<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Chapter 7 Addressing model lack of fit | Bayesian analysis of capture-recapture data with hidden Markov models</title>
<meta name="author" content="Olivier Gimenez">
<meta name="description" content="7.1 Introduction Capture-recapture models rely on assumptions that must hold for inference to be reliable. In Section 4.7, we saw what can go wrong and how to diagnose those issues. In this...">
<meta name="generator" content="bookdown 0.43 with bs4_book()">
<meta property="og:title" content="Chapter 7 Addressing model lack of fit | Bayesian analysis of capture-recapture data with hidden Markov models">
<meta property="og:type" content="book">
<meta property="og:url" content="https://oliviergimenez.github.io/banana-book/lackoffit.html">
<meta property="og:description" content="7.1 Introduction Capture-recapture models rely on assumptions that must hold for inference to be reliable. In Section 4.7, we saw what can go wrong and how to diagnose those issues. In this...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter 7 Addressing model lack of fit | Bayesian analysis of capture-recapture data with hidden Markov models">
<meta name="twitter:description" content="7.1 Introduction Capture-recapture models rely on assumptions that must hold for inference to be reliable. In Section 4.7, we saw what can go wrong and how to diagnose those issues. In this...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.9.0/transition.js"></script><script src="libs/bs3compat-0.9.0/tabs.js"></script><script src="libs/bs3compat-0.9.0/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<style type="text/css">
    /* Used with Pandoc 2.11+ new --citeproc when CSL is used */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
          margin-bottom: 0em;
        }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
<link rel="stylesheet" href="bs4_style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="Theory and case studies in R and NIMBLE">Bayesian analysis of capture-recapture data with hidden Markov models</a>:
        <small class="text-muted">Theory and case studies in R and NIMBLE</small>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Welcome</a></li>
<li><a class="" href="preface.html">Preface</a></li>
<li class="book-part">Foundations</li>
<li><a class="" href="introduction.html">Introduction</a></li>
<li><a class="" href="crashcourse.html"><span class="header-section-number">1</span> Bayesian statistics &amp; MCMC</a></li>
<li><a class="" href="intronimble.html"><span class="header-section-number">2</span> NIMBLE tutorial</a></li>
<li><a class="" href="hmmcapturerecapture.html"><span class="header-section-number">3</span> Hidden Markov models</a></li>
<li class="book-part">Transitions</li>
<li><a class="" href="introduction-4.html">Introduction</a></li>
<li><a class="" href="survival.html"><span class="header-section-number">4</span> Alive and dead</a></li>
<li><a class="" href="dispersal.html"><span class="header-section-number">5</span> Sites and states</a></li>
<li class="book-part">Case studies</li>
<li><a class="" href="introduction-7.html">Introduction</a></li>
<li><a class="" href="covariateschapter.html"><span class="header-section-number">6</span> Dealing with covariates</a></li>
<li><a class="active" href="lackoffit.html"><span class="header-section-number">7</span> Addressing model lack of fit</a></li>
<li><a class="" href="tradeoffs.html"><span class="header-section-number">8</span> Quantifying life history traits</a></li>
<li><a class="" href="conclusion.html">Conclusion</a></li>
<li><a class="" href="references.html">References</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/oliviergimenez/banana-book">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="lackoffit" class="section level1" number="7">
<h1>
<span class="header-section-number">7</span> Addressing model lack of fit<a class="anchor" aria-label="anchor" href="#lackoffit"><i class="fas fa-link"></i></a>
</h1>
<div id="introduction-9" class="section level2" number="7.1">
<h2>
<span class="header-section-number">7.1</span> Introduction<a class="anchor" aria-label="anchor" href="#introduction-9"><i class="fas fa-link"></i></a>
</h2>
<p>Capture-recapture models rely on assumptions that must hold for inference to be reliable. In Section <a href="survival.html#gof">4.7</a>, we saw what can go wrong and how to diagnose those issues. In this chapter, we turn to remedies and show how to fix them by building models that explicitly accommodate lack of fit. We focus on three topics: trap-dependence (detection today affects detection tomorrow), memory in the state process (the Markov assumption is too short – transitions depend on more than the current state), and individual heterogeneity (persistent differences among animals).</p>
</div>
<div id="trapdep" class="section level2" number="7.2">
<h2>
<span class="header-section-number">7.2</span> Accounting for trap-dependence<a class="anchor" aria-label="anchor" href="#trapdep"><i class="fas fa-link"></i></a>
</h2>
<div id="motivation-3" class="section level3" number="7.2.1">
<h3>
<span class="header-section-number">7.2.1</span> Motivation<a class="anchor" aria-label="anchor" href="#motivation-3"><i class="fas fa-link"></i></a>
</h3>
<p>Capture-recapture inference can go sideways when detection depends on past capture. If animals become trap‐shy (avoid traps) or trap‐happy (seek them) after being caught, the independence assumption breaks, and survival or detection can be biased if we ignore it. Tests for this trap‐dependence exist, see Section <a href="survival.html#gof">4.7</a>, and surveys show it’s common across taxa – roughly 70% of reviewed studies reported evidence for it <span class="citation">(<a href="references.html#ref-pradeltrapdep2012">Pradel and Sanz-Aguilar 2012</a>)</span>.</p>
<p>The fix is to encode the behavioural response. Following <span class="citation">Pradel and Sanz-Aguilar (<a href="references.html#ref-pradeltrapdep2012">2012</a>)</span>, we treat trap‐awareness as a (possibly temporary) state: right after a capture, individuals move to a ‘trap‐aware’ state with its own detection probability, so that detection at time <span class="math inline">\(t+1\)</span> can differ for animals caught vs. not caught at <span class="math inline">\(t\)</span>. This HMM formulation avoids awkward data splitting, and plays nicely with age or covariates. Importantly, in the authors’ example, ignoring trap‐dependence underestimated survival, illustrating why modelling trap-dependence matters.</p>
<p>Here, I adopt that logic in NIMBLE: define a trap‐aware state, let detection depend on it, and keep the rest of the HMM machinery unchanged.</p>
</div>
<div id="model-and-nimble-implementation-3" class="section level3" number="7.2.2">
<h3>
<span class="header-section-number">7.2.2</span> Model and NIMBLE implementation<a class="anchor" aria-label="anchor" href="#model-and-nimble-implementation-3"><i class="fas fa-link"></i></a>
</h3>
<p>For our example, we’ll work with data from 519 encounter histories of Cory’s shearwaters (<em>Calonectris diomedea</em>) marked as adults between 2001 and 2008 at Pantaleu Islet (Balearic Archipelago, Spain). These data were kindly provided by Ana Sanz-Aguilar. If you perform goodness-of-fit tests on this dataset, as in Section <a href="survival.html#gof">4.7</a>, you will end up with a significant trap-dependence effect (as well as a transience effect). To build up our model and explicitly account for this lack of fit, we first define the states and observations:</p>
<ul>
<li><p>States<br>
- A for ‘trap-aware’, the original state of an individual when it is first released<br>
- U for ‘trap-unaware’, which follows any occasion where it is not captured<br>
- D for dead</p></li>
<li><p>Observations<br>
- not detected (1)<br>
- detected (2)</p></li>
</ul>
<p>Now we turn to writing our model. We start with the vector of initial states. Individuals enter as trap-aware with probability 1:
<span class="math display">\[\begin{matrix}
&amp; \\
\mathbf{\delta} =
\left ( \vphantom{ \begin{matrix} 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
z_t=A &amp; z_t=U &amp; z_t=D \\ \hdashline
1 &amp; 0 &amp; 0\\
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
&amp; \\
\left . \vphantom{ \begin{matrix} 12 \end{matrix} } \right )
\begin{matrix}
\end{matrix}
\end{matrix}\]</span></p>
<p>We proceed with the transition matrix:
<span class="math display">\[\begin{matrix}
&amp; \\
\mathbf{\Gamma} =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
z_t=A &amp; z_t=U &amp; z_t=D \\ \hdashline
\phi p' &amp; \phi (1-p') &amp; 1 - \phi\\
\phi p &amp; \phi (1-p) &amp; 1 - \phi\\
0 &amp; 0 &amp; 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
&amp; \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t-1}=A \\ z_{t-1}=U \\ z_{t-1}=D
\end{matrix}
\end{matrix}\]</span></p>
<p>You might have noticed something ususual in that <span class="math inline">\(\mathbf{\Gamma}\)</span> contains both the survival and detection probabilities. Why is that? We track three hidden states from the end of session <span class="math inline">\(t\)</span> to <span class="math inline">\(t+1\)</span>: <span class="math inline">\(A =\)</span> trap-aware (the bird was just caught at <span class="math inline">\(t\)</span>), <span class="math inline">\(U =\)</span> trap-unaware (not caught at <span class="math inline">\(t\)</span>), and <span class="math inline">\(D =\)</span> dead. Between sessions, everyone either survives with probability <span class="math inline">\(\phi\)</span> or dies with <span class="math inline">\(1 - \phi\)</span> (which moves them to <span class="math inline">\(D\)</span>, an absorbing state). If alive at <span class="math inline">\(t+1\)</span>, the awareness flag for the next session is set by whether the bird gets caught at <span class="math inline">\(t+1\)</span>: those caught will be <span class="math inline">\(A\)</span> next time, those not caught will be <span class="math inline">\(U\)</span>. Because capture probabilities can differ by current awareness, we allow <span class="math inline">\(p'\)</span> for birds that were <span class="math inline">\(A\)</span> at <span class="math inline">\(t\)</span> and <span class="math inline">\(p\)</span> for birds that were <span class="math inline">\(U\)</span> at <span class="math inline">\(t\)</span>. If <span class="math inline">\(p'&gt;p\)</span> you have trap-happy behaviour (recently caught birds are easier to catch next time); if <span class="math inline">\(p'&lt;p\)</span>, it’s trap-shy. This ‘survive -&gt; update awareness via capture’ factorization is what the transition matrix formalizes.</p>
<p>Following the paper, adult survival is age-specific to account for a transient effect, see Section <a href="survival.html#gof">4.7</a>:</p>
<div class="sourceCode" id="cb336"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Transition matrix</span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">N</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="kw">for</span> <span class="op">(</span><span class="va">t</span> <span class="kw">in</span> <span class="va">first</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">:</span><span class="op">(</span><span class="va">K</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>      <span class="va">phi</span><span class="op">[</span><span class="va">i</span>,<span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">beta</span><span class="op">[</span><span class="va">age</span><span class="op">[</span><span class="va">i</span>,<span class="va">t</span><span class="op">]</span><span class="op">]</span> <span class="co"># beta1 = phi1, beta2 = phi2+</span></span>
<span>      <span class="va">gamma</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="va">i</span>,<span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi</span><span class="op">[</span><span class="va">i</span>,<span class="va">t</span><span class="op">]</span> <span class="op">*</span> <span class="va">pprime</span></span>
<span>      <span class="va">gamma</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="va">i</span>,<span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi</span><span class="op">[</span><span class="va">i</span>,<span class="va">t</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">pprime</span><span class="op">)</span></span>
<span>      <span class="va">gamma</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">3</span>,<span class="va">i</span>,<span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">phi</span><span class="op">[</span><span class="va">i</span>,<span class="va">t</span><span class="op">]</span></span>
<span>      <span class="va">gamma</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span>,<span class="va">i</span>,<span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi</span><span class="op">[</span><span class="va">i</span>,<span class="va">t</span><span class="op">]</span> <span class="op">*</span> <span class="va">p</span></span>
<span>      <span class="va">gamma</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">2</span>,<span class="va">i</span>,<span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi</span><span class="op">[</span><span class="va">i</span>,<span class="va">t</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">p</span><span class="op">)</span></span>
<span>      <span class="va">gamma</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">3</span>,<span class="va">i</span>,<span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">phi</span><span class="op">[</span><span class="va">i</span>,<span class="va">t</span><span class="op">]</span> </span>
<span>      <span class="va">gamma</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">1</span>,<span class="va">i</span>,<span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>      <span class="va">gamma</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">2</span>,<span class="va">i</span>,<span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span> </span>
<span>      <span class="va">gamma</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">i</span>,<span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span></span>
<span>    <span class="op">}</span></span>
<span>  <span class="op">}</span></span></code></pre></div>
<p>In the code above, age is passed in the data and created as follows:</p>
<div class="sourceCode" id="cb337"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Age effect via an individual x time covariate and use of nested indexing </span></span>
<span><span class="co"># to distinguish survival over the interval after first detection from survival afterwards: </span></span>
<span><span class="va">age</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="cn">NA</span>, nrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">age</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">age</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="va">j</span> <span class="op">==</span> <span class="va">first</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span> <span class="va">age</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="co"># age = 1</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="va">j</span> <span class="op">&gt;</span> <span class="va">first</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span> <span class="va">age</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span>  <span class="co"># age &gt; 1</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Last step is the observation matrix:
<span class="math display">\[\begin{matrix}
&amp; \\
\mathbf{\Omega} =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
y_t=1 &amp; y_t=2 \\ \hdashline
0 &amp; 1 \\
1 &amp; 0 \\
1 &amp; 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
&amp; \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t}=A \\ z_{t}=U \\ z_{t}=D
\end{matrix}
\end{matrix}\]</span></p>
<p>If an animal is trap-aware at <span class="math inline">\(t\)</span>, that means that it has just been captured. If it is trap unaware or dead, it has not been captured during this session. In code, we write:</p>
<div class="sourceCode" id="cb338"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Observation matrix</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span></code></pre></div>
<p>The likelihood and priors are handled as usual.</p>
</div>
<div id="results-and-interpretation-3" class="section level3" number="7.2.3">
<h3>
<span class="header-section-number">7.2.3</span> Results and interpretation<a class="anchor" aria-label="anchor" href="#results-and-interpretation-3"><i class="fas fa-link"></i></a>
</h3>
<p>Here are the raw results with trap-dependence:</p>
<pre><code>##        mean   sd 2.5%  50% 97.5% Rhat n.eff
## p      0.45 0.06 0.34 0.45  0.56 1.00   126
## phi1   0.76 0.02 0.71 0.76  0.80 1.00   395
## phi2   0.87 0.02 0.84 0.87  0.91 1.01   173
## pprime 0.79 0.02 0.75 0.79  0.82 1.00   183</code></pre>
<p>The two detection probabilities, depending on whether a bird was previously caught or not, differ clearly, providing evidence of trap-happiness. Our survival estimates are very similar to those obtained by <span class="citation">Pradel and Sanz-Aguilar (<a href="references.html#ref-pradeltrapdep2012">2012</a>)</span> who found <span class="math inline">\(\phi_1 = 0.77\; (0.70, 0.82)\)</span> and <span class="math inline">\(\phi_2 = 0.87\; (0.82,0.90)\)</span> (check out their Table 1). Interestingly, when we fit the same model by ignoring trap-dependence, we get the following results:</p>
<pre><code>##      mean   sd 2.5%  50% 97.5% Rhat n.eff
## p    0.78 0.02 0.75 0.78  0.81 1.00   489
## phi1 0.74 0.02 0.70 0.74  0.79 1.00   615
## phi2 0.84 0.01 0.82 0.84  0.87 1.01   569</code></pre>
<p>When compared the our previous estimates, we see that ignoring trap-dependence leads to an underestimation of survival, either <span class="math inline">\(\phi_1\)</span> the transient survival or <span class="math inline">\(\phi_{2}\)</span> the resident survival.</p>
<p>The approach described here can be conveniently extended to several sites or states, see <span class="citation">Pradel and Sanz-Aguilar (<a href="references.html#ref-pradeltrapdep2012">2012</a>)</span>.</p>
</div>
</div>
<div id="memorymodel" class="section level2" number="7.3">
<h2>
<span class="header-section-number">7.3</span> Allowing your Markov models to remember<a class="anchor" aria-label="anchor" href="#memorymodel"><i class="fas fa-link"></i></a>
</h2>
<div id="motivation-4" class="section level3" number="7.3.1">
<h3>
<span class="header-section-number">7.3.1</span> Motivation<a class="anchor" aria-label="anchor" href="#motivation-4"><i class="fas fa-link"></i></a>
</h3>
<p>How do we make our models remember? So far, the dynamics of our states have been first-order Markov: the state an animal moves to next depends only on the state it occupies now. But if we think of states as sites, transitions are dispersal or migration, and many species show site fidelity or directional return that reflects where they were several steps back.</p>
<p>To relax the first-order assumption, we move to a second-order Markov description, and what happens at <span class="math inline">\(t+1\)</span> depends on the site at <span class="math inline">\(t\)</span> and at <span class="math inline">\(t−1\)</span>. This idea, often called a memory model, was introduced in multisite capture-recapture by <span class="citation">Hestbeck, Nichols, and Malecki (<a href="references.html#ref-hestbeck1991estimates">1991</a>)</span> and <span class="citation">Brownie et al. (<a href="references.html#ref-BrownieEtAl1993">1993</a>)</span>, then formulated cleanly within the HMM framework by <span class="citation">Pradel (<a href="references.html#ref-pradel_multievent_2005">2005</a>)</span> and <span class="citation">Rouan, Choquet, and Pradel (<a href="references.html#ref-rouan2009memory">2009</a>)</span>.</p>
<p>To illustrate the memory model, we will use the geese data introduced in Chapter <a href="dispersal.html#dispersal">5</a>. As we saw in Section <a href="dispersal.html#gofas">5.3.3</a>, there is a strong positive association between the site where an animal was last seen and the site where it will next be seen. This suggests that a first-order model is too simple and that transitions at <span class="math inline">\(t+1\)</span> should not only depend on <span class="math inline">\(t\)</span> but also <span class="math inline">\(t-1\)</span>.</p>
</div>
<div id="model-and-nimble-implementation-4" class="section level3" number="7.3.2">
<h3>
<span class="header-section-number">7.3.2</span> Model and NIMBLE implementation<a class="anchor" aria-label="anchor" href="#model-and-nimble-implementation-4"><i class="fas fa-link"></i></a>
</h3>
<p>As a reminder, the two main ingredients for a HMM capturing dispersal between 2 sites are a transition matrix:
<span class="math display">\[\begin{matrix}
&amp; \\
\mathbf{\Gamma} =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
z_t=A &amp; z_t=B &amp; z_t=D \\ \hdashline
\phi^A (1-\psi^{AB}) &amp; \phi^A \psi^{AB} &amp; 1 - \phi^A\\
\phi^B \psi^{BA} &amp; \phi^B (1-\psi^{BA}) &amp; 1 - \phi^B\\
0 &amp; 0 &amp; 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
&amp; \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t-1}=A \\ z_{t-1}=B \\ z_{t-1}=D
\end{matrix}
\end{matrix}\]</span></p>
<p>and an observation matrix:
<span class="math display">\[\begin{matrix}
&amp; \\
\mathbf{\Omega} =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
y_t=1 &amp; y_t=2 &amp; y_t=3 \\ \hdashline
1 - p^A &amp; p^A &amp; 0\\
1 - p^B &amp; 0 &amp; p^B\\
1 &amp; 0 &amp; 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
&amp; \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t}=A \\ z_{t}=B \\ z_{t}=D
\end{matrix}
\end{matrix}\]</span></p>
<p>From here, how to come up with a HMM formulation of the memory model? We need to keep track of the sites previously visited, and to do so, the trick is to consider states as being pairs of sites occupied:</p>
<ul>
<li>States
<ul>
<li>AA is for alive in site A at <span class="math inline">\(t\)</span> and alive in site A at <span class="math inline">\(t-1\)</span><br>
</li>
<li>AB is for alive in site A at <span class="math inline">\(t\)</span> and alive in site B at <span class="math inline">\(t-1\)</span><br>
</li>
<li>BA is for alive in site B at <span class="math inline">\(t\)</span> and alive in site A at <span class="math inline">\(t-1\)</span><br>
</li>
<li>BB is for alive in site B at <span class="math inline">\(t\)</span> and alive in site B at <span class="math inline">\(t-1\)</span><br>
</li>
<li>D is for dead</li>
</ul>
</li>
<li>Observations
<ul>
<li>1 not captured<br>
</li>
<li>2 captured at site A<br>
</li>
<li>3 captured at site B</li>
</ul>
</li>
</ul>
<p>Now we turn to writing our model. We start with the vector of initial states. Individuals enter the study with probabilities:
<span class="math display">\[\begin{matrix}
&amp; \\
\mathbf{\delta} =
\left ( \vphantom{ \begin{matrix} 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
z_t=AA &amp; z_t=AB &amp; z_t=BA &amp; z_t=BB &amp;z_t=D \\ \hdashline
\pi^{AA} &amp; \pi^{AB} &amp; \pi^{BA} &amp; \pi^{BB} &amp; 0\\
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
&amp; \\
\left . \vphantom{ \begin{matrix} 12 \end{matrix} } \right )
\begin{matrix}
\end{matrix}
\end{matrix}\]</span></p>
<p>where <span class="math inline">\(\pi^{ij}\)</span> is the probability of being alive at site <span class="math inline">\(j\)</span> when first captured and site <span class="math inline">\(i\)</span> before, and <span class="math inline">\(\pi^{BB} = 1 - (\pi^{AA} + \pi^{AB} + \pi^{BA})\)</span>.</p>
<p>We proceed with the transition matrix that contains the survival and movement probabilities:
<span class="math display">\[\begin{matrix}
&amp; \\
\mathbf{\Gamma} =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12\end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
z_t=AA &amp; z_t=AB &amp; z_t=BA &amp; z_t=BB &amp; z_t=D \\ \hdashline
\phi^{AAA} &amp; \phi^{AAB} &amp; 0 &amp; 0 &amp; 1 - \phi^{AAA} - \phi^{AAB}\\
0 &amp; 0 &amp; \phi^{ABA} &amp; \phi^{ABB} &amp; 1 - \phi^{ABA} - \phi^{ABB}\\
\phi^{BAA} &amp; \phi^{BAB} &amp; 0 &amp; 0 &amp; 1 - \phi^{BAA} - \phi^{BAB}\\
0 &amp; 0 &amp; \phi^{BBA} &amp; \phi^{BBB} &amp; 1 - \phi^{BBA} - \phi^{BBB}\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
&amp; \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12\end{matrix} } \right )
\begin{matrix}
z_{t-1}=AA \\ z_{t-1}=AB \\ z_{t-1}=BA \\ z_{t-1}=BB \\ z_{t-1}=D
\end{matrix}
\end{matrix}\]</span></p>
<p>where <span class="math inline">\(\phi^{ijk}\)</span> is the probability to be in site <span class="math inline">\(k\)</span> at time <span class="math inline">\(t + 1\)</span> for an individual
present in site <span class="math inline">\(j\)</span> at <span class="math inline">\(t\)</span> and in site <span class="math inline">\(i\)</span> at <span class="math inline">\(t - 1\)</span>.</p>
<p>An alternate parameterization for <span class="math inline">\(\mathbf{\Gamma}\)</span> is:
<span class="math display">\[\begin{matrix}
&amp; \\
\mathbf{\Gamma} =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12\end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
z_t=AA &amp; z_t=AB &amp; z_t=BA &amp; z_t=BB &amp; z_t=D \\ \hdashline
\phi \psi^{AAA} &amp; \phi (1 - \psi^{AAA}) &amp; 0 &amp; 0 &amp; 1 - \phi\\
0 &amp; 0 &amp; \phi (1 - \psi^{ABB}) &amp; \phi \psi^{ABB} &amp; 1 - \phi\\
\phi \psi^{BAA} &amp; \phi (1 - \psi^{BAA}) &amp; 0 &amp; 0 &amp; 1 - \phi\\
0 &amp; 0 &amp; \phi (1-\psi^{BBB}) &amp; \phi \psi^{BBB} &amp; 1 - \phi\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
&amp; \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12\end{matrix} } \right )
\begin{matrix}
z_{t-1}=AA \\ z_{t-1}=AB \\ z_{t-1}=BA \\ z_{t-1}=BB \\ z_{t-1}=D
\end{matrix}
\end{matrix}\]</span></p>
<p>in which <span class="math inline">\(\phi\)</span> is the probability of surviving from one occasion to the next, and <span class="math inline">\(\psi_{ijj}\)</span> is the probability an animal stays at the same site <span class="math inline">\(j\)</span> given that it was at site <span class="math inline">\(i\)</span> on the previous occasion.</p>
<p>Last step is the observation matrix, which we write as follows:
<span class="math display">\[\begin{matrix}
&amp; \\
\mathbf{\Omega} =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12\end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
y_t=1 &amp; y_t=2 &amp; y_t=3 \\ \hdashline
1 - p^A &amp; p^A &amp; 0\\
1 - p^B &amp; 0 &amp; p^B\\
1 - p^A &amp; p^A &amp; 0\\
1 - p^B &amp; 0 &amp; p^B\\
1 &amp; 0 &amp; 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
&amp; \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12\end{matrix} } \right )
\begin{matrix}
z_t=AA \\ z_t=AB \\ z_t=BA \\ z_t=BB \\ z_t=D
\end{matrix}
\end{matrix}\]</span></p>
<p>To implement this model in NIMBLE, we’re going to use <code>nimbleEcology</code>, which makes our life much easier as we do not have to initialize the latent states <span class="math inline">\(z\)</span> – remember the likelihood is marginalized, see Sections <a href="hmmcapturerecapture.html#marginalization">3.8</a> and <a href="hmmcapturerecapture.html#nimbleecologyintro">3.8.3.2</a>. Specifically, we use the function <code><a href="https://rdrr.io/pkg/nimbleEcology/man/dHMM.html">dHMM()</a></code> that implements the distribution of a HMM with constant parameters. We also use a Dirichlet prior to ensure that the initial state probabilities and the survival-movement probabilities sum up to 1 and lie between 0 and 1, see Section <a href="dispersal.html#dirichletprior">5.4.1</a>. The code is as follows:</p>
<div class="sourceCode" id="cb341"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">multisite.marginalized</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/nimble/man/nimbleCode.html">nimbleCode</a></span><span class="op">(</span><span class="op">{</span></span>
<span>  </span>
<span>  <span class="co"># -------------------------------------------------</span></span>
<span>  <span class="co"># Parameters:</span></span>
<span>  <span class="co"># phi111: survival-mov probability from state 11 to state 11</span></span>
<span>  <span class="co"># phi112: survival-mov probability from state 11 to state 12</span></span>
<span>  <span class="co"># phi121: survival-mov probability from state 12 to state 21</span></span>
<span>  <span class="co"># phi122: survival-mov probability from state 12 to state 22</span></span>
<span>  <span class="co"># phi211: survival-mov probability from state 21 to state 11</span></span>
<span>  <span class="co"># phi212: survival-mov probability from state 21 to state 12</span></span>
<span>  <span class="co"># phi221: survival-mov probability from state 22 to state 21</span></span>
<span>  <span class="co"># phi222: survival-mov probability from state 22 to state 22</span></span>
<span>  <span class="co"># det1: detection probability site 1</span></span>
<span>  <span class="co"># det2: detection probability site 2</span></span>
<span>  <span class="co"># pi11: init stat prob 11</span></span>
<span>  <span class="co"># pi12: init stat prob 12</span></span>
<span>  <span class="co"># pi21: init stat prob 21</span></span>
<span>  <span class="co"># pi22: init stat prob 22</span></span>
<span>  <span class="co"># -------------------------------------------------</span></span>
<span>  <span class="co"># States (S):</span></span>
<span>  <span class="co"># 1 alive 11</span></span>
<span>  <span class="co"># 2 alive 12</span></span>
<span>  <span class="co"># 3 alive 21</span></span>
<span>  <span class="co"># 4 alive 22</span></span>
<span>  <span class="co"># 5 dead</span></span>
<span>  <span class="co"># Observations (O):  </span></span>
<span>  <span class="co"># 1 not seen</span></span>
<span>  <span class="co"># 2 seen at site 1 </span></span>
<span>  <span class="co"># 3 seen at site 2</span></span>
<span>  <span class="co"># -------------------------------------------------</span></span>
<span>  </span>
<span>  <span class="co"># priors</span></span>
<span>  <span class="va">det1</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">dunif</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span></span>
<span>  <span class="va">det2</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">dunif</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span></span>
<span>  <span class="va">phi11</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/nimble/man/Dirichlet.html">ddirch</a></span><span class="op">(</span><span class="va">alpha</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span> <span class="co"># phi111, phi112, 1-sum</span></span>
<span>  <span class="va">phi12</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/nimble/man/Dirichlet.html">ddirch</a></span><span class="op">(</span><span class="va">alpha</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span> <span class="co"># phi121, phi122, 1-sum</span></span>
<span>  <span class="va">phi21</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/nimble/man/Dirichlet.html">ddirch</a></span><span class="op">(</span><span class="va">alpha</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span> <span class="co"># phi211, phi212, 1-sum</span></span>
<span>  <span class="va">phi22</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/nimble/man/Dirichlet.html">ddirch</a></span><span class="op">(</span><span class="va">alpha</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span> <span class="co"># phi221, phi222, 1-sum</span></span>
<span>  </span>
<span>  <span class="co"># probabilities of state z(t+1) given z(t)</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi11</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi11</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi11</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi12</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi12</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi12</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi21</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi21</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi21</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi22</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi22</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi22</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">5</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">5</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">5</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">5</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">5</span>,<span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span></span>
<span>  </span>
<span>  <span class="co"># probabilities of y(t) given z(t)</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">det1</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">det1</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">det2</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">det2</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">det1</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">det1</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">det2</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">4</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">det2</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">5</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">5</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">5</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  </span>
<span>  <span class="co"># initial state probs</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">N</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">init</span><span class="op">[</span><span class="va">i</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">gamma</span><span class="op">[</span> <span class="va">y</span><span class="op">[</span><span class="va">i</span>, <span class="va">first</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">]</span> <span class="op">-</span> <span class="fl">1</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span> <span class="op">]</span> <span class="co"># first state propagation</span></span>
<span>  <span class="op">}</span></span>
<span>  </span>
<span>  <span class="co"># likelihood </span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">N</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">y</span><span class="op">[</span><span class="va">i</span>,<span class="op">(</span><span class="va">first</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="va">K</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/nimbleEcology/man/dHMM.html">dHMM</a></span><span class="op">(</span>init <span class="op">=</span> <span class="va">init</span><span class="op">[</span><span class="va">i</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span>,           <span class="co"># count data from first[i] + 1</span></span>
<span>                               probObs <span class="op">=</span> <span class="va">omega</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span>,     <span class="co"># observation matrix</span></span>
<span>                               probTrans <span class="op">=</span> <span class="va">gamma</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span>,   <span class="co"># transition matrix</span></span>
<span>                               len <span class="op">=</span> <span class="va">K</span> <span class="op">-</span> <span class="va">first</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>,           <span class="co"># nb of occasions</span></span>
<span>                               checkRowSums <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>             <span class="co"># do not check whether elements in a row sum tp 1</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span><span class="op">)</span></span></code></pre></div>
</div>
<div id="results-and-interpretation-4" class="section level3" number="7.3.3">
<h3>
<span class="header-section-number">7.3.3</span> Results and interpretation<a class="anchor" aria-label="anchor" href="#results-and-interpretation-4"><i class="fas fa-link"></i></a>
</h3>
<p>The raw results are:</p>
<pre><code>##          mean   sd 2.5%  50% 97.5% Rhat n.eff
## det1     0.45 0.01 0.43 0.45  0.47 1.01   296
## det2     0.41 0.01 0.39 0.41  0.42 1.05   244
## phi11[1] 0.50 0.01 0.49 0.50  0.52 1.00   478
## phi11[2] 0.16 0.01 0.15 0.16  0.17 1.01   834
## phi11[3] 0.34 0.01 0.32 0.34  0.35 1.00   565
## phi12[1] 0.10 0.00 0.09 0.10  0.11 1.00   496
## phi12[2] 0.57 0.01 0.55 0.57  0.59 1.02   382
## phi12[3] 0.33 0.01 0.32 0.34  0.35 1.02   421
## phi21[1] 0.36 0.03 0.31 0.36  0.42 1.00   900
## phi21[2] 0.33 0.03 0.27 0.33  0.38 1.01  1149
## phi21[3] 0.31 0.03 0.24 0.31  0.37 1.01   932
## phi22[1] 0.06 0.00 0.05 0.06  0.07 1.00   676
## phi22[2] 0.63 0.01 0.61 0.63  0.64 1.01  1140
## phi22[3] 0.31 0.01 0.30 0.31  0.33 1.00   965</code></pre>
<p>which we can reaarange as in Table <a href="lackoffit.html#tab:memoryres">7.1</a> to the results obtained by <span class="citation">Pradel (<a href="references.html#ref-pradel_multievent_2005">2005</a>)</span> in his Table 1:</p>
<div class="inline-table"><table class="table table-sm">
<caption>
<span id="tab:memoryres">Table 7.1: </span>Second-order (memory) estimates of transition probabilities. The first column gives the Transition made in <span class="math inline">\(t\)</span> to <span class="math inline">\(t+1\)</span> where M is for mid–Atlantic and C for Chesapeake. The second column gives the Condition that is whether the location at <span class="math inline">\(t+1\)</span> is Equal or Not equal to the location at <span class="math inline">\(t-1\)</span>. The Pradel (2005) time-averaged estimates are given in the third column. Our NIMBLE estimates (mean and 95% credible interval) are given in the fourth column.</caption>
<colgroup>
<col width="16%">
<col width="25%">
<col width="32%">
<col width="26%">
</colgroup>
<thead><tr class="header">
<th align="left">Transition</th>
<th align="left">Condition</th>
<th align="center">Pradel (avg 1985–88)</th>
<th align="center">NIMBLE</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">MM</td>
<td align="left">Equal to t-1</td>
<td align="center">0.57</td>
<td align="center">0.50 (0.49–0.52)</td>
</tr>
<tr class="even">
<td align="left">MM</td>
<td align="left">Not equal to t-1</td>
<td align="center">0.33</td>
<td align="center">0.36 (0.31–0.42)</td>
</tr>
<tr class="odd">
<td align="left">MC</td>
<td align="left">Equal to t-1</td>
<td align="center">0.27</td>
<td align="center">0.33 (0.27–0.38)</td>
</tr>
<tr class="even">
<td align="left">MC</td>
<td align="left">Not equal to t-1</td>
<td align="center">0.09</td>
<td align="center">0.16 (0.15–0.17)</td>
</tr>
<tr class="odd">
<td align="left">CM</td>
<td align="left">Equal to t-1</td>
<td align="center">0.21</td>
<td align="center">0.10 (0.09–0.11)</td>
</tr>
<tr class="even">
<td align="left">CM</td>
<td align="left">Not equal to t-1</td>
<td align="center">0.05</td>
<td align="center">0.06 (0.05–0.07)</td>
</tr>
<tr class="odd">
<td align="left">CC</td>
<td align="left">Equal to t-1</td>
<td align="center">0.63</td>
<td align="center">0.63 (0.61–0.64)</td>
</tr>
<tr class="even">
<td align="left">CC</td>
<td align="left">Not equal to t-1</td>
<td align="center">0.48</td>
<td align="center">0.57 (0.55–0.59)</td>
</tr>
</tbody>
</table></div>
<p>In both analyses, memory is real: for each transition, the probability is higher when the destination at <span class="math inline">\(t+1\)</span> matches where the bird was at <span class="math inline">\(t−1\)</span> (‘Equal to <span class="math inline">\(t-1\)</span>’ rows) than when it doesn’t (‘Not equal to <span class="math inline">\(t-1\)</span>’ rows). That’s site fidelity or directional return. Our fit mirrors Pradel’s fit especially well for staying in Chesapeake (CC, equal: 0.63 in both) and still shows a clear memory signal for staying in mid-Atlantic (MM, 0.50 vs 0.57 when equal). Moves also carry memory: MC is more likely when the bird was in C two steps back (0.33 vs 0.16), and CM shows a weaker but similar pattern (0.10 vs 0.06).</p>
<p>Where we differ is in the directional balance. Relative to Pradel’s averages, our model leans more toward Chesapeake: we estimate higher MC probabilities (both equal and not equal; e.g., 0.33 vs 0.27 and 0.16 vs 0.09) and lower CM (equal) (0.10 vs 0.21). We also find a higher chance of staying in C (CC, not equal: 0.57 vs 0.48). Several of these differences are well outside our 95% credible intervals (e.g., CM equal 0.09-0.11 vs 0.21, MC not equal 0.15-0.17 vs 0.09). These discrepancies are likely explained by the difference in model structures: ours assumes constant parameters, whereas Pradel’s allows them to vary over time. The big picture remains the same, though: movements are second–order and that memory is asymmetric, being strongest for persistence in Chesapeake and for moves toward it.</p>
</div>
</div>
<div id="indhet" class="section level2" number="7.4">
<h2>
<span class="header-section-number">7.4</span> Accomodating individual heterogeneity<a class="anchor" aria-label="anchor" href="#indhet"><i class="fas fa-link"></i></a>
</h2>
<div id="motivation-5" class="section level3" number="7.4.1">
<h3>
<span class="header-section-number">7.4.1</span> Motivation<a class="anchor" aria-label="anchor" href="#motivation-5"><i class="fas fa-link"></i></a>
</h3>
<p>I’ve worked with large carnivores for almost two decades, and they’re what pulled me into HMMs – especially gray wolves. Wolves are social, live in hierarchical packs, and that structure shows up in demography. It also shows up in how we detect them: dominant individuals use trails and roads more often, and that’s pretty much where we search for scats for DNA-based identification. The result is individual heterogeneity in detection, with some wolves being more detectable (via DNA) than others.</p>
<p>Shirley Pledger in a series of papers developed so–called mixture models in which individuals are assigned in two or more classes with class-specific survival/detection probabilities. If we ignore that variation, estimates can be biased and lack-of-fit tests light up. In <span class="citation">Cubaynes et al. (<a href="references.html#ref-cubaynes_importance_2010">2010</a>)</span>, we used an HMM formulation to capture heterogeneity in detection linked to social status <span class="citation">(see also <a href="references.html#ref-pradel2009">Pradel 2009</a>)</span>.</p>
<p>In what follows, I’ll show how to build and fit these finite–mixture HMMs using simulated data so we control the truth. This gives a practical template for dealing with heterogeneity whenever behavior or status makes some individuals easier (or more difficult) to find than others.</p>
<!-- ```{r pixwolf, echo=FALSE, fig.cap="Dominance in wolves.", fig.align='center'} -->
<!-- knitr::include_graphics("images/wolfdominance.jpg") -->
<!-- ``` -->
</div>
<div id="model-and-nimble-implementation-5" class="section level3" number="7.4.2">
<h3>
<span class="header-section-number">7.4.2</span> Model and NIMBLE implementation<a class="anchor" aria-label="anchor" href="#model-and-nimble-implementation-5"><i class="fas fa-link"></i></a>
</h3>
<p>To build up our model, we first define the states and observations:</p>
<ul>
<li>States
<ul>
<li>alive in class 1 (A1)</li>
<li>alive in class 2 (A2)</li>
<li>dead (D)</li>
</ul>
</li>
<li>Observations
<ul>
<li>not captured (1)</li>
<li>captured (2)</li>
</ul>
</li>
</ul>
<p>Now we turn to writing our model. We start with the vector of initial states. Individuals enter as a mixture of A1/A2:
<span class="math display">\[\begin{matrix}
&amp; \\
\mathbf{\delta} =
  \left ( \vphantom{ \begin{matrix} 12 \end{matrix} } \right .
          \end{matrix}
          \hspace{-1.2em}
          \begin{matrix}
          z_t=A1 &amp; z_t=A2 &amp; z_t=D \\ \hdashline
          \pi &amp; 1 - \pi &amp; 0\\
          \end{matrix}
          \hspace{-0.2em}
          \begin{matrix}
          &amp; \\
          \left . \vphantom{ \begin{matrix} 12 \end{matrix} } \right )
\begin{matrix}
\end{matrix}
\end{matrix}\]</span></p>
<p>where <span class="math inline">\(\pi\)</span> is the probability of being alive in A1, and <span class="math inline">\(1 - \pi\)</span> is the probability of being in A2.</p>
<p>We proceed with the transition matrix that contains the survival probabilities:
<span class="math display">\[\begin{matrix}
&amp; \\
\mathbf{\Gamma} =
  \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
          \end{matrix}
          \hspace{-1.2em}
          \begin{matrix}
          z_t=A1 &amp; z_t=A2 &amp; z_t=D \\ \hdashline
          \phi  &amp; 0 &amp; 1 - \phi\\
          0 &amp; \phi &amp; 1 - \phi\\
          0 &amp; 0 &amp; 1
          \end{matrix}
          \hspace{-0.2em}
          \begin{matrix}
          &amp; \\
          \left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t-1}=A1 \\ z_{t-1}=A2 \\ z_{t-1}=D
\end{matrix}
\end{matrix}\]</span></p>
<p>where <span class="math inline">\(\phi\)</span> is the survival probability. In NIMBLE, we write:</p>
<div class="sourceCode" id="cb343"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Transition matrix</span></span>
<span><span class="va">gamma</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi</span>      <span class="co"># A1(t)-&gt;A1(t+1)</span></span>
<span><span class="va">gamma</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span>        <span class="co"># A1(t)-&gt;A2(t+1)</span></span>
<span><span class="va">gamma</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">phi</span>  <span class="co"># A1(t)-&gt;D(t+1)</span></span>
<span><span class="va">gamma</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span>        <span class="co"># A2(t)-&gt;A1(t+1)</span></span>
<span><span class="va">gamma</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi</span>      <span class="co"># A2(t)-&gt;A2(t+1)</span></span>
<span><span class="va">gamma</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">phi</span>  <span class="co"># A2(t)-&gt;D(t+1)</span></span>
<span><span class="va">gamma</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span>        <span class="co"># D(t)-&gt;A1(t+1)</span></span>
<span><span class="va">gamma</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span>        <span class="co"># D(t)-&gt;A2(t+1)</span></span>
<span><span class="va">gamma</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span>        <span class="co"># D(t)-&gt;D(t+1)</span></span></code></pre></div>
<p>Survival could be made heterogeneous; to do so, we’d need to amend the transition matrix as follows:
<span class="math display">\[\begin{matrix}
&amp; \\
\mathbf{\Gamma} =
  \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
          \end{matrix}
          \hspace{-1.2em}
          \begin{matrix}
          z_t=A1 &amp; z_t=A2 &amp; z_t=D \\ \hdashline
          \phi (1-\psi^{12}) &amp; \phi \psi^{12} &amp; 1 - \phi\\
          \phi \psi^{21} &amp; \phi (1-\psi^{21}) &amp; 1 - \phi\\
          0 &amp; 0 &amp; 1
          \end{matrix}
          \hspace{-0.2em}
          \begin{matrix}
          &amp; \\
          \left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t-1}=A1 \\ z_{t-1}=A2 \\ z_{t-1}=D
\end{matrix}
\end{matrix}\]</span></p>
<p>where the <span class="math inline">\(psi\)</span>’s are the probabilities for an individual to change class of heterogeneity, with <span class="math inline">\(\psi^{12}\)</span> from A1 to A2, and <span class="math inline">\(\psi^{21}\)</span> from A2 to A1.</p>
<p>Last step is the observation matrix, which we write as follows:
<span class="math display">\[\begin{matrix}
&amp; \\
\mathbf{\Omega} =
  \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right .
          \end{matrix}
          \hspace{-1.2em}
          \begin{matrix}
          y_t=1 &amp; y_t=2\\ \hdashline
          1 - p^1 &amp; p^1\\
          1 - p^2 &amp; p^2\\
          1 &amp; 0
          \end{matrix}
          \hspace{-0.2em}
          \begin{matrix}
          &amp; \\
          \left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right )
\begin{matrix}
z_{t}=A1 \\ z_{t}=A2 \\ z_{t}=D
\end{matrix}
\end{matrix}\]</span></p>
<p>where <span class="math inline">\(p^1\)</span> is detection for individuals in A1, and <span class="math inline">\(p^2\)</span> that of individuals in A2. In NIMBLE, this translates into:</p>
<div class="sourceCode" id="cb344"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Observation matrix</span></span>
<span><span class="va">omega</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">p1</span>   <span class="co"># A1(t)-&gt;0(t)</span></span>
<span><span class="va">omega</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">p1</span>       <span class="co"># A1(t)-&gt;1(t)</span></span>
<span><span class="va">omega</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">p2</span>   <span class="co"># A2(t)-&gt;0(t)</span></span>
<span><span class="va">omega</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">p2</span>       <span class="co"># A2(t)-&gt;1(t)</span></span>
<span><span class="va">omega</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span>         <span class="co"># D(t)-&gt;0(t)</span></span>
<span><span class="va">omega</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span>         <span class="co"># D(t)-&gt;1(t)</span></span></code></pre></div>
<p>At first detection, the observation ‘not detected’ is impossible by construction (we condition on the first detection). We therefore use an initial observation matrix <span class="math inline">\(\mathbf{\Omega}_{\text{init}}\)</span> with <span class="math inline">\(p_1 = p_2\)</span> set to 1 (not shown).</p>
<p>Instead of real data, we will use simulated data, which is useful to identify problems in our analysis as we will illustrate below. We simulate a finite–mixture scenario where individuals differ in detection but share the same survival. Each animal is assigned to one of two latent classes: a small, highly detectable group (class A1; proportion <span class="math inline">\(\pi = 0.2\)</span>, <span class="math inline">\(p_1=0.8\)</span>) and a larger, less detectable group (class A2; proportion <span class="math inline">\(1-\pi = 0.8\)</span>, <span class="math inline">\(p_2=0.3\)</span>). Everyone starts captured at the first occasion (this mimics the CJS conditioning on first capture), then the latent alive state <span class="math inline">\(z_{i,t}\)</span> evolves with constant survival <span class="math inline">\(\phi = 0.7\)</span>. If an individual <span class="math inline">\(i\)</span> is alive at time <span class="math inline">\(t\)</span>, it’s observed with its own detection probability <span class="math inline">\(p_i\)</span> (either <span class="math inline">\(p_1\)</span> or <span class="math inline">\(p_2\)</span> depending on class). The result is a matrix of 0/1 encounter histories <span class="math inline">\(y\)</span> with built-in individual heterogeneity in detection, plus bookkeeping objects: <code>which_mixture</code> (true class), <code>detection</code> (each animal’s <span class="math inline">\(p_i\)</span>), and <code>z</code> (true alive states). We simulate the fate of 400 animals over 10 years.</p>
<div class="sourceCode" id="cb345"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Simulate encounter histories with individual heterogeneity (finite mixture)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span>           <span class="co"># for reproducibility</span></span>
<span></span>
<span><span class="co"># --- Parameters</span></span>
<span><span class="va">phi</span> <span class="op">&lt;-</span> <span class="fl">0.7</span>               <span class="co"># apparent survival (same for all)</span></span>
<span><span class="va">prop_class1</span> <span class="op">&lt;-</span> <span class="fl">0.2</span>       <span class="co"># mixture proportion pi: Pr(class 1)</span></span>
<span><span class="va">p_class1</span> <span class="op">&lt;-</span> <span class="fl">0.8</span>          <span class="co"># detection if in class 1 (high detectability)</span></span>
<span><span class="va">p_class2</span> <span class="op">&lt;-</span> <span class="fl">0.3</span>          <span class="co"># detection if in class 2 (low detectability)</span></span>
<span></span>
<span><span class="va">nind</span> <span class="op">&lt;-</span> <span class="fl">400</span>              <span class="co"># number of individuals</span></span>
<span><span class="va">nyear</span> <span class="op">&lt;-</span> <span class="fl">10</span>              <span class="co"># number of occasions</span></span>
<span></span>
<span><span class="co"># --- Storage</span></span>
<span><span class="va">z</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="va">nind</span>, <span class="va">nyear</span><span class="op">)</span>    <span class="co"># latent alive state</span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="va">nind</span>, <span class="va">nyear</span><span class="op">)</span>    <span class="co"># observed detections (0/1, with NAs before first)</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="va">nind</span>, <span class="va">nyear</span><span class="op">)</span>    <span class="co"># final encounter histories (0/1)</span></span>
<span><span class="va">first</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">nind</span><span class="op">)</span>           <span class="co"># first-capture occasion (here: all start at 1)</span></span>
<span><span class="va">detection</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="va">nind</span><span class="op">)</span>      <span class="co"># each individual’s p_i</span></span>
<span><span class="va">which_mixture</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="va">nind</span><span class="op">)</span>  <span class="co"># latent class: 1 or 0 (class 2)</span></span>
<span></span>
<span><span class="co"># --- Assign individuals to classes, then give them class-specific detection</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">nind</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">which_mixture</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">rbinom</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="va">prop_class1</span><span class="op">)</span> <span class="co"># 1 with prob pi, else 0</span></span>
<span>  <span class="va">detection</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="kw">if</span> <span class="op">(</span><span class="va">which_mixture</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span> <span class="va">p_class1</span> <span class="kw">else</span> <span class="va">p_class2</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># --- Generate latent states and observations</span></span>
<span><span class="co"># Everyone is alive and detected at first capture (CJS conditioning)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">nind</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">z</span><span class="op">[</span><span class="va">i</span>, <span class="va">first</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span></span>
<span>  <span class="va">x</span><span class="op">[</span><span class="va">i</span>, <span class="va">first</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span></span>
<span></span>
<span>  <span class="co"># From the second occasion on:</span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="op">(</span><span class="va">first</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="va">nyear</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="co"># Alive state: survive from previous if alive; else remain 0</span></span>
<span>    <span class="va">z</span><span class="op">[</span><span class="va">i</span>, <span class="va">j</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">rbinom</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="va">phi</span> <span class="op">*</span> <span class="va">z</span><span class="op">[</span><span class="va">i</span>, <span class="va">j</span> <span class="op">-</span> <span class="fl">1</span><span class="op">]</span><span class="op">)</span></span>
<span></span>
<span>    <span class="co"># Observation: if alive, detect with p_i; if dead, 0</span></span>
<span>    <span class="va">x</span><span class="op">[</span><span class="va">i</span>, <span class="va">j</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">rbinom</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="va">z</span><span class="op">[</span><span class="va">i</span>, <span class="va">j</span><span class="op">]</span> <span class="op">*</span> <span class="va">detection</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># --- Final encounter histories: replace NAs (before first) with 0</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="va">x</span></span>
<span><span class="va">y</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span></code></pre></div>
<p>The simulated data look like:</p>
<div class="sourceCode" id="cb346"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span></span>
<span><span class="co">##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]</span></span>
<span><span class="co">## [1,]    1    0    0    0    0    0    0    0    0     0</span></span>
<span><span class="co">## [2,]    1    0    0    0    0    0    0    0    0     0</span></span>
<span><span class="co">## [3,]    1    0    0    0    0    0    0    0    0     0</span></span>
<span><span class="co">## [4,]    1    0    1    0    0    0    0    0    0     0</span></span>
<span><span class="co">## [5,]    1    0    0    0    0    0    0    0    0     0</span></span>
<span><span class="co">## [6,]    1    1    0    0    0    0    0    0    0     0</span></span></code></pre></div>
<p>Now when I fit the model above to these data, I get the following results:</p>
<pre><code>##     mean   sd 2.5%  50% 97.5% Rhat n.eff
## phi 0.70 0.01 0.67 0.70  0.73 1.00  1074
## pi  0.70 0.03 0.63 0.70  0.76 1.01   722
## pp1 0.45 0.02 0.40 0.45  0.49 1.00   492
## pp2 0.49 0.03 0.43 0.48  0.55 1.01   632</code></pre>
<p>These estimates diverge markedly from the values used to simulate the data, see Table <a href="lackoffit.html#tab:simpar">7.2</a>:</p>
<div class="inline-table"><table class="table table-sm">
<caption>
<span id="tab:simpar">Table 7.2: </span>Comparison of posterior estimates from NIMBLE with the data-generating values for a finite–mixture HMM.</caption>
<thead><tr class="header">
<th align="left">Parameter</th>
<th align="center">True value</th>
<th align="center">Posterior mean (95% credible interval)</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">phi</td>
<td align="center">0.7</td>
<td align="center">0.70 (0.67–0.73)</td>
</tr>
<tr class="even">
<td align="left">pi</td>
<td align="center">0.2</td>
<td align="center">0.70 (0.63–0.76)</td>
</tr>
<tr class="odd">
<td align="left">pp1</td>
<td align="center">0.8</td>
<td align="center">0.45 (0.40–0.49)</td>
</tr>
<tr class="even">
<td align="left">pp2</td>
<td align="center">0.3</td>
<td align="center">0.49 (0.43–0.55)</td>
</tr>
</tbody>
</table></div>
<p>Why is that? The first issue is that the classes were permuted. In our model, nothing tells NIMBLE that the highly detectable individuals must belong to class A1 and the less detectable ones to class A2. The labeling of the classes is arbitrary. The interpretation only comes afterwards, by inspecting the parameter estimates. Now if we re-calculate <span class="math inline">\(\pi\)</span> as the proportion of individuals in A1 as follows:</p>
<div class="sourceCode" id="cb348"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">samples</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="va">mcmc.phipmix</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>, <span class="va">mcmc.phipmix</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="va">pi</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">samples</span><span class="op">[</span>,<span class="st">'pi'</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">pi</span><span class="op">)</span></span>
<span><span class="co">## [1] 0.305</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/quantile.html">quantile</a></span><span class="op">(</span><span class="va">pi</span>, probs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2.5</span>, <span class="fl">97.5</span><span class="op">)</span><span class="op">/</span><span class="fl">100</span><span class="op">)</span></span>
<span><span class="co">##   2.5%  97.5% </span></span>
<span><span class="co">## 0.2418 0.3715</span></span></code></pre></div>
<p>we can get a sorted new Table <a href="lackoffit.html#tab:simpar2">7.3</a>:</p>
<div class="inline-table"><table class="table table-sm">
<caption>
<span id="tab:simpar2">Table 7.3: </span>Comparison of posterior estimates from NIMBLE with the data-generating values for a finite–mixture HMM.</caption>
<thead><tr class="header">
<th align="left">Parameter</th>
<th align="center">True value</th>
<th align="center">Posterior mean (95% credible interval)</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">phi</td>
<td align="center">0.7</td>
<td align="center">0.70 (0.67–0.73)</td>
</tr>
<tr class="even">
<td align="left">pi</td>
<td align="center">0.2</td>
<td align="center">0.30 (0.24–0.37)</td>
</tr>
<tr class="odd">
<td align="left">pp1</td>
<td align="center">0.8</td>
<td align="center">0.49 (0.43–0.55)</td>
</tr>
<tr class="even">
<td align="left">pp2</td>
<td align="center">0.3</td>
<td align="center">0.45 (0.40–0.49)</td>
</tr>
</tbody>
</table></div>
<p>Still, the detection estimates are off. There’s a deeper issue here. The HMM formulation we used for capturing heterogeneity creates a limitation: individuals are not allowed to switch between classes over time (e.g., from A1 to A2), because the transition matrix does not permit it. In other words, any individual seen &gt; 1 time (it’s detected after the first observation occasion) can <em>never</em> change class assignments away from their initial value class assignment. Why this formulation fails? The problem is subtle but fundamental: in a HMM, transitions between states are governed by a Markov process. If the transition matrix says an individual in A1 must stay in A1 (or die), then the individual is permanently locked in that class. As a result, once an individual is assigned to a class through its initial latent state (e.g., A1), it can never change class during sampling. Even worse, any individual seen on multiple occasions (say, years 1 and 4) must stay alive during those years, the latent state cannot ‘jump’ between classes without violating the transition constraints, therefore, the initial class assignment is fixed forever, and the MCMC sampler cannot explore the alternative class, no matter how much data supports it.</p>
<p>I must confess, I got stuck in that trap, and it was only because I used simulations that I could identify the problem. I then asked the NIMBLE team for help, and Daniel Turek came up with the explanation – thanks, Daniel!</p>
<p>Fortunately, there are several solutions to this problem:</p>
<ul>
<li><p>Marginalize over the latent states: Instead of sampling the latent states <span class="math inline">\(z\)</span>, you can marginalize them out, which avoids the class-switching problem entirely. This is the principle behind the <code>nimbleEcology</code> package, see Section <a href="hmmcapturerecapture.html#nimbleecologyintro">3.8.3.2</a>.</p></li>
<li><p>Use a class-level latent variable: Rather than coding classes as HMM states, define a latent class assignment (e.g., <code>g[i] ~ dcat(pi[1:2])</code>) for each individual. The HMM then conditions on that fixed class, allowing for proper inference and switching during MCMC.</p></li>
<li><p>Custom block sampler: Design a custom MCMC sampler that updates the entire latent history of an individual (<code>z[i, 1:K]</code>) at once. This allows for class-switching in a consistent way, though it’s more advanced and computationally heavier.</p></li>
</ul>
<p>Here I will adopt the first solution and use some material we saw in Section <a href="hmmcapturerecapture.html#marginalization">3.8</a>. In NIMBLE, we start by writing our own functions for the HMM likelihood, using the backward algorithm:</p>
<div class="sourceCode" id="cb349"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Goal: integrate out latent states z using a custom density (forward algorithm),</span></span>
<span><span class="co"># and speed things up by pooling identical encounter histories with a pooled likelihood.</span></span>
<span></span>
<span><span class="co"># Get rid of individuals for which first==K</span></span>
<span><span class="va">mask</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span><span class="op">(</span><span class="va">first</span><span class="op">!=</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span><span class="op">)</span> <span class="co"># individuals that are not first encountered at last occasion</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="va">y</span><span class="op">[</span><span class="va">mask</span>, <span class="op">]</span>                <span class="co"># keep only these</span></span>
<span><span class="va">first</span> <span class="op">&lt;-</span> <span class="va">first</span><span class="op">[</span><span class="va">mask</span><span class="op">]</span></span>
<span><span class="co"># Rationale: if first == K (first seen at last occasion), there is no post-capture interval</span></span>
<span><span class="co"># to inform phi/p; removing them simplifies the forward recursion and avoids degenerate len=1 cases.</span></span>
<span></span>
<span><span class="co"># Pool encounter histories</span></span>
<span><span class="va">y_weighted</span> <span class="op">&lt;-</span> <span class="va">y</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu">as_tibble</span><span class="op">(</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu">group_by_all</span><span class="op">(</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>                 <span class="co"># group by entire encounter history (all columns)</span></span>
<span>  <span class="fu">summarise</span><span class="op">(</span>size <span class="op">=</span> <span class="fu">n</span><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>          <span class="co"># count how many individuals share that history</span></span>
<span>  <span class="fu">relocate</span><span class="op">(</span><span class="va">size</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span>                 <span class="co"># move the "size" column to the front</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">y_weighted</span><span class="op">)</span></span>
<span><span class="va">size</span> <span class="op">&lt;-</span> <span class="va">y_weighted</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span> <span class="co"># nb of individuals w/ a particular encounter history</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="va">y_weighted</span><span class="op">[</span>,<span class="op">-</span><span class="fl">1</span><span class="op">]</span>   <span class="co"># pooled data: one row per unique history</span></span>
<span></span>
<span><span class="co"># Assemble data and constants</span></span>
<span><span class="co"># +1 because the custom distribution expects categories 1/2 (not 0/1)</span></span>
<span><span class="va">my.data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">y</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">my.constants</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>N <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span>, </span>
<span>                     K <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span>, </span>
<span>                     first <span class="op">=</span> <span class="va">first</span>,</span>
<span>                     size <span class="op">=</span> <span class="va">size</span>,</span>
<span>                     one <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co"># "one" is a dummy constant used in a dconstraint (to prevent label switching).</span></span>
<span></span>
<span><span class="co"># NIMBLE functions</span></span>
<span><span class="co"># Custom HMM *density* for pooled histories via forward algorithm (alpha recursion)</span></span>
<span><span class="va">dwolfHMM</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/nimble/man/nimbleFunction.html">nimbleFunction</a></span><span class="op">(</span></span>
<span>  run <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>, </span>
<span>                 <span class="va">probInit</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>, <span class="co"># vector of initial states (delta)</span></span>
<span>                 <span class="va">probObs</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span>,  <span class="co"># observation matrix (omega)</span></span>
<span>                 <span class="va">probObse</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span>, <span class="co"># observation matrix used at first occasion (conditioning)</span></span>
<span>                 <span class="va">probTrans</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span>,<span class="co"># transition matrix (gamma)</span></span>
<span>                 <span class="va">size</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">0</span><span class="op">)</span>,     <span class="co"># multiplicity of this history</span></span>
<span>                 <span class="va">len</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">0</span>, default <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>, <span class="co"># number of sampling occasions</span></span>
<span>                 <span class="va">log</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/integer.html">integer</a></span><span class="op">(</span><span class="fl">0</span>, default <span class="op">=</span> <span class="fl">0</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="co"># Initial forward probs:</span></span>
<span>    <span class="co"># multiply initial state probs by the observation prob at the first datum x[1]</span></span>
<span>    <span class="co"># (probObs at t=first is effectively 1 due to CJS conditioning; handled via 'probObse').</span></span>
<span>    <span class="va">alpha</span> <span class="op">&lt;-</span> <span class="va">probInit</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span> <span class="op">*</span> <span class="va">probObse</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,<span class="va">x</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="co"># * probObs[1:3,x[1]] == 1 due to conditioning on first detection</span></span>
<span>    <span class="kw">for</span> <span class="op">(</span><span class="va">t</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="va">len</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="co"># standard forward step: alpha_t = (alpha_{t-1} * Gamma) .* Omega(:, y_t)</span></span>
<span>      <span class="va">alpha</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">alpha</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="va">probTrans</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span> <span class="op">*</span> <span class="va">probObs</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,<span class="va">x</span><span class="op">[</span><span class="va">t</span><span class="op">]</span><span class="op">]</span></span>
<span>    <span class="op">}</span></span>
<span>    <span class="co"># Pooling: multiply the log-likelihood by 'size'</span></span>
<span>    <span class="va">logL</span> <span class="op">&lt;-</span> <span class="va">size</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">alpha</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="fu">returnType</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="va">log</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">logL</span><span class="op">)</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">logL</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Matching *random generator* (required by NIMBLE for custom distributions)</span></span>
<span><span class="co"># Generates one synthetic history consistent with the HMM; not used in MCMC, but needed to register the dist.</span></span>
<span><span class="va">rwolfHMM</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/nimble/man/nimbleFunction.html">nimbleFunction</a></span><span class="op">(</span></span>
<span>  run <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">n</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/integer.html">integer</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>                 <span class="va">probInit</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>                 <span class="va">probObs</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span>,</span>
<span>                 <span class="va">probObse</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span>,</span>
<span>                 <span class="va">probTrans</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span>,</span>
<span>                 <span class="va">size</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">0</span><span class="op">)</span>,</span>
<span>                 <span class="va">len</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">0</span>, default <span class="op">=</span> <span class="fl">0</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu">returnType</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">z</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">numeric</a></span><span class="op">(</span><span class="va">len</span><span class="op">)</span> <span class="co"># latent states</span></span>
<span>    <span class="va">z</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/nimble/man/Categorical.html">rcat</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">1</span>, prob <span class="op">=</span> <span class="va">probInit</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span> <span class="co"># all individuals alive at t = 0 (by construction)</span></span>
<span>    <span class="va">y</span> <span class="op">&lt;-</span> <span class="va">z</span></span>
<span>    <span class="va">y</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span> <span class="co"># all individuals are detected at t = 0 (CJS conditioning)</span></span>
<span>    <span class="kw">for</span> <span class="op">(</span><span class="va">t</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="va">len</span><span class="op">)</span><span class="op">{</span></span>
<span>      <span class="co"># state at t given state at t-1</span></span>
<span>      <span class="va">z</span><span class="op">[</span><span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/nimble/man/Categorical.html">rcat</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">1</span>, prob <span class="op">=</span> <span class="va">probTrans</span><span class="op">[</span><span class="va">z</span><span class="op">[</span><span class="va">t</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span> </span>
<span>      <span class="co"># observation at t given state at t</span></span>
<span>      <span class="va">y</span><span class="op">[</span><span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/nimble/man/Categorical.html">rcat</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">1</span>, prob <span class="op">=</span> <span class="va">probObs</span><span class="op">[</span><span class="va">z</span><span class="op">[</span><span class="va">t</span><span class="op">]</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span> </span>
<span>    <span class="op">}</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Register the custom density/generator in the global environment</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/assign.html">assign</a></span><span class="op">(</span><span class="st">'dwolfHMM'</span>, <span class="va">dwolfHMM</span>, <span class="va">.GlobalEnv</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/assign.html">assign</a></span><span class="op">(</span><span class="st">'rwolfHMM'</span>, <span class="va">rwolfHMM</span>, <span class="va">.GlobalEnv</span><span class="op">)</span></span></code></pre></div>
<p>Now the NIMBLE code for the model, at last:</p>
<div class="sourceCode" id="cb350"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Model code</span></span>
<span><span class="va">hmm.phipmix</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/nimble/man/nimbleCode.html">nimbleCode</a></span><span class="op">(</span><span class="op">{</span></span>
<span>  </span>
<span>  <span class="co"># -------------------------------------------------</span></span>
<span>  <span class="co"># Parameters:</span></span>
<span>  <span class="co"># pi: initial state probability A1   (mixture weight for class 1)</span></span>
<span>  <span class="co"># phi: survival probability          (shared across classes)</span></span>
<span>  <span class="co"># pp1: recapture probability A1      (detection for class 1)</span></span>
<span>  <span class="co"># pp2: recapture probability A2      (detection for class 2)</span></span>
<span>  <span class="co"># -------------------------------------------------</span></span>
<span>  <span class="co"># States (S):</span></span>
<span>  <span class="co"># 1 alive (A1)  -&gt; class 1</span></span>
<span>  <span class="co"># 2 alive (A2)  -&gt; class 2</span></span>
<span>  <span class="co"># 3 dead (D)</span></span>
<span>  <span class="co"># Observations (O):</span></span>
<span>  <span class="co"># 1 neither seen nor recovered (0)</span></span>
<span>  <span class="co"># 2 seen alive (1)</span></span>
<span>  <span class="co"># -------------------------------------------------</span></span>
<span>  </span>
<span>  <span class="co"># priors</span></span>
<span>  <span class="va">phi</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">dunif</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span> <span class="co"># prior survival</span></span>
<span>  <span class="va">one</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/pkg/nimble/man/Constraint.html">dconstraint</a></span><span class="op">(</span><span class="va">pp1</span> <span class="op">&lt;</span> <span class="va">pp2</span><span class="op">)</span> <span class="co"># to avoid label switching (enforces an ordering)</span></span>
<span>  <span class="va">pp1</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">dunif</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span> <span class="co"># prior detection (class 1)</span></span>
<span>  <span class="va">pp2</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">dunif</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span> <span class="co"># prior detection (class 2)</span></span>
<span>  <span class="va">pi</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">dunif</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span>  <span class="co"># prob init state 1 (mixture proportion for class 1)</span></span>
<span>  </span>
<span>  <span class="co"># transition matrix (classes are persistent; no switching between A1 and A2)</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi</span>      <span class="co"># A1(t)-&gt;A1(t+1)</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span>        <span class="co"># A1(t)-&gt;A2(t+1)</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">phi</span>  <span class="co"># A1(t)-&gt;D(t+1)</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span>        <span class="co"># A2(t)-&gt;A1(t+1)</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">phi</span>      <span class="co"># A2(t)-&gt;A2(t+1)</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">phi</span>  <span class="co"># A2(t)-&gt;D(t+1)</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span>        <span class="co"># D(t)-&gt;A1(t+1)</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span>        <span class="co"># D(t)-&gt;A2(t+1)</span></span>
<span>  <span class="va">gamma</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span>        <span class="co"># D(t)-&gt;D(t+1)</span></span>
<span>  </span>
<span>  <span class="co"># vector of initial state probs (mixture at first capture)</span></span>
<span>  <span class="va">delta</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">pi</span>         <span class="co"># A1(first)</span></span>
<span>  <span class="va">delta</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">pi</span>     <span class="co"># A2(first)</span></span>
<span>  <span class="va">delta</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span>          <span class="co"># D(first)</span></span>
<span>  </span>
<span>  <span class="co"># observation matrix (detection differs by class; dead are never seen)</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">pp1</span>   <span class="co"># A1(t)-&gt;0(t)</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">pp1</span>       <span class="co"># A1(t)-&gt;1(t)</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">pp2</span>   <span class="co"># A2(t)-&gt;0(t)</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">pp2</span>       <span class="co"># A2(t)-&gt;1(t)</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span>         <span class="co"># D(t)-&gt;0(t)</span></span>
<span>  <span class="va">omega</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span>         <span class="co"># D(t)-&gt;1(t)</span></span>
<span>  </span>
<span>  <span class="co"># 'omegae' is used only at the first datum inside the custom density</span></span>
<span>  <span class="co"># to implement CJS conditioning (everyone is detected at first capture)</span></span>
<span>  <span class="va">omegae</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span>        <span class="co"># A1(t)-&gt;0(t)</span></span>
<span>  <span class="va">omegae</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span>        <span class="co"># A1(t)-&gt;1(t)</span></span>
<span>  <span class="va">omegae</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span>        <span class="co"># A2(t)-&gt;0(t)</span></span>
<span>  <span class="va">omegae</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span>        <span class="co"># A2(t)-&gt;1(t)</span></span>
<span>  <span class="va">omegae</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span>        <span class="co"># D(t)-&gt;0(t)</span></span>
<span>  <span class="va">omegae</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span>        <span class="co"># D(t)-&gt;1(t)</span></span>
<span>  </span>
<span>  <span class="co"># likelihood</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">N</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="co"># One weighted likelihood contribution per *unique* encounter history,</span></span>
<span>    <span class="co"># using the forward algorithm implemented in dwolfHMM.</span></span>
<span>    <span class="va">y</span><span class="op">[</span><span class="va">i</span>,<span class="va">first</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">:</span><span class="va">K</span><span class="op">]</span> <span class="op">~</span> <span class="fu">dwolfHMM</span><span class="op">(</span>probInit <span class="op">=</span> <span class="va">delta</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span>,      <span class="co"># initial state probs</span></span>
<span>                               probObs <span class="op">=</span> <span class="va">omega</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>,   <span class="co"># observation matrix</span></span>
<span>                               probObse <span class="op">=</span> <span class="va">omegae</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, <span class="co"># obs matrix for first occasion (conditioning)</span></span>
<span>                               probTrans <span class="op">=</span> <span class="va">gamma</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span>, <span class="co"># transition matrix</span></span>
<span>                               size <span class="op">=</span> <span class="va">size</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>,             <span class="co"># weight: how many individuals share this history</span></span>
<span>                               len <span class="op">=</span> <span class="va">K</span> <span class="op">-</span> <span class="va">first</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span>     <span class="co"># number of occasions for this history</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Initial values (cool thing, we do not need inits for the latent states anymore!!)</span></span>
<span><span class="va">initial.values</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>phi <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span>,</span>
<span>                                  pp1 <span class="op">=</span> <span class="fl">0.3</span>,</span>
<span>                                  pp2 <span class="op">=</span> <span class="fl">0.8</span>,</span>
<span>                                  pi <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co"># Note: 'one' is provided in constants; no init needed. The pp1&lt;pp2 constraint</span></span>
<span><span class="co"># prevents label switching by fixing the class ordering.</span></span>
<span></span>
<span><span class="co"># Parameters to be monitored</span></span>
<span><span class="va">parameters.to.save</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"phi"</span>, <span class="st">"pp1"</span>, <span class="st">"pp2"</span>, <span class="st">"pi"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Run NIMBLE</span></span>
<span><span class="va">out</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/nimble/man/nimbleMCMC.html">nimbleMCMC</a></span><span class="op">(</span>code <span class="op">=</span> <span class="va">hmm.phipmix</span>, </span>
<span>                  constants <span class="op">=</span> <span class="va">my.constants</span>,</span>
<span>                  data <span class="op">=</span> <span class="va">my.data</span>,              </span>
<span>                  inits <span class="op">=</span> <span class="va">initial.values</span>,</span>
<span>                  monitors <span class="op">=</span> <span class="va">parameters.to.save</span>,</span>
<span>                  niter <span class="op">=</span> <span class="va">n.iter</span>,</span>
<span>                  nburnin <span class="op">=</span> <span class="va">n.burnin</span>, </span>
<span>                  nchains <span class="op">=</span> <span class="va">n.chains</span><span class="op">)</span></span></code></pre></div>
</div>
<div id="results-and-interpretation-5" class="section level3" number="7.4.3">
<h3>
<span class="header-section-number">7.4.3</span> Results and interpretation<a class="anchor" aria-label="anchor" href="#results-and-interpretation-5"><i class="fas fa-link"></i></a>
</h3>
<p>The results in Table <a href="lackoffit.html#tab:okidh">7.4</a> look fine now:</p>
<div class="inline-table"><table class="table table-sm">
<caption>
<span id="tab:okidh">Table 7.4: </span>Posterior estimates vs. data-generating values for a finite–mixture HMM, when a marginalized likelihood is used.</caption>
<thead><tr class="header">
<th align="left">Parameter</th>
<th align="center">True value</th>
<th align="center">Posterior mean (95% credible interval)</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">phi</td>
<td align="center">0.7</td>
<td align="center">0.72 (0.69–0.75)</td>
</tr>
<tr class="even">
<td align="left">pi</td>
<td align="center">0.2</td>
<td align="center">0.28 (0.10–0.46)</td>
</tr>
<tr class="odd">
<td align="left">pp1</td>
<td align="center">0.8</td>
<td align="center">0.79 (0.65–0.92)</td>
</tr>
<tr class="even">
<td align="left">pp2</td>
<td align="center">0.3</td>
<td align="center">0.27 (0.18–0.35)</td>
</tr>
</tbody>
</table></div>
<p>In summary, when modeling unobservable individual heterogeneity (e.g., detection classes) in an HMM, avoid encoding class identity as a dynamic state. Instead, treat it as a fixed latent variable, or marginalize it out. Otherwise, the model is unable to explore the full posterior and will yield biased or unreliable estimates.</p>
<p>A question that remains is the number of classes we should use. In other words, why 2 classes and not 3 or 4? One option is to fit models with more classes and select among them <span class="citation">(e.g., <a href="references.html#ref-cubaynes2012">Cubaynes et al. 2012</a>)</span>. Alternatively, you can take a non-parametric route and let the data decide how many classes are needed; this is relatively easy in NIMBLE <span class="citation">(see <a href="references.html#ref-turek_bayesian_2021">Turek, Wehrhahn, and Gimenez 2021</a>)</span>.</p>
<p>For broader context on individual heterogeneity, see <span class="citation">Gimenez, Cam, and Gaillard (<a href="references.html#ref-gimenez2018ih">2018</a>)</span>. Finally, remember that these hidden classes were introduced by Pledger and colleagues primarily to correct bias in survival or abundance when heterogeneity is ignored; interpreting the classes biologically after fitting should be done with caution.</p>
<!-- I'm not an expert on the BNP facilities offered in NIMBLE, but I think I can comment: the stick-breaking representation (as you're using), and the CRP distribution, are modelling the same Dirichlet process.  They differ in the MCMC sampling algorithms which are applied to each, automatically, by NIMBLE's MCMC.  Translating your code between these two (mathematically identical) representations is a relatively small and straight-forward exercise.  The relative performance of the different sampling algorithms, as applied to each representation, could differ, would depend on the model and the data, and is generally difficult to predict. -->
<!-- Changing between the stick-breaking representation and the CRP representation, the categorical distribution would persist in your model.  And Perry's comments are correct, that (in particular for a large number of categories, e.g. large values of H or HH in your code) the categorical sampler (which is applied to the categorical distribution) would become arbitrarily inefficient, in that it evaluates the posterior density for every category value (H or HH times), then samples directly from that posterior distribution.  And that you could hopefully reduce this inefficiency by writing a customized sampling strategy (a custom-written MCMC sampler), to update your categorical distributions, in a more efficient (less wasteful) manner. -->
<!-- ## Temporary emigration -->
<!-- Multistate treatment as in @schaub2004te. See example in @bancila2018te. -->
<!-- Transition matrix: -->
<!-- $$\begin{matrix} -->
<!-- & \\ -->
<!-- \mathbf{\Gamma} = -->
<!--   \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right . -->
<!--           \end{matrix} -->
<!--           \hspace{-1.2em} -->
<!--           \begin{matrix} -->
<!--           z_t=\text{in} & z_t=\text{out} & z_t=\text{D} \\ \hdashline -->
<!--           \phi (1-\psi^{\text{in} \rightarrow \text{out}}) & \phi \psi^{\text{in} \rightarrow \text{out}} & 1 - \phi\\ -->
<!--           \phi \psi^{\text{out} \rightarrow \text{in}} & \phi (1-\psi^{\text{out} \rightarrow \text{in}}) & 1 - \phi\\ -->
<!--           0 & 0 & 1 -->
<!--           \end{matrix} -->
<!--           \hspace{-0.2em} -->
<!--           \begin{matrix} -->
<!--           & \\ -->
<!--           \left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right ) -->
<!-- \begin{matrix} -->
<!-- z_{t-1}=\text{in} \\ z_{t-1}=\text{out} \\ z_{t-1}=\text{D} -->
<!-- \end{matrix} -->
<!-- \end{matrix}$$ -->
<!-- Observation matrix: -->
<!-- $$\begin{matrix} -->
<!-- & \\ -->
<!-- \mathbf{\Omega} = -->
<!--   \left ( \vphantom{ \begin{matrix} 12 \\ 12 \end{matrix} } \right . -->
<!--           \end{matrix} -->
<!--           \hspace{-1.2em} -->
<!--           \begin{matrix} -->
<!--           y_t=1 & y_t=2 \\ \hdashline -->
<!--           1 - p & p\\ -->
<!--           1 & 0\\ -->
<!--           1 & 0 -->
<!--           \end{matrix} -->
<!--           \hspace{-0.2em} -->
<!--           \begin{matrix} -->
<!--           & \\ -->
<!--           \left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right ) -->
<!-- \begin{matrix} -->
<!-- z_{t}=\text{in} \\ z_{t}=\text{out} \\ z_{t}=\text{D} -->
<!-- \end{matrix} -->
<!-- \end{matrix}$$ -->

</div>
</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="covariateschapter.html"><span class="header-section-number">6</span> Dealing with covariates</a></div>
<div class="next"><a href="tradeoffs.html"><span class="header-section-number">8</span> Quantifying life history traits</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#lackoffit"><span class="header-section-number">7</span> Addressing model lack of fit</a></li>
<li><a class="nav-link" href="#introduction-9"><span class="header-section-number">7.1</span> Introduction</a></li>
<li>
<a class="nav-link" href="#trapdep"><span class="header-section-number">7.2</span> Accounting for trap-dependence</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#motivation-3"><span class="header-section-number">7.2.1</span> Motivation</a></li>
<li><a class="nav-link" href="#model-and-nimble-implementation-3"><span class="header-section-number">7.2.2</span> Model and NIMBLE implementation</a></li>
<li><a class="nav-link" href="#results-and-interpretation-3"><span class="header-section-number">7.2.3</span> Results and interpretation</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#memorymodel"><span class="header-section-number">7.3</span> Allowing your Markov models to remember</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#motivation-4"><span class="header-section-number">7.3.1</span> Motivation</a></li>
<li><a class="nav-link" href="#model-and-nimble-implementation-4"><span class="header-section-number">7.3.2</span> Model and NIMBLE implementation</a></li>
<li><a class="nav-link" href="#results-and-interpretation-4"><span class="header-section-number">7.3.3</span> Results and interpretation</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#indhet"><span class="header-section-number">7.4</span> Accomodating individual heterogeneity</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#motivation-5"><span class="header-section-number">7.4.1</span> Motivation</a></li>
<li><a class="nav-link" href="#model-and-nimble-implementation-5"><span class="header-section-number">7.4.2</span> Model and NIMBLE implementation</a></li>
<li><a class="nav-link" href="#results-and-interpretation-5"><span class="header-section-number">7.4.3</span> Results and interpretation</a></li>
</ul>
</li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/oliviergimenez/banana-book/blob/master/7-lackoffit.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/oliviergimenez/banana-book/edit/master/7-lackoffit.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Bayesian analysis of capture-recapture data with hidden Markov models</strong>: Theory and case studies in R and NIMBLE" was written by Olivier Gimenez. It was last built on 2025-08-18.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
