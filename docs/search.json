[{"path":"index.html","id":"welcome","chapter":"Welcome","heading":"Welcome","text":"Welcome online version book Bayesian Analysis Capture-Recapture Data Hidden Markov Models – Theory Case Studies R. HMM framework gained much attention ecological literature last decade, suggested general modelling framework demography plant animal populations. particular, HMMs increasingly used analyse capture-recapture data estimate key population parameters (e.g., survival, dispersal, recruitment abundance) applications fields ecology.parallel, Bayesian statistics well established fast growing ecology related disciplines, resonates scientific reasoning allows accommodating uncertainty smoothly. popularity Bayesian statistics also comes availability free pieces software (WinBUGS, OpenBUGS, JAGS, Stan, NIMBLE) allow practitioners code analyses.book offers Bayesian treatment HMMs applied capture-recapture data. learn use R package NIMBLE seen many future Bayesian statistical ecology deal complex models /big data. important part book consists case studies presented tutorial style abide “learning ” philosophy.’m currently writing book, welcome feedback. may raise issue , amend directly R Markdown file generated page ’re reading clicking ‘Edit page’ icon right panel, email . Many thanks!Olivier Gimenez. Written Montpellier, France Athens, Greece.\nLast updated: August 11, 2023","code":""},{"path":"index.html","id":"license","chapter":"Welcome","heading":"License","text":"online version book licensed Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.code public domain, licensed Creative Commons CC0 1.0 Universal (CC0 1.0).","code":""},{"path":"preface.html","id":"preface","chapter":"Preface","heading":"Preface","text":"","code":""},{"path":"preface.html","id":"why-this-book","chapter":"Preface","heading":"Why this book?","text":"completed. capture-recapture data models, fields application.1 Brief history capture-recapture, switch state-space/hidden Markov model (HMM) formulation. Flexibility HMM decompose complex problems smaller pieces easier understand, model analyse. satellite guidance conservation endangered species. Bayes? Also three fav research topics – capture-recapture, HMM Bayes statistics – let’s enjoy great cocktail together.","code":""},{"path":"preface.html","id":"who-should-read-this-book","chapter":"Preface","heading":"Who should read this book?","text":"book aimed beginners ’re comfortable using R write basic code (including loops), well connoisseurs capture-recapture ’d like tap power Bayesian side statistics. audiences, thinking HMM framework help confidently building models make capture-recapture data.","code":""},{"path":"preface.html","id":"what-will-you-learn","chapter":"Preface","heading":"What will you learn?","text":"book divided five parts. first part aimed getting --speed Bayesian statistics, NIMBLE, hidden Markov models. second part teach capture-recapture models open populations, reproducible R code ease learning process. third part, focus issues inferring states (dealing uncertainty assignment, modelling waiting time distribution). fourth part provides real-world case studies scientific literature can reproduce using material covered previous chapters. problems can either ) used cement deepen understanding methods models, ii) adapted purpose, iii) serve teaching projects. fifth last chapter closes book take-home messages recommendations, list frequently asked questions references cited book. Likely amended feedbacks.","code":""},{"path":"preface.html","id":"what-wont-you-learn","chapter":"Preface","heading":"What won’t you learn?","text":"hardly maths book. equations use either simple enough understood without background maths, can skipped without prejudice. cover Bayesian statistics even hidden Markov models fully, provide just need work capture-recapture data. interested knowing topics, hopefully section Suggested reading end chapter put right direction. also number important topics specific capture-recapture cover, including closed-population capture-recapture models (Williams, Nichols, Conroy 2002), spatial capture-recapture models (Royle et al. 2013). models can treated HMMs, now usual formulation just fine. spatial considerations Covariates chapter w/ splines CAR. ’m sure yet SCR models (R. Glennie’s Biometrics paper HMMs open pop SCR easy Bayes transform implement NIMBLE).","code":""},{"path":"preface.html","id":"prerequisites","chapter":"Preface","heading":"Prerequisites","text":"book uses primarily R package NIMBLE, need install least R NIMBLE. bunch R packages used. can install running:","code":"\ninstall.packages(c(\n  \"magick\", \"MCMCvis\", \"nimble\", \"pdftools\", \n  \"tidyverse\", \"wesanderson\" \n))"},{"path":"preface.html","id":"acknowledgements","chapter":"Preface","heading":"Acknowledgements","text":"completed.","code":""},{"path":"preface.html","id":"how-this-book-was-written","chapter":"Preface","heading":"How this book was written","text":"writing book RStudio using bookdown. book website hosted GitHub Pages, automatically updated every push Github Actions. source available GitHub.version book ’re reading built R version 4.2.3 (2023-03-15) following packages:","code":""},{"path":"about-the-author.html","id":"about-the-author","chapter":"About the author","heading":"About the author","text":"name Olivier Gimenez (https://oliviergimenez.github.io/). senior (euphemism young anymore) scientist National Centre Scientific Research (CNRS) beautiful city Montpellier, France.struggled studying maths, obtained PhD applied statistics long time ago galaxy wine cheese. awarded habilitation (https://en.wikipedia.org/wiki/Habilitation) ecology evolution stop pretending understand colleagues talking . recently embarked sociology studies hey, .Lost somewhere interface animal ecology, statistical modeling social sciences, -called expertise lies population dynamics species distribution modeling address questions ecology conservation biology impact human activities management large carnivores. nothing without students colleagues kind enough bear .may find Twitter (https://twitter.com/oaggimenez), GitHub (https://github.com/oliviergimenez), get touch email.","code":""},{"path":"introduction.html","id":"introduction","chapter":"Introduction","heading":"Introduction","text":"","code":""},{"path":"introduction-1.html","id":"introduction-1","chapter":"Introduction","heading":"Introduction","text":"","code":""},{"path":"survival.html","id":"survival","chapter":"1 Survival","heading":"1 Survival","text":"","code":""},{"path":"survival.html","id":"introduction-2","chapter":"1 Survival","heading":"1.1 Introduction","text":"fourth chapter, learn Cormack-Jolly-Seber model allows estimating survival based capture-recapture data. also see deal covariates try explain temporal /individual variation survival. chapter also opportunity illustrate incorporate prior information improve model inference.","code":""},{"path":"survival.html","id":"the-cormack-jolly-seber-cjs-model","chapter":"1 Survival","heading":"1.2 The Cormack-Jolly-Seber (CJS) model","text":"chapter ??, introduced capture-recapture model constant survival detection probabilities formulated HMM fitted data NIMBLE. Historically, however, slightly complicated model first proposed – -called Cormack-Jolly-Seber (CJS) model – survival recapture probabilities time-varying. feature CJS model useful account variation due environmental conditions survival sampling effort detection. Schematically CJS model can represented way:Note states (gray) observations (white) change. still \\(z = 1\\) alive, \\(z = 2\\) dead, \\(y = 1\\) non-detected, \\(y = 2\\) detected.Parameters now indexed time. survival probability defined probability staying alive (“ah, ha, ha, ha, stayin’ alive” like Bee Gees say) interval \\(t\\) \\(t+1\\), \\(\\phi_t = \\Pr(z_{t+1} = 1 | z_t = 1)\\). detection probability defined probability observed \\(t\\) given ’re alive \\(t\\), \\(p_t = \\Pr(y_{t} = 1 | z_t = 1)\\). important bear mind survival operates interval detection occurs specific time (see Section 1.8).CJS model named three statisticians published independently paper introducing less approach, year apart ! fact, Richard Cormack George Jolly working corridor Scotland back 1960’s. meet every day coffee play game together, never mention work aware ’s work.","code":""},{"path":"survival.html","id":"capture-recapture-data","chapter":"1 Survival","heading":"1.3 Capture-recapture data","text":"turn fitting CJS model actual data, let’s talk capture-recapture minute. said Section ?? animals individually marked. can accomplished two ways, either artificial marks like rings birds ear tags mammals, (non-invasive) natural marks like coat patterns feces DNA sequencing (Figure 1.1).\nFigure 1.1: Animal individual marking. Top-left: rings; Top-right: ear-tags; Bottom left: coat patterns; Bottom right: ADN feces\nThroughout chapter, use data White-throated Dipper (Cinclus cinclus; dipper hereafter) kindly provided Gilbert Marzolin (Figure 1.2). total, 294 dippers known sex wing length captured recaptured 1981 1987 March-June period. Birds least 1 year old initially banded.\nFigure 1.2: White-throated Dipper (Cinclus cinclus)\nmay scroll data :first seven columns years Gilbert went field captured birds. 0 stands non-detection, 1 detection. eighth column informs sex bird, F female M male. last column gives measure wing length first time bird captured.","code":""},{"path":"survival.html","id":"fitting-the-cjs-model-to-the-dipper-data-with-nimble","chapter":"1 Survival","heading":"1.4 Fitting the CJS model to the dipper data with NIMBLE","text":"write NIMBLE code corresponding CJS model, need make adjustments NIMBLE code model constant parameters Section ??. main modification concerns observation transition matrices need make time-varying. matrices therefore become arrays inherit third dimension besides rows columns. Also need priors time-varying survival detection probabilities. write:likelihood change, except time-varying observation transition matrices need used appropriately. Also, now deal several cohorts animals first captured, marked released year (contrast single cohort Chapter ??), need start loop time first capture individual. Therefore, write:Overall, code looks like:read data:get occasion first capture individuals, finding position detections encounter history ((x !=0)), keeping first one:Now specify constants:Now put data list. add 1 data code non-detections 1’s detections 2’s (see Section @ref{fittinghmmnimble}).Now let’s write function initial values. latent states, go easy way, say individuals alive study period:specify parameters like monitor:provide MCMC details:Now ready run NIMBLE:may look numerical summaries:much time variation detection probability estimated high around 0.90. Note p[1] corresponds detection probability 1982 \\(p_2\\), p[2] detection 1983 therefore \\(p_3\\), . contrast, dippers seem experienced decrease survival years 1982-1983 (phi[2]) 1983-1984 (phi[4]). get back Section 1.8.may noticed small effective sample size last survival (phi[6]) detection (p[6]) probabilities. Let’s look mixing parameter phi[6] example:Clearly mixing (left panel plot ) bad big overlap prior posterior parameter (right panel) suggesting prior well updated data. going ? inspect likelihood CJS model, realise two parameters \\(\\phi_6\\) \\(p_7\\) appear product \\(\\phi_6 p_7\\) estimated separately. words, one parameters redundant, ’d need extra sampling occasion able disentangle . big issue long ’re aware attempt ecologically interpret parameters.","code":"\n...\n# parameters\n  delta[1] <- 1          # Pr(alive t = 1) = 1\n  delta[2] <- 0          # Pr(dead t = 1) = 0\n  for (t in 1:(T-1)){\n    phi[t] ~ dunif(0, 1) # prior survival\n    gamma[1,1,t] <- phi[t]      # Pr(alive t -> alive t+1)\n    gamma[1,2,t] <- 1 - phi[t]  # Pr(alive t -> dead t+1)\n    gamma[2,1,t] <- 0        # Pr(dead t -> alive t+1)\n    gamma[2,2,t] <- 1        # Pr(dead t -> dead t+1)\n    p[t] ~ dunif(0, 1) # prior detection\n    omega[1,1,t] <- 1 - p[t]    # Pr(alive t -> non-detected t)\n    omega[1,2,t] <- p[t]        # Pr(alive t -> detected t)\n    omega[2,1,t] <- 1        # Pr(dead t -> non-detected t)\n    omega[2,2,t] <- 0        # Pr(dead t -> detected t)\n  }\n...\n...\n# likelihood\n  for (i in 1:N){\n    z[i,first[i]] ~ dcat(delta[1:2])\n    for (j in (first[i]+1):T){\n      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])\n      y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1])\n    }\n  }\n...\nhmm.phitpt <- nimbleCode({\n  # parameters\n  delta[1] <- 1          # Pr(alive t = 1) = 1\n  delta[2] <- 0          # Pr(dead t = 1) = 0\n  for (t in 1:(T-1)){\n    phi[t] ~ dunif(0, 1) # prior survival\n    gamma[1,1,t] <- phi[t]      # Pr(alive t -> alive t+1)\n    gamma[1,2,t] <- 1 - phi[t]  # Pr(alive t -> dead t+1)\n    gamma[2,1,t] <- 0        # Pr(dead t -> alive t+1)\n    gamma[2,2,t] <- 1        # Pr(dead t -> dead t+1)\n    p[t] ~ dunif(0, 1) # prior detection\n    omega[1,1,t] <- 1 - p[t]    # Pr(alive t -> non-detected t)\n    omega[1,2,t] <- p[t]        # Pr(alive t -> detected t)\n    omega[2,1,t] <- 1        # Pr(dead t -> non-detected t)\n    omega[2,2,t] <- 0        # Pr(dead t -> detected t)\n  }\n  # likelihood\n  for (i in 1:N){\n    z[i,first[i]] ~ dcat(delta[1:2])\n    for (j in (first[i]+1):T){\n      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])\n      y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1])\n    }\n  }\n})\ndipper <- read_csv(here::here(\"dat\", \"dipper.csv\"), show_col_types = FALSE)\ny <- dipper %>%\n  select(year_1981:year_1987) %>%\n  as.matrix()\nfirst <- apply(y, 1, function(x) min(which(x !=0)))\nmy.constants <- list(N = nrow(y),   # number of animals\n                     T = ncol(y),   # number of sampling occasions\n                     first = first) # first capture for all animales\nmy.constants\n## $N\n## [1] 294\n## \n## $T\n## [1] 7\n## \n## $first\n##   [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2\n##  [28] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n##  [55] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3\n##  [82] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n## [109] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4\n## [136] 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4\n## [163] 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5\n## [190] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6\n## [217] 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6\n## [244] 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7\n## [271] 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7\nmy.data <- list(y = y + 1)\nzinits <- y + 1 # non-detection -> alive\nzinits[zinits == 2] <- 1 # dead -> alive\ninitial.values <- function() list(phi = runif(my.constants$T-1,0,1),\n                                  p = runif(my.constants$T-1,0,1),\n                                  z = zinits)\nparameters.to.save <- c(\"phi\", \"p\")\nn.iter <- 5000\nn.burnin <- 1000\nn.chains <- 2\nmcmc.output <- nimbleMCMC(code = hmm.phitpt,\n                          constants = my.constants,\n                          data = my.data,\n                          inits = initial.values,\n                          monitors = parameters.to.save,\n                          niter = n.iter,\n                          nburnin = n.burnin,\n                          nchains = n.chains)\nMCMCsummary(mcmc.output, round = 2)##        mean   sd 2.5%  50% 97.5% Rhat n.eff\n## phi[1] 0.73 0.14 0.46 0.72  0.99 1.02   199\n## phi[2] 0.45 0.07 0.32 0.44  0.59 1.02   410\n## phi[3] 0.48 0.06 0.35 0.48  0.59 1.01   506\n## phi[4] 0.63 0.06 0.52 0.63  0.75 1.03   415\n## phi[5] 0.60 0.06 0.49 0.60  0.72 1.01   365\n## phi[6] 0.74 0.13 0.51 0.74  0.97 1.10    38\n## p[1]   0.66 0.14 0.38 0.67  0.89 1.01   344\n## p[2]   0.87 0.08 0.68 0.89  0.98 1.02   249\n## p[3]   0.88 0.07 0.73 0.89  0.97 1.02   307\n## p[4]   0.87 0.06 0.74 0.88  0.96 1.05   333\n## p[5]   0.90 0.05 0.77 0.91  0.98 1.01   224\n## p[6]   0.72 0.13 0.50 0.72  0.97 1.08    37\npriors <- runif(3000, 0, 1)\nMCMCtrace(object = mcmc.phitpt,\n          ISB = FALSE,\n          exact = TRUE, \n          params = c(\"phi[6]\"),\n          pdf = FALSE, \n          priors = priors)"},{"path":"survival.html","id":"cjs-model-derivatives","chapter":"1 Survival","heading":"1.5 CJS model derivatives","text":"Besides model considered constant parameters (see Chapter ??) CJS model time-varying parameters, might want fit -models time variation either detection survival.Let’s start model time-varying survival constant detection. modify CJS model NIMBLE code longer observation matrix time-specific:obtain following numerical summaries parameters, confirming high detection temporal variation survival:Now model time-varying detection constant survival, NIMBLE code constant time transition matrix:Numerical summaries parameters :note two models longer parameter redundancy issues. left four models, saying different story data, temporal variation either survival detection probabilty. quantify plausible four ecological hypotheses? Rendez-vous next section.","code":"\nhmm.phitp <- nimbleCode({\n  for (t in 1:(T-1)){\n    phi[t] ~ dunif(0, 1) # prior survival\n    gamma[1,1,t] <- phi[t]      # Pr(alive t -> alive t+1)\n    gamma[1,2,t] <- 1 - phi[t]  # Pr(alive t -> dead t+1)\n    gamma[2,1,t] <- 0        # Pr(dead t -> alive t+1)\n    gamma[2,2,t] <- 1        # Pr(dead t -> dead t+1)\n  }\n  p ~ dunif(0, 1) # prior detection\n  delta[1] <- 1          # Pr(alive t = 1) = 1\n  delta[2] <- 0          # Pr(dead t = 1) = 0\n  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)\n  omega[1,2] <- p        # Pr(alive t -> detected t)\n  omega[2,1] <- 1        # Pr(dead t -> non-detected t)\n  omega[2,2] <- 0        # Pr(dead t -> detected t)\n  # likelihood\n  for (i in 1:N){\n    z[i,first[i]] ~ dcat(delta[1:2])\n    for (j in (first[i]+1):T){\n      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])\n      y[i,j] ~ dcat(omega[z[i,j], 1:2])\n    }\n  }\n})##        mean   sd 2.5%  50% 97.5% Rhat n.eff\n## phi[1] 0.63 0.10 0.42 0.63  0.82 1.04   564\n## phi[2] 0.46 0.06 0.35 0.46  0.59 1.01   629\n## phi[3] 0.48 0.05 0.37 0.48  0.59 1.00   610\n## phi[4] 0.62 0.06 0.51 0.62  0.73 1.00   553\n## phi[5] 0.61 0.05 0.50 0.61  0.72 1.00   568\n## phi[6] 0.59 0.05 0.48 0.59  0.69 1.03   463\n## p      0.89 0.03 0.82 0.89  0.95 1.04   211\nhmm.phipt <- nimbleCode({\n  phi ~ dunif(0, 1) # prior survival\n  gamma[1,1] <- phi      # Pr(alive t -> alive t+1)\n  gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)\n  gamma[2,1] <- 0        # Pr(dead t -> alive t+1)\n  gamma[2,2] <- 1        # Pr(dead t -> dead t+1)\n  delta[1] <- 1          # Pr(alive t = 1) = 1\n  delta[2] <- 0          # Pr(dead t = 1) = 0\n  for (t in 1:(T-1)){\n    p[t] ~ dunif(0, 1) # prior detection\n    omega[1,1,t] <- 1 - p[t]    # Pr(alive t -> non-detected t)\n    omega[1,2,t] <- p[t]        # Pr(alive t -> detected t)\n    omega[2,1,t] <- 1        # Pr(dead t -> non-detected t)\n    omega[2,2,t] <- 0        # Pr(dead t -> detected t)\n  }\n  # likelihood\n  for (i in 1:N){\n    z[i,first[i]] ~ dcat(delta[1:2])\n    for (j in (first[i]+1):T){\n      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2])\n      y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1])\n    }\n  }\n})##      mean   sd 2.5%  50% 97.5% Rhat n.eff\n## phi  0.56 0.03 0.52 0.56  0.61 1.02   381\n## p[1] 0.75 0.12 0.48 0.77  0.93 1.03   452\n## p[2] 0.85 0.08 0.68 0.86  0.97 1.02   359\n## p[3] 0.85 0.07 0.69 0.85  0.96 1.00   316\n## p[4] 0.89 0.05 0.77 0.89  0.97 1.00   412\n## p[5] 0.91 0.04 0.82 0.92  0.98 1.00   376\n## p[6] 0.90 0.07 0.73 0.91  1.00 1.07   111"},{"path":"survival.html","id":"waic","chapter":"1 Survival","heading":"1.6 Model comparison with WAIC","text":"four models best supported data? answer question, need bear mind used observed data fit models, close truth models perform predicting future data – predictive accuracy – assessed. natural candidate measure predictive accuracy likelihood often referred context model comparison predictive density. However, know neither true process, future data, can estimate predictive density bias.may heard Akaike Information Criterion (AIC) Frequentist framework, Deviance Information Criterion (DIC) Bayesian framework. consider Widely Applicable Information Criterion Watanabe Information Criterion (WAIC). AIC, DIC WAIC aim provide approximation predictive accuracy.AIC predictive measure choice Frequentist framework ecologists, DIC around time Bayesian applications due availability population BUGS pieces software. However, methods utilize point estimate unknown parameters. Also, various difficulties noted DIC may give nonsensical results posterior distribution well summarized mean. fully Bayesian approach like use entire posterior distribution evaluate predictive performance, exactly WAIC .Conveniently, NIMBLE calculates WAIC . modifications need make ) monitor latent states ii) add WAIC = TRUE call nimbleMCMC() function. example, CJS model, write:re-ran four models calculate WAIC value themLower values WAIC imply higher predictive accuracy, thefore favor model constant parameters.","code":"\nparameters.to.save <- c(\"phi\", \"p\", \"z\") \nmcmc.phitpt <- nimbleMCMC(code = hmm.phitpt,\n                          constants = my.constants,\n                          data = my.data,\n                          inits = initial.values,\n                          monitors = parameters.to.save,\n                          niter = n.iter,\n                          nburnin = n.burnin,\n                          nchains = n.chains,\n                          WAIC = TRUE) ##                                                    model\n## 1        model with both survival and detection constant\n## 2 model with time-dependent survival, constant detection\n## 3 model with constant survival, time-dependent detection\n## 4                                              CJS model\n##    WAIC\n## 1 265.9\n## 2 277.6\n## 3 270.2\n## 4 308.8"},{"path":"survival.html","id":"goodness-of-fit-testing","chapter":"1 Survival","heading":"1.7 Goodness-of-fit testing","text":"previous Section 1.6, compared models based predictive accuracy – assessed relative fit. However, even though able rank models according predictive accuracy, happen models actually poor predictive performance – absolute fit.assess goodness fit CJS model capture-recapture data? particular assess homogeneity survival detection probabilities fundamental assumption model?Bayesian framework, rely posterior predictive checks assess absolute fit. Briefly speaking, idea compare observed data replicated data generated model. model good fit data, replicated data predicted model look similar observed data. simplify comparison, summary statistics generally considered built based ecological question interest.CJS model, posterior predictive checks can used. However, well established procedures assessing absolute fit departures specific model assumptions shame just ignore.focus two assumptions ecological interpretation, transience trap-dependence. transience procedure assesses whether newly encountered individuals chance later re-observed recaptured (previously encountered) individuals. trap-dependence procedure assesses whether missed individuals chance recaptured next occasion currently captured individuals. Although procedures called test transience test trap-dependence, comes interpretation, keep mind transience – excess individuals never seen – trap-dependence – effect trapping detection – just two specific reasons tests might detect lack fit.tests implemented package R2ucare, illustrate use dipper data.get capture-recapture data:sake illustration, consider females :overall test shows reject hypothesis CJS models fits data well:may perform test specifically assess transient effect:trap-dependence:tests significant? detect transient effect, 2 age classes considered survival probability account issue (fast forward covariate section ). Explain without talking age effect, survival effect considered. trap dependence significant, use time-varying individual covariate account effect. Explain covariate (fast forward section covariate ), consider complex models. Explain multievent model without talking states (fast forward case study).far, addressed assumptions relative model. also assumptions relative design. particular, survival refers study area, need think carefully survival actually mean. actually estimate usually call apparent survival, exactly true survival. Apparent survival probability product true survival study area fidelity. Consequently, apparent survival always lower true survival unless study area fidelity exactly 1. assumptions relative design, simply list . mark loss, identity individuals recorded without error (false positives), captured animals random sample population.","code":"\nlibrary(R2ucare)\n# capture-recapture data\ndipper <- read_csv(here::here(\"dat\", \"dipper.csv\"))\ndip.hist <- dipper %>%\n  select(year_1981:year_1987) %>%\n  as.matrix()\n# number of birds with that particular capture-recapture history\ndip.freq <- rep(1, nrow(dip.hist))\n# sex of each bird\ndip.group <- dipper$sex\nmask <- (dip.group == 'F')\ndip.fem.hist <- dip.hist[mask,]\ndip.fem.freq <- dip.freq[mask]\noverall_CJS(dip.fem.hist, dip.fem.freq)\n##                          chi2 degree_of_freedom p_value\n## Gof test for CJS model: 10.28                12   0.592\ntest3sr(dip.fem.hist, dip.fem.freq)\n## $test3sr\n##      stat        df     p_val sign_test \n##     4.985     5.000     0.418     1.428 \n## \n## $details\n##   component  stat p_val signed_test  test_perf\n## 1         2 0.858 0.354       0.926 Chi-square\n## 2         3 3.586 0.058       1.894 Chi-square\n## 3         4 0.437 0.509       0.661 Chi-square\n## 4         5 0.103 0.748      -0.321 Chi-square\n## 5         6 0.001 0.982       0.032 Chi-square\ntest2ct(dip.fem.hist, dip.fem.freq)\n## $test2ct\n##      stat        df     p_val sign_test \n##     3.250     4.000     0.517    -0.901 \n## \n## $details\n##   component dof stat p_val signed_test test_perf\n## 1         2   1    0     1           0    Fisher\n## 2         3   1    0     1           0    Fisher\n## 3         4   1    0     1           0    Fisher\n## 4         5   1 3.25 0.071      -1.803    Fisher"},{"path":"survival.html","id":"covariates","chapter":"1 Survival","heading":"1.8 Covariates","text":"Blabla sur le pourquoi des covariables.","code":""},{"path":"survival.html","id":"temporal-covariates","chapter":"1 Survival","heading":"1.8.1 Temporal covariates","text":"","code":""},{"path":"survival.html","id":"discrete","chapter":"1 Survival","heading":"1.8.1.1 Discrete","text":"Also consider flood effect discrete cov. major flood occurred 1983 breeding season. captures breding season occurred well flood, survival two years 1982-1983 1983-1984 likely affected. Indeed survival species living along feeding river two flood years likely lower nonflood years.Flood / nonflood year covariate:Constants list.Initial values.Parameters monitored.Run nimble.Regression intercept slope. Caterpillar plot regression parameters. posterior distribution slope centered negative values, suggesting water flow increases, survival decreases.gives survival nonflood years (inv logit \\(\\beta_1\\)) 0.61 (0.54, 0.66) flood year (logit \\(\\beta_1+\\beta_2\\)) 0.48 (0.4, 0.56).WAIC mcmc.phifloodp$WAIC$WAIC. Survival flood years lower nonflood years.Let’s use covariate \\(\\text{flood}\\) contains 1s 2s, indicating whether flood nonflood year year: 1 nonflood year, 2 flood year. E.g. year \\(t = 2\\), beta[flood[t]] gives beta[flood[2]] beta[1] beta[2] depending whether flood[2] 1 2.Flood / nonflood year covariate:Constants list.Initial values.Parameters monitored.Run nimble.Regression intercept slope. Caterpillar plot regression parameters. posterior distribution slope centered negative values, suggesting water flow increases, survival decreases.gives survival flood years 0.61 (0.55, 0.67) nonflood year 0.47 (0.39, 0.55).WAIC mcmc.phifloodp$WAIC$WAIC. Survival flood years lower nonflood years.","code":"\nhmm.phifloodp <- nimbleCode({\n  delta[1] <- 1          # Pr(alive t = 1) = 1\n  delta[2] <- 0          # Pr(dead t = 1) = 0\n  for (t in 1:(T-1)){\n    logit(phi[t]) <- beta[1] + beta[2] * flood[t]\n    gamma[1,1,t] <- phi[t]      # Pr(alive t -> alive t+1)\n    gamma[1,2,t] <- 1 - phi[t]  # Pr(alive t -> dead t+1)\n    gamma[2,1,t] <- 0        # Pr(dead t -> alive t+1)\n    gamma[2,2,t] <- 1        # Pr(dead t -> dead t+1)\n  }\n  p ~ dunif(0, 1) # prior detection\n  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)\n  omega[1,2] <- p        # Pr(alive t -> detected t)\n  omega[2,1] <- 1        # Pr(dead t -> non-detected t)\n  omega[2,2] <- 0        # Pr(dead t -> detected t)\n  beta[1] ~ dnorm(0, 1.5) # prior intercept\n  beta[2] ~ dnorm(0, 1.5) # prior slope\n  # likelihood\n  for (i in 1:N){\n    z[i,first[i]] ~ dcat(delta[1:2])\n    for (j in (first[i]+1):T){\n      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])\n      y[i,j] ~ dcat(omega[z[i,j], 1:2])\n    }\n  }\n})\nflood <- c(0, 1, 1, 0, 0, 0) # 1981-1982, 1982-1983, 1983-1984, 1984-1985, ...\nmy.constants <- list(N = nrow(y),\n                     T = ncol(y),\n                     first = first,\n                     flood = flood)\ninitial.values <- function() list(beta = rnorm(2,0,1),\n                                  p = runif(1,0,1),\n                                  z = zinits)\nparameters.to.save <- c(\"beta\", \"p\", \"phi\", \"z\")\nmcmc.phifloodp <- nimbleMCMC(code = hmm.phifloodp, \n                          constants = my.constants,\n                          data = my.data,              \n                          inits = initial.values,\n                          monitors = parameters.to.save,\n                          niter = n.iter,\n                          nburnin = n.burnin, \n                          nchains = n.chains,\n                          WAIC = TRUE)\nflood <- c(1, 2, 2, 1, 1, 1) # 1981-1982, 1982-1983, 1983-1984, 1984-1985, ...\nhmm.phifloodp <- nimbleCode({\n  delta[1] <- 1          # Pr(alive t = 1) = 1\n  delta[2] <- 0          # Pr(dead t = 1) = 0\n  for (t in 1:(T-1)){\n    phi[t] <- beta[flood[t]]\n    gamma[1,1,t] <- phi[t]      # Pr(alive t -> alive t+1)\n    gamma[1,2,t] <- 1 - phi[t]  # Pr(alive t -> dead t+1)\n    gamma[2,1,t] <- 0        # Pr(dead t -> alive t+1)\n    gamma[2,2,t] <- 1        # Pr(dead t -> dead t+1)\n  }\n  p ~ dunif(0, 1) # prior detection\n  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)\n  omega[1,2] <- p        # Pr(alive t -> detected t)\n  omega[2,1] <- 1        # Pr(dead t -> non-detected t)\n  omega[2,2] <- 0        # Pr(dead t -> detected t)\n  beta[1] ~ dunif(0, 1) # prior intercept\n  beta[2] ~ dunif(0, 1) # prior slope\n  # likelihood\n  for (i in 1:N){\n    z[i,first[i]] ~ dcat(delta[1:2])\n    for (j in (first[i]+1):T){\n      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])\n      y[i,j] ~ dcat(omega[z[i,j], 1:2])\n    }\n  }\n})\nmy.constants <- list(N = nrow(y),\n                     T = ncol(y),\n                     first = first,\n                     flood = flood)\ninitial.values <- function() list(beta = runif(2,0,1),\n                                  p = runif(1,0,1),\n                                  z = zinits)\nparameters.to.save <- c(\"beta\", \"p\", \"phi\", \"z\")\nmcmc.phifloodp <- nimbleMCMC(code = hmm.phifloodp, \n                             constants = my.constants,\n                             data = my.data,              \n                             inits = initial.values,\n                             monitors = parameters.to.save,\n                             niter = n.iter,\n                             nburnin = n.burnin, \n                             nchains = n.chains,\n                             WAIC = TRUE)"},{"path":"survival.html","id":"continuous","chapter":"1 Survival","heading":"1.8.1.2 Continuous","text":"Include temporal covariates, say \\(x_t\\), \\(\\text{logit}(\\phi_t) = \\beta_1 + \\beta_2 x_t\\). explain logit link function bit caution priors. Let’s investigate effect water flow dipper survival (Marzolin 2002). Now ’d like add temporal covariate try explain annual variation survival. pick water flow river. specify relationship logit scale.take values need, standardize covariate. Insist think covariate operates time interval.Constants list.Initial values.Parameters monitored.Run nimble.Regression intercept slope. Caterpillar plot regression parameters. posterior distribution slope centered negative values, suggesting water flow increases, survival decreases.\n\nTime-dependent (covariate constrained) survival probability estimates. Caterpillar plot survival estimates. Survival 1982 1983 seems affected highly huge water flow compared years. Coherent previous section flood effect.\n","code":"\nhmm.phiflowp <- nimbleCode({\n  delta[1] <- 1          # Pr(alive t = 1) = 1\n  delta[2] <- 0          # Pr(dead t = 1) = 0\n  for (t in 1:(T-1)){\n    logit(phi[t]) <- beta[1] + beta[2] * flow[t] \n    gamma[1,1,t] <- phi[t]      # Pr(alive t -> alive t+1)\n    gamma[1,2,t] <- 1 - phi[t]  # Pr(alive t -> dead t+1)\n    gamma[2,1,t] <- 0        # Pr(dead t -> alive t+1)\n    gamma[2,2,t] <- 1        # Pr(dead t -> dead t+1)\n  }\n  p ~ dunif(0, 1) # prior detection\n  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)\n  omega[1,2] <- p        # Pr(alive t -> detected t)\n  omega[2,1] <- 1        # Pr(dead t -> non-detected t)\n  omega[2,2] <- 0        # Pr(dead t -> detected t)\n  beta[1] ~ dnorm(0, 1.5) # prior intercept\n  beta[2] ~ dnorm(0, 1.5) # prior slope\n  # likelihood\n  for (i in 1:N){\n    z[i,first[i]] ~ dcat(delta[1:2])\n    for (j in (first[i]+1):T){\n      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])\n      y[i,j] ~ dcat(omega[z[i,j], 1:2])\n    }\n  }\n})\n# water flow in L/s\nwater_flow <- c(443, 1114, 529, 434, 627, 466) # 1981, 1982, ..., 1987\nwater_flow_st <- (water_flow - mean(water_flow))/sd(water_flow)\nmy.constants <- list(N = nrow(y),\n                     T = ncol(y),\n                     first = first,\n                     flow = water_flow_st)\ninitial.values <- function() list(beta = rnorm(2,0,1),\n                                  p = runif(1,0,1),\n                                  z = zinits)\nparameters.to.save <- c(\"beta\", \"p\", \"phi\")\nmcmc.phiflowp <- nimbleMCMC(code = hmm.phiflowp, \n                          constants = my.constants,\n                          data = my.data,              \n                          inits = initial.values,\n                          monitors = parameters.to.save,\n                          niter = n.iter,\n                          nburnin = n.burnin, \n                          nchains = n.chains)"},{"path":"survival.html","id":"individual-covariates","chapter":"1 Survival","heading":"1.8.2 Individual covariates","text":"Discrete covariate like, e.g., sexDiscrete covariate like, e.g., sexContinuous covariate like, e.g., mass sizeContinuous covariate like, e.g., mass sizeSex wing length Dipper","code":""},{"path":"survival.html","id":"discrete-1","chapter":"1 Survival","heading":"1.8.2.1 Discrete","text":"Sex effectLet’s use covariate \\(\\text{sex}\\) takes value 0 male, 1 femaleLet’s use covariate \\(\\text{sex}\\) takes value 0 male, 1 femaleAnd write \\(\\text{logit}(\\phi_i) = \\beta_1 + \\beta_2 \\; \\text{sex}_i\\) bird \\(\\)write \\(\\text{logit}(\\phi_i) = \\beta_1 + \\beta_2 \\; \\text{sex}_i\\) bird \\(\\)male survival isThen male survival \\[\\text{logit}(\\phi_i) = \\beta_1\\]female survival \\[\\text{logit}(\\phi_i) = \\beta_1 + \\beta_2\\]Nimble implementation sex covariateNIMBLE implementation nested indexingLet’s use covariate \\(\\text{sex}\\) contains 1s 2s, indicating sex individual: 1 male, 2 femaleE.g. individual \\(= 2\\), beta[sex[]] gives beta[sex[2]] beta[1] beta[2] depending whether sex[2] 1 2.","code":"\nhmm.phisexp <- nimbleCode({\n...\n  for (i in 1:N){ #<<\n    logit(phi[i]) <- beta[1] + beta[2] * sex[i]\n    gamma[1,1,i] <- phi[i]      # Pr(alive t -> alive t+1)\n    gamma[1,2,i] <- 1 - phi[i]  # Pr(alive t -> dead t+1)\n    gamma[2,1,i] <- 0        # Pr(dead t -> alive t+1)\n    gamma[2,2,i] <- 1        # Pr(dead t -> dead t+1)\n  } #<<\n  beta[1] ~ dnorm(mean = 0, sd = 1.5)\n  beta[2] ~ dnorm(mean = 0, sd = 1.5)\n  phi_male <- 1/(1+exp(-beta[1]))\n  phi_female <- 1/(1+exp(-(beta[1]+beta[2])))\n...\n  # likelihood\n  for (i in 1:N){\n    z[i,first[i]] ~ dcat(delta[1:2])\n    for (j in (first[i]+1):T){\n      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, i])\n      y[i,j] ~ dcat(omega[z[i,j], 1:2])\n    }\n  }\n})##             mean   sd  2.5%   50% 97.5% Rhat n.eff\n## beta[1]     0.29 0.14  0.01  0.29  0.57 1.01   237\n## beta[2]    -0.09 0.19 -0.47 -0.10  0.29 1.01   241\n## p           0.90 0.03  0.83  0.90  0.95 1.02   253\n## phi_female  0.55 0.04  0.48  0.55  0.62 1.02   698\n## phi_male    0.57 0.03  0.50  0.57  0.64 1.01   237\n...\nfor (i in 1:N){\n  phi[i] <- beta[sex[i]]\n  gamma[1,1,i] <- phi[i]      # Pr(alive t -> alive t+1)\n  gamma[1,2,i] <- 1 - phi[i]  # Pr(alive t -> dead t+1)\n  gamma[2,1,i] <- 0           # Pr(dead t -> alive t+1)\n  gamma[2,2,i] <- 1           # Pr(dead t -> dead t+1)\n}\nbeta[1] ~ dunif(0,1) # male survival #<<\nbeta[2] ~ dunif(0,1) # female survival #<<\n...##         mean   sd 2.5%  50% 97.5% Rhat n.eff\n## beta[1] 0.57 0.03 0.50 0.57  0.63 1.00   616\n## beta[2] 0.55 0.03 0.48 0.55  0.62 1.02   657\n## p       0.90 0.03 0.83 0.90  0.95 1.10   229"},{"path":"survival.html","id":"continuous-1","chapter":"1 Survival","heading":"1.8.2.2 Continuous","text":"Besides discrete individual covariates, might want continuous individual covariates, e.g. wing length dipper case study. Note ’re considering individual trait takes value whatever occasion. time-varying individual covariate model, something missing values covariate individual recaptured. easiest way cope time-varying individual covariate discretize treat levels covariates states. next live demo. Back wing length. first standardize covariate.Now write model. Basically replace sex wing length first method used previous section. Easy.Constants list.Initial values.Run nimble.Numerical summaries. Wing length seem explain much individual--individual variation survival. See corresponding slope param.Let’s plot relationship. First, gather values generated posterior distribution regression parameters two chains.define grid values wing length, predict survival MCMC iteration.Now calculate posterior mean credible interval. Note ordering.Now time visualize.","code":"\n...\n  for (i in 1:N){ #<<\n    logit(phi[i]) <- beta[1] + beta[2] * winglength[i] #<<\n    gamma[1,1,i] <- phi[i]      # Pr(alive t -> alive t+1)\n    gamma[1,2,i] <- 1 - phi[i]  # Pr(alive t -> dead t+1)\n    gamma[2,1,i] <- 0        # Pr(dead t -> alive t+1)\n    gamma[2,2,i] <- 1        # Pr(dead t -> dead t+1)\n  }\n  beta[1] ~ dnorm(mean = 0, sd = 1.5) # intercept #<<\n  beta[2] ~ dnorm(mean = 0, sd = 1.5) # slope #<<\n...\ndipper <- read_csv(\"dat/dipper.csv\")\ny <- dipper %>%\n  select(year_1981:year_1987) %>%\n  as.matrix()\nwing.length.st <- as.vector(scale(dipper$wing_length))\nhead(wing.length.st)\n## [1]  0.7581 -0.8671  0.5260 -1.5637 -1.3315  1.2225\nhmm.phiwlp <- nimbleCode({\n    p ~ dunif(0, 1) # prior detection\n    omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)\n    omega[1,2] <- p        # Pr(alive t -> detected t)\n    omega[2,1] <- 1        # Pr(dead t -> non-detected t)\n    omega[2,2] <- 0        # Pr(dead t -> detected t)\n  for (i in 1:N){\n    logit(phi[i]) <- beta[1] + beta[2] * winglength[i]\n    gamma[1,1,i] <- phi[i]      # Pr(alive t -> alive t+1)\n    gamma[1,2,i] <- 1 - phi[i]  # Pr(alive t -> dead t+1)\n    gamma[2,1,i] <- 0           # Pr(dead t -> alive t+1)\n    gamma[2,2,i] <- 1           # Pr(dead t -> dead t+1)\n  }\n  beta[1] ~ dnorm(mean = 0, sd = 1.5)\n  beta[2] ~ dnorm(mean = 0, sd = 1.5)\n  delta[1] <- 1          # Pr(alive t = 1) = 1\n  delta[2] <- 0          # Pr(dead t = 1) = 0\n  # likelihood\n  for (i in 1:N){\n    z[i,first[i]] ~ dcat(delta[1:2])\n    for (j in (first[i]+1):T){\n      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, i])\n      y[i,j] ~ dcat(omega[z[i,j], 1:2])\n    }\n  }\n})\nmy.constants <- list(N = nrow(y), \n                     T = ncol(y), \n                     first = first,\n                     winglength = wing.length.st)\ninitial.values <- function() list(beta = rnorm(2,0,1),\n                                  p = runif(1,0,1),\n                                  z = zinits)\nmcmc.phiwlp <- nimbleMCMC(code = hmm.phiwlp, \n                          constants = my.constants,\n                          data = my.data,              \n                          inits = initial.values,\n                          monitors = parameters.to.save,\n                          niter = n.iter,\n                          nburnin = n.burnin, \n                          nchains = n.chains)\n## |-------------|-------------|-------------|-------------|\n## |-------------------------------------------------------|\n## |-------------|-------------|-------------|-------------|\n## |-------------------------------------------------------|\nload(here::here(\"dat/phiwlp.RData\"))\nMCMCsummary(mcmc.phiwlp, params = \"beta\", round = 2)\n##          mean   sd  2.5%   50% 97.5% Rhat n.eff\n## beta[1]  0.25 0.10  0.04  0.25  0.45    1  1472\n## beta[2] -0.02 0.09 -0.20 -0.02  0.17    1  1555\nbeta1 <- c(mcmc.phiwlp$chain1[,'beta[1]'], mcmc.phiwlp$chain2[,'beta[1]'])\nbeta2 <- c(mcmc.phiwlp$chain1[,'beta[2]'], mcmc.phiwlp$chain2[,'beta[2]'])\npredicted_survival <- matrix(NA, nrow = length(beta1), ncol = length(my.constants$winglength))\nfor (i in 1:length(beta1)){\n  for (j in 1:length(my.constants$winglength)){\n    predicted_survival[i,j] <- plogis(beta1[i] + beta2[i] * my.constants$winglength[j])\n  }\n}\nmean_survival <- apply(predicted_survival, 2, mean)\nlci <- apply(predicted_survival, 2, quantile, prob = 2.5/100)\nuci <- apply(predicted_survival, 2, quantile, prob = 97.5/100)\nord <- order(my.constants$winglength)\ndf <- data.frame(wing_length = my.constants$winglength[ord],\n                 survival = mean_survival[ord],\n                 lci = lci[ord],\n                 uci = uci[ord])\ndf %>%\n  ggplot() + \n  aes(x = wing_length, y = survival) + \n  geom_line() + \n  geom_ribbon(aes(ymin = lci, ymax = uci), fill = \"grey70\", alpha = 0.5) + \n  ylim(0,1) + \n  labs(x = \"wing length\", y = \"estimated survival\")"},{"path":"survival.html","id":"additive-and-interaction","chapter":"1 Survival","heading":"1.8.3 Additive and interaction","text":"may test effect sex wing length. Write model. use nested indexing sex index contains 1 bird male, 2 otherwise. \\(\\logit(\\phi_i) = \\beta_1 + \\beta_3 * \\text{winglength}_i\\) males, \\(\\logit(\\phi_i) = \\beta_2 + \\beta_3 * \\text{winglength}_i\\) females.Constants list. Note standardise wing length.Data list.Initial values.Parameters monitored.MCMC details.Run nimble.Display results.Let’s visualise survival function wing length sexes.First put together values two chains generated posterior distributions regression parameters.get survival estimates MCMC iteration., may calculate posterior mean credible intervals.Now plot.","code":"\nhmm.phisexwlp <- nimbleCode({\n  p ~ dunif(0, 1) # prior detection\n  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)\n  omega[1,2] <- p        # Pr(alive t -> detected t)\n  omega[2,1] <- 1        # Pr(dead t -> non-detected t)\n  omega[2,2] <- 0        # Pr(dead t -> detected t)\n  for (i in 1:N){\n    logit(phi[i]) <- beta[sex[i]] + beta[3] * winglength[i]\n    gamma[1,1,i] <- phi[i]      # Pr(alive t -> alive t+1)\n    gamma[1,2,i] <- 1 - phi[i]  # Pr(alive t -> dead t+1)\n    gamma[2,1,i] <- 0           # Pr(dead t -> alive t+1)\n    gamma[2,2,i] <- 1           # Pr(dead t -> dead t+1)\n  }\n  beta[1] ~ dnorm(mean = 0, sd = 1.5) # intercept male\n  beta[2] ~ dnorm(mean = 0, sd = 1.5) # intercept female\n  beta[3] ~ dnorm(mean = 0, sd = 1.5) # slope wing length\n  delta[1] <- 1          # Pr(alive t = 1) = 1\n  delta[2] <- 0          # Pr(dead t = 1) = 0\n  # likelihood\n  for (i in 1:N){\n    z[i,first[i]] ~ dcat(delta[1:2])\n    for (j in (first[i]+1):T){\n      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, i])\n      y[i,j] ~ dcat(omega[z[i,j], 1:2])\n    }\n  }\n})\nfirst <- apply(y, 1, function(x) min(which(x !=0)))\nwing.length.st <- as.vector(scale(dipper$wing_length))\nmy.constants <- list(N = nrow(y), \n                     T = ncol(y), \n                     first = first,\n                     winglength = wing.length.st,\n                     sex = if_else(dipper$sex == \"M\", 1, 2))\nmy.data <- list(y = y + 1)\nmy.data <- list(y = y + 1)\nzinits <- y\nzinits[zinits == 0] <- 1\ninitial.values <- function() list(beta = rnorm(3,0,5),\n                                  p = runif(1,0,1),\n                                  z = zinits)\nparameters.to.save <- c(\"beta\", \"p\")\nn.iter <- 5000\nn.burnin <- 2500\nn.chains <- 2\nmcmc.phisexwlp <- nimbleMCMC(code = hmm.phisexwlp, \n                             constants = my.constants,\n                             data = my.data,              \n                             inits = initial.values,\n                             monitors = parameters.to.save,\n                             niter = n.iter,\n                             nburnin = n.burnin, \n                             nchains = n.chains)##          mean   sd  2.5%   50% 97.5% Rhat n.eff\n## beta[1]  0.52 0.23  0.07  0.53  0.96 1.01   223\n## beta[2] -0.02 0.22 -0.47 -0.02  0.42 1.02   199\n## beta[3] -0.25 0.19 -0.61 -0.25  0.14 1.02   144\n## p        0.90 0.03  0.83  0.90  0.95 1.02   466\nbeta1 <- c(mcmc.phisexwlp$chain1[,'beta[1]'], mcmc.phisexwlp$chain2[,'beta[1]'])\nbeta2 <- c(mcmc.phisexwlp$chain1[,'beta[2]'], mcmc.phisexwlp$chain2[,'beta[2]'])\nbeta3 <- c(mcmc.phisexwlp$chain1[,'beta[3]'], mcmc.phisexwlp$chain2[,'beta[3]'])\npredicted_survivalM <- matrix(NA, nrow = length(beta1), ncol = length(my.constants$winglength))\npredicted_survivalF <- matrix(NA, nrow = length(beta1), ncol = length(my.constants$winglength))\nfor (i in 1:length(beta1)){\n  for (j in 1:length(my.constants$winglength)){\n    predicted_survivalM[i,j] <- plogis(beta1[i] + beta3[i] * my.constants$winglength[j]) # males\n    predicted_survivalF[i,j] <- plogis(beta2[i] + beta3[i] * my.constants$winglength[j]) # females\n  }\n}\nmean_survivalM <- apply(predicted_survivalM, 2, mean)\nlciM <- apply(predicted_survivalM, 2, quantile, prob = 2.5/100)\nuciM <- apply(predicted_survivalM, 2, quantile, prob = 97.5/100)\nmean_survivalF <- apply(predicted_survivalF, 2, mean)\nlciF <- apply(predicted_survivalF, 2, quantile, prob = 2.5/100)\nuciF <- apply(predicted_survivalF, 2, quantile, prob = 97.5/100)\nord <- order(my.constants$winglength)\ndf <- data.frame(wing_length = c(my.constants$winglength[ord], my.constants$winglength[ord]),\n                 survival = c(mean_survivalM[ord], mean_survivalF[ord]),\n                 lci = c(lciM[ord],lciF[ord]),\n                 uci = c(uciM[ord],uciF[ord]),\n                 sex = c(rep(\"male\", length(mean_survivalM)), rep(\"female\", length(mean_survivalF))))\ndf %>%\n  ggplot() + \n  aes(x = wing_length, y = survival, color = sex) + \n  geom_line() + \n  geom_ribbon(aes(ymin = lci, ymax = uci, fill = sex), alpha = 0.5) + \n  ylim(0,1) + \n  labs(x = \"wing length\", y = \"estimated survival\", color = \"\", fill = \"\")"},{"path":"survival.html","id":"random-effects","chapter":"1 Survival","heading":"1.8.4 Random effects","text":"","code":""},{"path":"survival.html","id":"temporal","chapter":"1 Survival","heading":"1.8.4.1 Temporal","text":"Include temporal covariates, say \\(x_t\\) \\(\\text{logit}(\\phi_t) = \\beta_1 + \\beta_2 x_t\\). temporal variation fully explained covariates, add random effects \\(\\text{logit}(\\phi_t) = \\beta_1 + \\beta_2 x_t + \\varepsilon_t, \\; \\varepsilon_t \\sim N(0,\\sigma^2)\\). may wish allow extra variation survival vs. water flow relationship. , consider yearly random effect. prior standard deviation random effect uniform 0 10.Initial values.Parameters monitored.MCMC details. Note ’ve increased number iterations length burn-period.Run nimble.Display outputs. Seems water flow effect important anymore.Trace plots standard deviation random effect.","code":"\nhmm.phiflowREpt <- nimbleCode({\n  delta[1] <- 1          # Pr(alive t = 1) = 1\n  delta[2] <- 0          # Pr(dead t = 1) = 0\n  for (t in 1:(T-1)){\n    logit(phi[t]) <- beta[1] + beta[2] * flow[t] + eps[t] # eps is random effect\n    eps[t] ~ dnorm(0, sd = sdeps) \n    gamma[1,1,t] <- phi[t]      # Pr(alive t -> alive t+1)\n    gamma[1,2,t] <- 1 - phi[t]  # Pr(alive t -> dead t+1)\n    gamma[2,1,t] <- 0           # Pr(dead t -> alive t+1)\n    gamma[2,2,t] <- 1           # Pr(dead t -> dead t+1)\n    p[t] ~ dunif(0, 1)          # prior detection\n    omega[1,1,t] <- 1 - p[t]    # Pr(alive t -> non-detected t)\n    omega[1,2,t] <- p[t]        # Pr(alive t -> detected t)\n    omega[2,1,t] <- 1           # Pr(dead t -> non-detected t)\n    omega[2,2,t] <- 0           # Pr(dead t -> detected t)\n  }\n  beta[1] ~ dnorm(0, 1.5) # prior intercept\n  beta[2] ~ dnorm(0, 1.5) # prior slope\n  sdeps ~ dunif(0,10)\n  # likelihood\n  for (i in 1:N){\n    z[i,first[i]] ~ dcat(delta[1:2])\n    for (j in (first[i]+1):T){\n      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])\n      y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1])\n    }\n  }\n})\ninitial.values <- function() list(beta = rnorm(2,0,1),\n                                  p = runif(my.constants$T-1,0,1),\n                                  sdeps = runif(1,0,3),\n                                  z = zinits)\nparameters.to.save <- c(\"beta\", \"p\", \"phi\", \"sdeps\")\nn.iter <- 10000\nn.burnin <- 5000\nn.chains <- 2\nmcmc.phiflowREpt <- nimbleMCMC(code = hmm.phiflowREpt, \n                             constants = my.constants,\n                             data = my.data,              \n                             inits = initial.values,\n                             monitors = parameters.to.save,\n                             niter = n.iter,\n                             nburnin = n.burnin, \n                             nchains = n.chains)\nload(here::here(\"dat/phiflowREpt.RData\"))\nMCMCsummary(object = mcmc.phiflowREpt, round = 2)\n##          mean   sd  2.5%   50% 97.5% Rhat n.eff\n## beta[1]  0.27 0.25 -0.32  0.28  0.77 1.04   153\n## beta[2] -0.22 0.23 -0.65 -0.23  0.31 1.01   300\n## p[1]     0.70 0.13  0.44  0.71  0.92 1.00  1414\n## p[2]     0.88 0.07  0.70  0.89  0.98 1.00   971\n## p[3]     0.87 0.07  0.71  0.88  0.97 1.00   981\n## p[4]     0.88 0.05  0.75  0.88  0.96 1.01  1236\n## p[5]     0.91 0.05  0.80  0.91  0.98 1.00   974\n## p[6]     0.81 0.11  0.56  0.83  0.98 1.00   164\n## phi[1]   0.65 0.09  0.48  0.63  0.84 1.00   490\n## phi[2]   0.45 0.07  0.32  0.45  0.59 1.00  1853\n## phi[3]   0.53 0.06  0.41  0.53  0.63 1.00   660\n## phi[4]   0.62 0.05  0.52  0.62  0.73 1.00  1238\n## phi[5]   0.59 0.05  0.50  0.59  0.69 1.01  1061\n## phi[6]   0.64 0.10  0.50  0.62  0.91 1.00   143\n## sdeps    0.47 0.54  0.05  0.34  1.59 1.08    91\nMCMCtrace(object = mcmc.phiflowREpt, params = \"sdeps\", pdf = FALSE)"},{"path":"survival.html","id":"individual","chapter":"1 Survival","heading":"1.8.4.2 Individual","text":"add individual random effect.Initial values.Parameters monitored.MCMC details. Note increase number iterations length burn-period.Run nimble.Numerical summaries.Effective sample size SD low. Let’s try something else. reparameterize non-centering.Initial values.Parameters monitored.MCMC details. Note increase number iterations length burn-period.Run nimble.Numerical summaries. Much better.Let’s plot posterior distribution standard deviation individual random effect.","code":"\nhmm.phiwlrep <- nimbleCode({\n    p ~ dunif(0, 1) # prior detection\n    omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)\n    omega[1,2] <- p        # Pr(alive t -> detected t)\n    omega[2,1] <- 1        # Pr(dead t -> non-detected t)\n    omega[2,2] <- 0        # Pr(dead t -> detected t)\n  for (i in 1:N){\n    logit(phi[i]) <- beta[1] + beta[2] * winglength[i] + eps[i]\n    eps[i] ~ dnorm(mean = 0, sd = sdeps)\n    gamma[1,1,i] <- phi[i]      # Pr(alive t -> alive t+1)\n    gamma[1,2,i] <- 1 - phi[i]  # Pr(alive t -> dead t+1)\n    gamma[2,1,i] <- 0           # Pr(dead t -> alive t+1)\n    gamma[2,2,i] <- 1           # Pr(dead t -> dead t+1)\n  }\n  beta[1] ~ dnorm(mean = 0, sd = 1.5)\n  beta[2] ~ dnorm(mean = 0, sd = 1.5)\n  sdeps ~ dunif(0, 10)\n  delta[1] <- 1          # Pr(alive t = 1) = 1\n  delta[2] <- 0          # Pr(dead t = 1) = 0\n  # likelihood\n  for (i in 1:N){\n    z[i,first[i]] ~ dcat(delta[1:2])\n    for (j in (first[i]+1):T){\n      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, i])\n      y[i,j] ~ dcat(omega[z[i,j], 1:2])\n    }\n  }\n})\ninitial.values <- function() list(beta = rnorm(2,0,1.5),\n                                  sdeps = runif(1,0,3),\n                                  p = runif(1,0,1),\n                                  z = zinits)\nparameters.to.save <- c(\"beta\", \"sdeps\", \"p\")\nn.iter <- 10000\nn.burnin <- 5000\nn.chains <- 2\nmcmc.phiwlrep <- nimbleMCMC(code = hmm.phiwlrep, \n                            constants = my.constants,\n                            data = my.data,              \n                            inits = initial.values,\n                            monitors = parameters.to.save,\n                            niter = n.iter,\n                            nburnin = n.burnin, \n                            nchains = n.chains)##          mean   sd  2.5%   50% 97.5% Rhat n.eff\n## beta[1]  0.21 0.12 -0.04  0.21  0.43 1.00  1202\n## beta[2] -0.01 0.10 -0.20 -0.01  0.19 1.00  1789\n## p        0.90 0.03  0.83  0.90  0.95 1.01   790\n## sdeps    0.40 0.26  0.02  0.37  0.95 1.01   170\nhmm.phiwlrep <- nimbleCode({\n    p ~ dunif(0, 1) # prior detection\n    omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)\n    omega[1,2] <- p        # Pr(alive t -> detected t)\n    omega[2,1] <- 1        # Pr(dead t -> non-detected t)\n    omega[2,2] <- 0        # Pr(dead t -> detected t)\n  for (i in 1:N){\n    logit(phi[i]) <- beta[1] + beta[2] * winglength[i] + sdeps * eps[i]\n    eps[i] ~ dnorm(mean = 0, sd = 1)\n    gamma[1,1,i] <- phi[i]      # Pr(alive t -> alive t+1)\n    gamma[1,2,i] <- 1 - phi[i]  # Pr(alive t -> dead t+1)\n    gamma[2,1,i] <- 0           # Pr(dead t -> alive t+1)\n    gamma[2,2,i] <- 1           # Pr(dead t -> dead t+1)\n  }\n  beta[1] ~ dnorm(mean = 0, sd = 1.5)\n  beta[2] ~ dnorm(mean = 0, sd = 1.5)\n  sdeps ~ dunif(0, 10)\n  delta[1] <- 1          # Pr(alive t = 1) = 1\n  delta[2] <- 0          # Pr(dead t = 1) = 0\n  # likelihood\n  for (i in 1:N){\n    z[i,first[i]] ~ dcat(delta[1:2])\n    for (j in (first[i]+1):T){\n      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, i])\n      y[i,j] ~ dcat(omega[z[i,j], 1:2])\n    }\n  }\n})\ninitial.values <- function() list(beta = rnorm(2,0,1.5),\n                                  sdeps = runif(1,0,3),\n                                  p = runif(1,0,1),\n                                  z = zinits)\nparameters.to.save <- c(\"beta\", \"sdeps\", \"p\")\nn.iter <- 10000\nn.burnin <- 5000\nn.chains <- 2\nmcmc.phiwlrep <- nimbleMCMC(code = hmm.phiwlrep, \n                            constants = my.constants,\n                            data = my.data,              \n                            inits = initial.values,\n                            monitors = parameters.to.save,\n                            niter = n.iter,\n                            nburnin = n.burnin, \n                            nchains = n.chains)##          mean   sd  2.5%   50% 97.5% Rhat n.eff\n## beta[1]  0.21 0.12 -0.04  0.21  0.43 1.00  1202\n## beta[2] -0.01 0.10 -0.20 -0.01  0.19 1.00  1789\n## p        0.90 0.03  0.83  0.90  0.95 1.01   790\n## sdeps    0.40 0.26  0.02  0.37  0.95 1.01   170\nsdeps <- c(mcmc.phiwlrep$chain1[,\"sdeps\"], mcmc.phiwlrep$chain2[,\"sdeps\"])\nsdeps %>%\n  as_tibble() %>%\n  ggplot() + \n  aes(x = value) + \n  geom_histogram(color = \"white\", binwidth = .03, fill = \"gray70\") + \n  geom_density(aes(y = .03 * ..count..))"},{"path":"survival.html","id":"what-if-covariates-vary-with-individual-and-time","chapter":"1 Survival","heading":"1.8.5 What if covariates vary with individual and time?","text":"","code":""},{"path":"survival.html","id":"age","chapter":"1 Survival","heading":"1.8.5.1 Age","text":"Think age example (see exercises Worksheets); covariate nested indexing works fine.Age capture-recapture particular meaning capture-recapture analyses. time elapsed since first encounter, proxy true age obviously, true age. course, age known first encounter, true age.Another important remark age individual covariate, contrast wing length covariate considered previous examples, age varies time. cool thing missing value age \\(t+1\\) just age \\(t\\) add 1. suggests way code age effect nimble follows.Constants list.Data list.Initial values.Parameters monitored.MCMC details.Run nimble.Display results.Another method include age effect create individual time covariate use nested indexing (previous example) distinguish survival first detection survival afterwards.model. Careful, now survival longer defined logit scale previous model, use uniform priors.Constants list, inculding age matrix covariate.Data list.Initial values.Parameters monitored.MCMC details.Run nimble.Display results.","code":"\nhmm.phiage.in <- nimbleCode({\n  p ~ dunif(0, 1) # prior detection\n  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)\n  omega[1,2] <- p        # Pr(alive t -> detected t)\n  omega[2,1] <- 1        # Pr(dead t -> non-detected t)\n  omega[2,2] <- 0        # Pr(dead t -> detected t)\n  for (i in 1:N){\n    for (t in first[i]:(T-1)){\n    logit(phi[i,t]) <- beta[1] + beta[2] * equals(t, first[i]) # phi1 = beta1 + beta2 and phi1+ = beta1\n    gamma[1,1,i,t] <- phi[i,t]      # Pr(alive t -> alive t+1)\n    gamma[1,2,i,t] <- 1 - phi[i,t]  # Pr(alive t -> dead t+1)\n    gamma[2,1,i,t] <- 0           # Pr(dead t -> alive t+1)\n    gamma[2,2,i,t] <- 1           # Pr(dead t -> dead t+1)\n    }\n  }\n  beta[1] ~ dnorm(mean = 0, sd = 1.5) # phi1+\n  beta[2] ~ dnorm(mean = 0, sd = 1.5) # phi1 - phi1+\n  phi1plus <- plogis(beta[1])         # phi1+\n  phi1 <- plogis(beta[1] + beta[2])   # phi1\n  delta[1] <- 1          # Pr(alive t = 1) = 1\n  delta[2] <- 0          # Pr(dead t = 1) = 0\n  # likelihood\n  for (i in 1:N){\n    z[i,first[i]] ~ dcat(delta[1:2])\n    for (j in (first[i]+1):T){\n      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, i, j-1])\n      y[i,j] ~ dcat(omega[z[i,j], 1:2])\n    }\n  }\n})\nfirst <- apply(y, 1, function(x) min(which(x !=0)))\nmy.constants <- list(N = nrow(y), \n                     T = ncol(y), \n                     first = first)\nmy.data <- list(y = y + 1)\nzinits <- y\nzinits[zinits == 0] <- 1\ninitial.values <- function() list(beta = rnorm(2,0,5),\n                                  p = runif(1,0,1),\n                                  z = zinits)\nparameters.to.save <- c(\"phi1\", \"phi1plus\", \"p\")\nn.iter <- 5000\nn.burnin <- 2500\nn.chains <- 2\nmcmc.phi.age.in <- nimbleMCMC(code = hmm.phiage.in, \n                             constants = my.constants,\n                             data = my.data,              \n                             inits = initial.values,\n                             monitors = parameters.to.save,\n                             niter = n.iter,\n                             nburnin = n.burnin, \n                             nchains = n.chains)##          mean   sd 2.5%  50% 97.5% Rhat n.eff\n## p        0.89 0.03 0.83 0.90  0.94 1.00   402\n## phi1     0.56 0.03 0.49 0.55  0.63 1.01   689\n## phi1plus 0.57 0.04 0.50 0.57  0.64 1.00   309\nage <- matrix(NA, nrow = nrow(y), ncol = ncol(y) - 1)\nfor (i in 1:nrow(age)){\n  for (j in 1:ncol(age)){\n    if (j == first[i]) age[i,j] <- 1\n    if (j > first[i]) age[i,j] <- 2\n  }\n}\nhmm.phiage.out <- nimbleCode({\n  p ~ dunif(0, 1) # prior detection\n  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)\n  omega[1,2] <- p        # Pr(alive t -> detected t)\n  omega[2,1] <- 1        # Pr(dead t -> non-detected t)\n  omega[2,2] <- 0        # Pr(dead t -> detected t)\n  for (i in 1:N){\n    for (t in first[i]:(T-1)){\n    phi[i,t] <- beta[age[i,t]] # beta1 = phi1, beta2 = phi1+\n    gamma[1,1,i,t] <- phi[i,t]      # Pr(alive t -> alive t+1)\n    gamma[1,2,i,t] <- 1 - phi[i,t]  # Pr(alive t -> dead t+1)\n    gamma[2,1,i,t] <- 0           # Pr(dead t -> alive t+1)\n    gamma[2,2,i,t] <- 1           # Pr(dead t -> dead t+1)\n    }\n  }\n  beta[1] ~ dunif(0, 1) # phi1\n  beta[2] ~ dunif(0, 1) # phi1+\n  phi1 <- beta[1]\n  phi1plus <- beta[2]\n  delta[1] <- 1          # Pr(alive t = 1) = 1\n  delta[2] <- 0          # Pr(dead t = 1) = 0\n  # likelihood\n  for (i in 1:N){\n    z[i,first[i]] ~ dcat(delta[1:2])\n    for (j in (first[i]+1):T){\n      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, i, j-1])\n      y[i,j] ~ dcat(omega[z[i,j], 1:2])\n    }\n  }\n})\nfirst <- apply(y, 1, function(x) min(which(x !=0)))\nmy.constants <- list(N = nrow(y), \n                     T = ncol(y), \n                     first = first,\n                     age = age)\nmy.data <- list(y = y + 1)\nzinits <- y\nzinits[zinits == 0] <- 1\ninitial.values <- function() list(beta = runif(2,0,1),\n                                  p = runif(1,0,1),\n                                  z = zinits)\nparameters.to.save <- c(\"phi1\", \"phi1plus\", \"p\")\nn.iter <- 5000\nn.burnin <- 2500\nn.chains <- 2\nmcmc.phi.age.out <- nimbleMCMC(code = hmm.phiage.out, \n                               constants = my.constants,\n                               data = my.data,              \n                               inits = initial.values,\n                               monitors = parameters.to.save,\n                               niter = n.iter,\n                               nburnin = n.burnin, \n                               nchains = n.chains)\nload(here::here(\"dat/phiageout.RData\"))\nMCMCsummary(mcmc.phi.age.out, round = 2)\n##          mean   sd 2.5%  50% 97.5% Rhat n.eff\n## p        0.90 0.03 0.84 0.90  0.95 1.02   438\n## phi1     0.55 0.03 0.48 0.55  0.62 1.00   878\n## phi1plus 0.57 0.04 0.50 0.57  0.64 1.02  1048"},{"path":"survival.html","id":"trap-dependence","chapter":"1 Survival","heading":"1.8.5.2 Trap-dependence","text":"Add example trap-dependence w/ time individual covariate. Move case study w/ multievent.","code":""},{"path":"survival.html","id":"missing-values","chapter":"1 Survival","heading":"1.8.5.3 Missing values","text":"Now, think body size across life. Problem record size animal non-detected. Discretize small, medium large treat state. later. Assume model covariate fill missing values (imputation).","code":""},{"path":"survival.html","id":"summary","chapter":"1 Survival","heading":"1.9 Summary","text":"Statistical models rely assumptions, CJS model makes exception.Statistical models rely assumptions, CJS model makes exception.Blabla.Blabla.","code":""},{"path":"survival.html","id":"suggested-reading","chapter":"1 Survival","heading":"1.10 Suggested reading","text":"bit history CJS model people involved developements S.T. Buckland (2016).bit history CJS model people involved developements S.T. Buckland (2016).Mettre papier Vlad et Morten pour temps, et mon papier Oikos pour individu.Mettre papier Vlad et Morten pour temps, et mon papier Oikos pour individu.CJS state-space formulation Gimenez et al. (2007) Royle (2008).CJS state-space formulation Gimenez et al. (2007) Royle (2008).Also read Lebreton et al. 1992, long monography, gem, w/ introduction AIC, model assumptions, etc.Also read Lebreton et al. 1992, long monography, gem, w/ introduction AIC, model assumptions, etc.WAIC, video https://www.youtube.com/watch?v=vSjL2Zc-gEQ R. McElreath. Cite relevant papers particular paper Gelman et al. 2014 Understanding predictive information criteria Bayesian models.WAIC, video https://www.youtube.com/watch?v=vSjL2Zc-gEQ R. McElreath. Cite relevant papers particular paper Gelman et al. 2014 Understanding predictive information criteria Bayesian models.Work missing values Bonner et al. (2006) Langrock King (2013) Worthington et al. (2015).Work missing values Bonner et al. (2006) Langrock King (2013) Worthington et al. (2015).example incorporate prior information McCarthy Masters (2005).example incorporate prior information McCarthy Masters (2005).posterior predictive check, see paper Chambert https://doi.org/10.1002/ece3.993, Conn https://doi.org/10.1002/ecm.1314.posterior predictive check, see paper Chambert https://doi.org/10.1002/ece3.993, Conn https://doi.org/10.1002/ecm.1314.Combine live recapture w/ dead recoveries Lebreton et al. (1999) go spatial account emigration Gilroy et al. (2012) Schaub & Royle (2014).Combine live recapture w/ dead recoveries Lebreton et al. (1999) go spatial account emigration Gilroy et al. (2012) Schaub & Royle (2014).Non-identifiability Bayesian framework, see Gimenez et al. (2009) book Cole (2020).Non-identifiability Bayesian framework, see Gimenez et al. (2009) book Cole (2020).","code":""},{"path":"introduction-3.html","id":"introduction-3","chapter":"Introduction","heading":"Introduction","text":"","code":""},{"path":"introduction-4.html","id":"introduction-4","chapter":"Introduction","heading":"Introduction","text":"","code":""},{"path":"take-home-messages.html","id":"take-home-messages","chapter":"Take-home messages","heading":"Take-home messages","text":"–>\n –>–>–>–>","code":""},{"path":"references.html","id":"references","chapter":"References","heading":"References","text":"","code":""}]
