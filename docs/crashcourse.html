<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Chapter 1 Bayesian statistics &amp; MCMC | Bayesian analysis of capture-recapture data with hidden Markov models</title>
<meta name="author" content="Olivier Gimenez">
<meta name="description" content="1.1 Introduction In this first chapter, you will learn what the Bayesian theory is, and how you may use it with a simple example. You will also see how to implement simulation algorithms to...">
<meta name="generator" content="bookdown 0.43 with bs4_book()">
<meta property="og:title" content="Chapter 1 Bayesian statistics &amp; MCMC | Bayesian analysis of capture-recapture data with hidden Markov models">
<meta property="og:type" content="book">
<meta property="og:url" content="https://oliviergimenez.github.io/banana-book/crashcourse.html">
<meta property="og:description" content="1.1 Introduction In this first chapter, you will learn what the Bayesian theory is, and how you may use it with a simple example. You will also see how to implement simulation algorithms to...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter 1 Bayesian statistics &amp; MCMC | Bayesian analysis of capture-recapture data with hidden Markov models">
<meta name="twitter:description" content="1.1 Introduction In this first chapter, you will learn what the Bayesian theory is, and how you may use it with a simple example. You will also see how to implement simulation algorithms to...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.9.0/transition.js"></script><script src="libs/bs3compat-0.9.0/tabs.js"></script><script src="libs/bs3compat-0.9.0/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<style type="text/css">
    /* Used with Pandoc 2.11+ new --citeproc when CSL is used */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
          margin-bottom: 0em;
        }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
<link rel="stylesheet" href="bs4_style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="Theory and case studies in R and NIMBLE">Bayesian analysis of capture-recapture data with hidden Markov models</a>:
        <small class="text-muted">Theory and case studies in R and NIMBLE</small>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Welcome</a></li>
<li><a class="" href="preface.html">Preface</a></li>
<li class="book-part">Foundations</li>
<li><a class="" href="introduction.html">Introduction</a></li>
<li><a class="active" href="crashcourse.html"><span class="header-section-number">1</span> Bayesian statistics &amp; MCMC</a></li>
<li><a class="" href="intronimble.html"><span class="header-section-number">2</span> NIMBLE tutorial</a></li>
<li><a class="" href="hmmcapturerecapture.html"><span class="header-section-number">3</span> Hidden Markov models</a></li>
<li class="book-part">Transitions</li>
<li><a class="" href="introduction-4.html">Introduction</a></li>
<li><a class="" href="survival.html"><span class="header-section-number">4</span> Alive and dead</a></li>
<li><a class="" href="dispersal.html"><span class="header-section-number">5</span> Sites and states</a></li>
<li class="book-part">Case studies</li>
<li><a class="" href="introduction-7.html">Introduction</a></li>
<li><a class="" href="covariateschapter.html"><span class="header-section-number">6</span> Dealing with covariates</a></li>
<li><a class="" href="lackoffit.html"><span class="header-section-number">7</span> Addressing model lack of fit</a></li>
<li><a class="" href="tradeoffs.html"><span class="header-section-number">8</span> Quantifying life history traits</a></li>
<li><a class="" href="conclusion.html">Conclusion</a></li>
<li><a class="" href="references.html">References</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/oliviergimenez/banana-book">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="crashcourse" class="section level1" number="1">
<h1>
<span class="header-section-number">1</span> Bayesian statistics &amp; MCMC<a class="anchor" aria-label="anchor" href="#crashcourse"><i class="fas fa-link"></i></a>
</h1>
<div id="introduction-1" class="section level2" number="1.1">
<h2>
<span class="header-section-number">1.1</span> Introduction<a class="anchor" aria-label="anchor" href="#introduction-1"><i class="fas fa-link"></i></a>
</h2>
<p>In this first chapter, you will learn what the Bayesian theory is, and how you may use it with a simple example. You will also see how to implement simulation algorithms to implement the Bayesian method for more complex analyses. This is not an exhaustive treatment of Bayesian statistics, but you should get what you need to navigate through the rest of the book.</p>
</div>
<div id="bayes-theorem" class="section level2" number="1.2">
<h2>
<span class="header-section-number">1.2</span> Bayes’ theorem<a class="anchor" aria-label="anchor" href="#bayes-theorem"><i class="fas fa-link"></i></a>
</h2>
<p>Let’s not wait any longer and jump into it. Bayesian statistics relies on the Bayes’ theorem (or law, or rule, whatever you prefer) named after Reverend Thomas Bayes (Figure <a href="crashcourse.html#fig:revbayes">1.1</a>). This theorem was published in 1763 two years after Bayes’ death thanks to his friend’s efforts Richard Price, and was independently discovered by Pierre-Simon Laplace <span class="citation">(<a href="references.html#ref-mcgrayne2011">McGrayne 2011</a>)</span>.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:revbayes"></span>
<img src="images/amazing-thomas-bayes-illustration.jpg" alt="Cartoon of Thomas Bayes with Bayes' theorem in background. Source: James Kulich at &lt;https://www.elmhurst.edu/blog/thomas-bayes/&gt;" width="100%"><p class="caption">
Figure 1.1: Cartoon of Thomas Bayes with Bayes’ theorem in background. Source: James Kulich at <a href="https://www.elmhurst.edu/blog/thomas-bayes/" class="uri">https://www.elmhurst.edu/blog/thomas-bayes/</a>
</p>
</div>
<p>As we will see in a minute, Bayes’ theorem is all about conditional probabilities, which are somehow tricky to understand. Conditional probability of outcome or event A given event B, which we denote <span class="math inline">\(\Pr(A \mid B)\)</span>, is the probability that A occurs, revised by considering the additional information that event B has occurred. For example, a friend of yours rolls a fair dice and asks you the probability that the outcome was a six (event A). Your answer is 1/6 because each side of the dice is equally likely to come up. Now imagine that you’re told the number rolled was even (event B) before you answer your friend’s question. Because there are only three even numbers, one of which is six, you may revise your answer for the probability that a six was rolled from 1/6 to <span class="math inline">\(\Pr(A \mid B) = 1/3\)</span>. The order in which A and B appear is important, make sure you do not confuse <span class="math inline">\(\Pr(A \mid B)\)</span> and <span class="math inline">\(\Pr(B \mid A)\)</span>.</p>
<p>Bayes’ theorem gives you <span class="math inline">\(\Pr(A \mid B)\)</span> using marginal probabilities <span class="math inline">\(\Pr(A)\)</span> and <span class="math inline">\(\Pr(B)\)</span> and <span class="math inline">\(\Pr(B \mid A)\)</span>:</p>
<p><span class="math display">\[\Pr(A \mid B) = \displaystyle{\frac{ \Pr(B \mid A) \; \Pr(A)}{\Pr(B)}}.\]</span></p>
<p>Originally, Bayes’ theorem was seen as a way to infer an unkown cause A of a particular effect B, knowing the probability of effect B given cause A. Think for example of a situation where a medical diagnosis is needed, with A an unknown disease and B symptoms, the doctor knows Pr(symptoms|disease) and wants to derive Pr(disease|symptoms). This way of reversing <span class="math inline">\(\Pr(B \mid A)\)</span> into <span class="math inline">\(\Pr(A \mid B)\)</span> explains why Bayesian thinking used to be referred to as ‘inverse probability’.</p>
<!-- ```{r bayestheorem, echo = FALSE, fig.align="center", fig.cap = "Bayes' theorem spelt out in blue neon. Source: https://en.wikipedia.org/wiki/Bayes%27_theorem.", out.width="60%"} -->
<!-- knitr::include_graphics("images/bayes_neon.jpeg") -->
<!-- ``` -->
<p>I don’t know about you, but I need to think twice for not messing the letters around. I find it easier to remember Bayes’ theorem written like this:</p>
<p><span class="math display">\[\Pr(\text{hypothesis} \mid \text{data}) = \frac{ \Pr(\text{data} \mid \text{hypothesis}) \; \Pr(\text{hypothesis})}{\Pr(\text{data})}\]</span></p>
<div class="blackbox">
<p>The <em>hypothesis</em> is a working assumption about which you want to learn using <em>data</em>. In capture–recapture analyses, the hypothesis might be a parameter like detection probability, or regression parameters in a relationship between survival probability and a covariate (see Chapter <a href="survival.html#survival">4</a>). Bayes’ theorem tells us how to obtain the probability of a hypothesis given the data we have.</p>
</div>
<p>This is great because think about it, this is exactly what the scientific method is! We’d like to know how plausible some hypothesis is based on some data we collected, and possibly compare several hypotheses among them. In that respect, the Bayesian reasoning matches the scientific reasoning, which probably explains why the Bayesian framework is so natural for doing and understanding statistics.</p>
<p>You might ask then, why is Bayesian statistics not the default in statistics? Until recently, there were practical problems to implement Bayes’ theorem. Recent advances in computational power coupled with the development of new algorithms have led to a great increase in the application of Bayesian methods within the last three decades.</p>
<!-- Clearly, because of futile wars between male statisticians (including Ronald Fisher, Jerzy Neyman and Egon Sharpe Pearson among others), little progress was made for over two centuries. Also,  -->
</div>
<div id="what-is-the-bayesian-approach" class="section level2" number="1.3">
<h2>
<span class="header-section-number">1.3</span> What is the Bayesian approach?<a class="anchor" aria-label="anchor" href="#what-is-the-bayesian-approach"><i class="fas fa-link"></i></a>
</h2>
<p>Typical statistical problems involve estimating a parameter (or several parameters) <span class="math inline">\(\theta\)</span> with available data. To do so, you might be more used to the frequentist rather than the Bayesian method. The frequentist approach, and in particular maximum likelihood estimation (MLE), assumes that the parameters are fixed, and have unknown values to be estimated. Therefore classical estimates are generally point estimates of the parameters of interest. In contrast, the Bayesian approach assumes that the parameters are not fixed, and have some unknown distribution. A probability distribution is a mathematical expression that gives the probability for a random variable to take particular values. It may be either discrete (e.g., the Bernoulli, Binomial or Poisson distribution) or continuous (e.g., the Gaussian distribution also known as the normal distribution).</p>
<p>The Bayesian approach is based upon the idea that you, as an experimenter, begin with some prior beliefs about the system. Then you collect data and update your prior beliefs on the basis of observations. These observations might arise from field work, lab work or from expertise of your esteemed colleagues. This updating process is based upon Bayes’ theorem. Loosely, let’s say <span class="math inline">\(A = \theta\)</span> and <span class="math inline">\(B = \text{data}\)</span>, then Bayes’ theorem gives you a way to estimate parameter <span class="math inline">\(\theta\)</span> given the data you have:</p>
<p><span class="math display">\[{\color{red}{\Pr(\theta \mid \text{data})}} = \frac{\color{blue}{\Pr(\text{data} \mid \theta)} \times \color{green}{\Pr(\theta)}}{\color{orange}{\Pr(\text{data})}}.\]</span>
Let’s spend some time going through each quantity in this formula.</p>
<p>On the left-hand side is <span class="math inline">\(\color{red}{\Pr(\theta \mid \text{data})}\)</span> the <span class="math inline">\(\color{red}{\text{posterior distribution}}\)</span>. It represents what you know after having seen the data. This is the basis for inference and clearly what you’re after, a distribution, possibly multivariate if you have more than one parameter.</p>
<p>On the right-hand side, there is <span class="math inline">\(\color{blue}{\Pr(\text{data} \mid \theta)}\)</span> the <span class="math inline">\(\color{blue}{\text{likelihood}}\)</span>. This quantity is the same as in the MLE approach. Yes, the Bayesian and frequentist approaches have the same likelihood at their core, which mostly explains why results often do not differ much. The likelihood captures the information you have in your data, given a model parameterized with <span class="math inline">\(\theta\)</span>.</p>
<p>Then we have <span class="math inline">\(\color{green}{\Pr(\theta)}\)</span> the <span class="math inline">\(\color{green}{\text{prior distribution}}\)</span>. This quantity represents what you know before seeing the data. This is the source of much discussion about the Bayesian approach. It may be vague if you don’t know anything about <span class="math inline">\(\theta\)</span>. Usually however, you never start from scratch, and you’d like your prior to reflect the information you have (see Section <a href="survival.html#elicitprior">4.9</a> for how to accomplish that).</p>
<p>Last, we have <span class="math inline">\(\color{orange}{\Pr(\text{data})}\)</span> which is sometimes called the average likelihood because it is obtained by integrating the likelihood with respect to the prior <span class="math inline">\(\color{orange}{\Pr(\text{data}) = \int{\Pr(\text{data} \mid \theta)\Pr(\theta) d\theta}}\)</span> so that the posterior is standardized, that is it integrates to one for the posterior to be a distribution. The average likelihood is an integral with dimension the number of parameters <span class="math inline">\(\theta\)</span> you need to estimate. This quantity is difficult, if not impossible, to calculate in general. This is one of the reasons why the Bayesian method wasn’t used until recently, and why we need algorithms to estimate posterior distributions as I illustrate in the next section.</p>
</div>
<div id="numerical-approx" class="section level2" number="1.4">
<h2>
<span class="header-section-number">1.4</span> Approximating posteriors via numerical integration<a class="anchor" aria-label="anchor" href="#numerical-approx"><i class="fas fa-link"></i></a>
</h2>
<p>Let’s take an example to illustrate Bayes’ theorem. Say we capture, mark and release <span class="math inline">\(n = 57\)</span> animals at the beginning of a winter, out of which we recapture <span class="math inline">\(y = 19\)</span> animals alive <span class="citation">(we used a similar example in <a href="references.html#ref-king_bayesian_2009">King et al. 2009</a>)</span>. We’d like to estimate winter survival <span class="math inline">\(\theta\)</span>. The data are:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fl">19</span> <span class="co"># nb of success</span></span>
<span><span class="va">n</span> <span class="op">&lt;-</span> <span class="fl">57</span> <span class="co"># nb of attempts</span></span></code></pre></div>
<p>We build our model first. Assuming all animals are independent of each other and have the same survival probability, then <span class="math inline">\(y\)</span> the number of alive animals at the end of the winter is a binomial distribution with <span class="math inline">\(n\)</span> trials and <span class="math inline">\(\theta\)</span> the probability of success:</p>
<p><span class="math display">\[\begin{align*}
y &amp;\sim \text{Binomial}(n, \theta) &amp;\text{[likelihood]}
\end{align*}\]</span></p>
<p>Note that I follow <span class="citation">McElreath (<a href="references.html#ref-mcelreathbook">2020</a>)</span> and use labels on the right to help remember what each line is about. This likelihood can be visualised in <code>R</code>:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">grid</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">0.01</span><span class="op">)</span> <span class="co"># grid of values for survival</span></span>
<span><span class="va">likelihood</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">dbinom</a></span><span class="op">(</span><span class="va">y</span>, <span class="va">n</span>, <span class="va">grid</span><span class="op">)</span> <span class="co"># compute binomial likelihood</span></span>
<span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>survival <span class="op">=</span> <span class="va">grid</span>, likelihood <span class="op">=</span> <span class="va">likelihood</span><span class="op">)</span> </span>
<span><span class="va">df</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">ggplot</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">survival</span>, y <span class="op">=</span> <span class="va">likelihood</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">geom_line</span><span class="op">(</span>linewidth <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="banana-book_files/figure-html/unnamed-chunk-11-1.png" width="672"></div>
<p>This is the binomial likelihood with <span class="math inline">\(n = 57\)</span> released animals and <span class="math inline">\(y = 19\)</span> survivors after winter. The value of survival (on the x-axis) that corresponds to the maximum of the likelihood function (on the y-axis) is the MLE, or the proportion of success in this example, close to 0.33.</p>
<p>Besides the likelihood, priors are another component of the model in the Bayesian approach. For a parameter that is a probability, the one thing we know is that the prior should be a continuous random variable that lies between 0 and 1. To reflect that, we often go for the uniform distribution <span class="math inline">\(U(0,1)\)</span> to imply <em>vague</em> priors. Here vague means that survival has, before we see the data, the same probability of falling between 0.1 and 0.2 and between 0.8 and 0.9, for example.</p>
<p><span class="math display">\[\begin{align*}
\theta &amp;\sim \text{Uniform}(0, 1) &amp;\text{[prior for }\theta \text{]}
\end{align*}\]</span></p>
<p>Now we apply Bayes’ theorem. We write a <code>R</code> function that computes the product of the likelihood times the prior, or the numerator in Bayes’ theorem: <span class="math inline">\(\Pr(\text{data} \mid \theta) \times \Pr(\theta)\)</span></p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">numerator</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">theta</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">dbinom</a></span><span class="op">(</span><span class="va">y</span>, <span class="va">n</span>, <span class="va">theta</span><span class="op">)</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">dunif</a></span><span class="op">(</span><span class="va">theta</span>, <span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>We write another function that calculates the denominator, the average likelihood: <span class="math inline">\(\Pr(\text{data}) = \int{\Pr(\text{data} \mid \theta) \Pr(\theta) d\theta}\)</span></p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">denominator</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/integrate.html">integrate</a></span><span class="op">(</span><span class="va">numerator</span>,<span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span><span class="op">$</span><span class="va">value</span></span></code></pre></div>
<p>We use the <code>R</code> function <code>integrate</code> to calculate the integral in the denominator, which implements quadrature techniques to divide in little squares the area underneath the curve delimited by the function to integrate (here the numerator), and count them.</p>
<p>Then we get a numerical approximation of the posterior of winter survival by applying Bayes’ theorem:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">grid</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">0.01</span><span class="op">)</span> <span class="co"># grid of values for theta</span></span>
<span><span class="va">numerical_posterior</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>survival <span class="op">=</span> <span class="va">grid</span>, </span>
<span>                                  posterior <span class="op">=</span> <span class="fu">numerator</span><span class="op">(</span><span class="va">grid</span><span class="op">)</span><span class="op">/</span><span class="va">denominator</span><span class="op">)</span> <span class="co"># Bayes' theorem</span></span>
<span><span class="va">numerical_posterior</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">ggplot</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">survival</span>, y <span class="op">=</span> <span class="va">posterior</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">geom_line</span><span class="op">(</span>linewidth <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="banana-book_files/figure-html/unnamed-chunk-15-1.png" width="672"></div>
<p>How good is our numerical approximation of survival posterior distribution? Ideally, we would want to compare the approximation to the true posterior distribution. Although a closed-form expression for the posterior distribution is in general intractable, when you combine a binomial likelihood together with a beta distribution as a prior, then the posterior distribution is also a beta distribution, which makes it amenable to all sorts of exact calculations. We say that the beta distribution is the conjugate prior distribution for the binomial distribution. The beta distribution is continuous between 0 and 1, and extends the uniform distribution to situations where not all outcomes are equally likely. It has two parameters <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> that control its shape (Figure <a href="crashcourse.html#fig:betadistribution">1.2</a>).</p>

<div class="figure">
<span style="display:block;" id="fig:betadistribution"></span>
<img src="banana-book_files/figure-html/betadistribution-1.png" alt="The distribution beta(\(a\),\(b\)) for different values of \(a\) and \(b\). Note that for \(a = b = 1\), we get the uniform distribution between 0 and 1 in the top left panel. When \(a\) and \(b\) are equal, the distribution is symmetric, and the bigger \(a\) and \(b\), the more peaked the distribution around the mean (the smaller the variance). The expectation (or mean) of a beta(\(a\),\(b\)) is \(\displaystyle{\frac{a}{a + b}}\)." width="672"><p class="caption">
Figure 1.2: The distribution beta(<span class="math inline">\(a\)</span>,<span class="math inline">\(b\)</span>) for different values of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. Note that for <span class="math inline">\(a = b = 1\)</span>, we get the uniform distribution between 0 and 1 in the top left panel. When <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are equal, the distribution is symmetric, and the bigger <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, the more peaked the distribution around the mean (the smaller the variance). The expectation (or mean) of a beta(<span class="math inline">\(a\)</span>,<span class="math inline">\(b\)</span>) is <span class="math inline">\(\displaystyle{\frac{a}{a + b}}\)</span>.
</p>
</div>
<p>If the likelihood of the data <span class="math inline">\(y\)</span> is binomial with <span class="math inline">\(n\)</span> trials and probability of success <span class="math inline">\(\theta\)</span>, and the prior is a beta distribution with parameters <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, then the posterior is a beta distribution with parameters <span class="math inline">\(a + y\)</span> and <span class="math inline">\(b + n - y\)</span>. In our example, we have <span class="math inline">\(n = 57\)</span> trials and <span class="math inline">\(y = 19\)</span> animals that survived and a uniform prior between 0 and 1 or a beta distribution with parameters <span class="math inline">\(a = b = 1\)</span>, therefore survival has a beta posterior distribution with parameters 20 and 39. Let’s superimpose the exact posterior and the numerical approximation:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">explicit_posterior</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Beta.html">dbeta</a></span><span class="op">(</span><span class="va">grid</span>, <span class="va">y</span> <span class="op">+</span> <span class="va">a</span>, <span class="va">n</span> <span class="op">-</span> <span class="va">y</span> <span class="op">+</span> <span class="va">b</span><span class="op">)</span></span>
<span><span class="va">dfexpposterior</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>survival <span class="op">=</span> <span class="va">grid</span>, explicit_posterior <span class="op">=</span> <span class="va">explicit_posterior</span><span class="op">)</span></span>
<span><span class="fu">ggplot</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">geom_line</span><span class="op">(</span>data <span class="op">=</span> <span class="va">numerical_posterior</span>, </span>
<span>            <span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">survival</span>, y <span class="op">=</span> <span class="va">posterior</span><span class="op">)</span>, </span>
<span>            size <span class="op">=</span> <span class="fl">1.5</span>, </span>
<span>            col <span class="op">=</span> <span class="fu">wesanderson</span><span class="fu">::</span><span class="va"><a href="https://rdrr.io/pkg/wesanderson/man/wes_palettes.html">wes_palettes</a></span><span class="op">$</span><span class="va">Royal1</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>,</span>
<span>            alpha <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">geom_line</span><span class="op">(</span>data <span class="op">=</span> <span class="va">dfexpposterior</span>, </span>
<span>            <span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">survival</span>, y <span class="op">=</span> <span class="va">explicit_posterior</span><span class="op">)</span>,</span>
<span>            size <span class="op">=</span> <span class="fl">1.5</span>, </span>
<span>            col <span class="op">=</span> <span class="fu">wesanderson</span><span class="fu">::</span><span class="va"><a href="https://rdrr.io/pkg/wesanderson/man/wes_palettes.html">wes_palettes</a></span><span class="op">$</span><span class="va">Royal1</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span>, </span>
<span>            linetype <span class="op">=</span> <span class="st">"dashed"</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="banana-book_files/figure-html/unnamed-chunk-16-1.png" width="672"></div>
<p>Clearly, the exact (dashed line) vs. numerical approximation (continuous line) of winter survival posterior distribution are indistinguishable, suggesting that the numerical approximation is more than fine.</p>
<!-- To finish up, let's add the prior.  -->
<!-- ```{r, echo = FALSE} -->
<!-- ggplot() +  -->
<!--   geom_line(data = numerical_posterior,  -->
<!--             aes(x = survival, y = posterior),  -->
<!--             size = 1.5,  -->
<!--             col = wesanderson::wes_palettes$Royal1[2],  -->
<!--             alpha = 0.5) +  -->
<!--   geom_line(data = dfexpposterior,  -->
<!--             aes(x = survival, y = explicit_posterior), -->
<!--             col = wesanderson::wes_palettes$Royal1[3],  -->
<!--             size = 1.5,  -->
<!--             linetype = "dashed") +  -->
<!--   geom_line(data = dfprior, -->
<!--             aes(x = survival, y = prior), -->
<!--             col = wesanderson::wes_palettes$Royal1[1], -->
<!--             size = 1.5) -->
<!-- ``` -->
<p>In our example, we have a single parameter to estimate, winter survival. This means dealing with a one-dimensional integral in the denominator which is pretty easy with quadrature techniques and the <code>R</code> function <code><a href="https://rdrr.io/r/stats/integrate.html">integrate()</a></code>. Now what if we had multiple parameters? For example, imagine you’d like to fit a capture-recapture model with detection probability <span class="math inline">\(p\)</span> and regression parameters <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> for the intercept and slope of a relationship between survival probability and a covariate, then Bayes’ theorem gives you the posterior distribution of all three parameters together:</p>
<p><span class="math display">\[ \Pr(\alpha, \beta, p \mid \text{data}) = \frac{ \Pr(\text{data} \mid \alpha, \beta, p) \times \Pr(\alpha, \beta, p)}{\iiint \, \Pr(\text{data} \mid \alpha, \beta, p) \Pr(\alpha, \beta, p) d\alpha d\beta dp} \]</span>
There are two computational challenges with this formula. First, do we really wish to calculate a three-dimensional integral? The answer is no, one-dimensional and two-dimensional integrals are so much further we can go with standard methods. Second, we’re more interested in a posterior distribution for each parameter separately than the joint posterior distribution. The so-called marginal distribution of <span class="math inline">\(p\)</span> for example is obtained by integrating over all the other parameters – a two-dimensional integral in this example. Now imagine with tens or hundreds of parameters to estimate, these integrals become highly multi-dimensional and simply intractable. In the next section, I introduce powerful simulation methods to circumvent this issue.</p>
</div>
<div id="markov-chain-monte-carlo-mcmc" class="section level2" number="1.5">
<h2>
<span class="header-section-number">1.5</span> Markov chain Monte Carlo (MCMC)<a class="anchor" aria-label="anchor" href="#markov-chain-monte-carlo-mcmc"><i class="fas fa-link"></i></a>
</h2>
<p>In the early 1990s, statisticians rediscovered work from the 1950’s in physics. In a famous paper that would lay the fundations of modern Bayesian statistics (Figure <a href="crashcourse.html#fig:mcmcpaper">1.3</a>), the authors use simulations to approximate posterior distributions with some precision by drawing large samples. This is a neat trick to avoid explicit calculation of the multi-dimensional integrals we struggle with when using Bayes’ theorem.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:mcmcpaper"></span>
<img src="images/metropolis.png" alt="MCMC article cover. Source: The Journal of Chemical Physics -- https://aip.scitation.org/doi/10.1063/1.1699114" width="100%"><p class="caption">
Figure 1.3: MCMC article cover. Source: The Journal of Chemical Physics – <a href="https://aip.scitation.org/doi/10.1063/1.1699114" class="uri">https://aip.scitation.org/doi/10.1063/1.1699114</a>
</p>
</div>
<p>These simulation algorithms are called Markov chain Monte Carlo (MCMC), and they definitely gave a boost to Bayesian statistics. There are two parts in MCMC, Markov chain and Monte Carlo, let’s try and make sense of these terms.</p>
<div id="monte-carlo-integration" class="section level3" number="1.5.1">
<h3>
<span class="header-section-number">1.5.1</span> Monte Carlo integration<a class="anchor" aria-label="anchor" href="#monte-carlo-integration"><i class="fas fa-link"></i></a>
</h3>
<p>What does Monte Carlo stand for? Monte Carlo integration is a simulation technique to calculate integrals of any function <span class="math inline">\(f\)</span> of random variable <span class="math inline">\(X\)</span> with distribution <span class="math inline">\(\Pr(X)\)</span> say <span class="math inline">\(\int f(X) \Pr(X)dX\)</span>. You draw values <span class="math inline">\(X_1,\ldots,X_k\)</span> from <span class="math inline">\(\Pr(X)\)</span> the distribution of <span class="math inline">\(X\)</span>, apply function <span class="math inline">\(f\)</span> to these values, then calculate the mean of these new values <span class="math inline">\(\displaystyle{\frac{1}{k}}\sum_{i=1}^k{f(X_i)}\)</span> to approximate the integral. How is Monte Carlo integration used in a Bayesian context? The posterior distribution contains all the information we need about the parameter to be estimated. When dealing with many parameters however, you may want to summarise posterior results by calculating numerical summaries. The simplest numerical summary is the mean of the posterior distribution, <span class="math inline">\(E(\theta) = \int \theta \Pr(\theta|\text{data})\)</span>, where <span class="math inline">\(X\)</span> is <span class="math inline">\(\theta\)</span> now and <span class="math inline">\(f\)</span> is the identity function. Posterior mean can be calculated with Monte Carlo integration:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sample_from_posterior</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Beta.html">rbeta</a></span><span class="op">(</span><span class="fl">1000</span>, <span class="fl">20</span>, <span class="fl">39</span><span class="op">)</span> <span class="co"># draw 1000 values from posterior survival beta(20,39)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">sample_from_posterior</span><span class="op">)</span> <span class="co"># compute mean with Monte Carlo integration</span></span>
<span><span class="co">## [1] 0.3421</span></span></code></pre></div>
<p>You may check that the mean we have just calculated matches closely the expectation of a beta distribution:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fl">20</span><span class="op">/</span><span class="op">(</span><span class="fl">20</span><span class="op">+</span><span class="fl">39</span><span class="op">)</span> <span class="co"># expectation of beta(20,39)</span></span>
<span><span class="co">## [1] 0.339</span></span></code></pre></div>
<p>Another useful numerical summary is the credible interval within which our parameter falls with some probability, usually 0.95 hence a 95<span class="math inline">\(\%\)</span> credible interval. Finding the bounds of a credible interval requires calculating quantiles, which in turn involves integrals and the use of Monte Carlo integration. A 95<span class="math inline">\(\%\)</span> credible interval for winter survival can be obtained in <code>R</code> with:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/quantile.html">quantile</a></span><span class="op">(</span><span class="va">sample_from_posterior</span>, probs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2.5</span><span class="op">/</span><span class="fl">100</span>, <span class="fl">97.5</span><span class="op">/</span><span class="fl">100</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">##   2.5%  97.5% </span></span>
<span><span class="co">## 0.2190 0.4802</span></span></code></pre></div>
</div>
<div id="markovmodelmcmc" class="section level3" number="1.5.2">
<h3>
<span class="header-section-number">1.5.2</span> Markov chains<a class="anchor" aria-label="anchor" href="#markovmodelmcmc"><i class="fas fa-link"></i></a>
</h3>
<p>What is a Markov chain? A Markov chain is a random sequence of numbers, in which each number depends only on the previous number. An example is the weather in my home town in Southern France, Montpellier, in which a sunny day is most likely to be followed by another sunny day, say with probability 0.8, and a rainy day is rarely followed by another rainy day, say with probability 0.1. The dynamic of this Markov chain is captured by the transition matrix <span class="math inline">\(\mathbf{\Gamma}\)</span>:
<span class="math display">\[
\begin{matrix}
&amp; \\
\mathbf{\Gamma} =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    \text{sunny tomorrow} &amp; \text{rainy tomorrow} \\
0.8 &amp; 0.2 \\
0.9 &amp; 0.1 \\
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
&amp; \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
    \begin{matrix}
    \text{sunny today} \\ \text{rainy today}
    \end{matrix}
\end{matrix}
\]</span>
In rows the weather today, and in columns the weather tomorrow. The cells give the probability of a sunny or rainy day tomorrow, given the day is sunny or rainy today. Under certain conditions, a Markov chain will converge to a unique stationary distribution. In our weather example, let’s run the Markov chain for 20 steps:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">weather</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.8</span>, <span class="fl">0.2</span>, <span class="fl">0.9</span>, <span class="fl">0.1</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, byrow <span class="op">=</span> <span class="cn">T</span><span class="op">)</span> <span class="co"># transition matrix</span></span>
<span><span class="va">steps</span> <span class="op">&lt;-</span> <span class="fl">20</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">steps</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">weather</span> <span class="op">&lt;-</span> <span class="va">weather</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="va">weather</span> <span class="co"># matrix multiplication</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">weather</span>, <span class="fl">2</span><span class="op">)</span> <span class="co"># matrix product after 20 steps</span></span>
<span><span class="co">##      [,1] [,2]</span></span>
<span><span class="co">## [1,] 0.82 0.18</span></span>
<span><span class="co">## [2,] 0.82 0.18</span></span></code></pre></div>
<p>Each row of the transition matrix converges to the same distribution <span class="math inline">\((0.82, 0.18)\)</span> as the number of steps increases. Convergence happens no matter which state you start in, and you always have probability 0.82 of the day being sunny and 0.18 of the day being rainy.</p>
<p>Back to MCMC, the core idea is that you can build a Markov chain with a given stationary distribution set to be the desired posterior distribution.</p>
<div class="blackbox">
<p>Putting Monte Carlo and Markov chains together, MCMC allows us to generate a sample of values (Markov chain) whose distribution converges to the posterior distribution, and we can use this sample of values to calculate any posterior summaries (Monte Carlo), such as posterior means and credible intervals.</p>
</div>
</div>
<div id="metropolis-algorithm" class="section level3" number="1.5.3">
<h3>
<span class="header-section-number">1.5.3</span> Metropolis algorithm<a class="anchor" aria-label="anchor" href="#metropolis-algorithm"><i class="fas fa-link"></i></a>
</h3>
<p>There are several ways of constructing Markov chains for Bayesian inference. You might have heard about the Metropolis-Hastings or the Gibbs sampler. Have a look to <a href="https://chi-feng.github.io/mcmc-demo/" class="uri">https://chi-feng.github.io/mcmc-demo/</a> for an interactive gallery of MCMC algorithms. Here I illustrate the Metropolis algorithm and how to implement it in practice.</p>
<p>Let’s go back to our example on animal survival estimation. We illustrate sampling from survival posterior distribution. We write functions for likelihood, prior and posterior:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 19 animals recaptured alive out of 57 captured, marked and released</span></span>
<span><span class="va">survived</span> <span class="op">&lt;-</span> <span class="fl">19</span></span>
<span><span class="va">released</span> <span class="op">&lt;-</span> <span class="fl">57</span></span>
<span></span>
<span><span class="co"># binomial log-likelihood function</span></span>
<span><span class="va">loglikelihood</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">p</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">dbinom</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">x</span>, size <span class="op">=</span> <span class="va">released</span>, prob <span class="op">=</span> <span class="va">p</span>, log <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># uniform prior density</span></span>
<span><span class="va">logprior</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">p</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">dunif</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">p</span>, min <span class="op">=</span> <span class="fl">0</span>, max <span class="op">=</span> <span class="fl">1</span>, log <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># posterior density function (log scale)</span></span>
<span><span class="va">posterior</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">p</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu">loglikelihood</span><span class="op">(</span><span class="va">x</span>, <span class="va">p</span><span class="op">)</span> <span class="op">+</span> <span class="fu">logprior</span><span class="op">(</span><span class="va">p</span><span class="op">)</span> <span class="co"># - log(Pr(data))</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>The Metropolis algorithm works as follows:</p>
<ol style="list-style-type: decimal">
<li><p>We pick a value of the parameter to be estimated. This is where we start our Markov chain – this is a <em>starting</em> value, or a starting location.</p></li>
<li><p>To decide where to go next, we propose to move away from the current value of the parameter – this is a <em>candidate</em> value. To do so, we add to the current value some random value from e.g. a normal distribution with some variance – this is a <em>proposal</em> distribution. The Metropolis algorithm is a particular case of the Metropolis-Hastings algorithm with symmetric proposals.</p></li>
<li><p>We compute the ratio of the probabilities at the candidate and current locations <span class="math inline">\(R=\displaystyle{\frac{{\Pr(\text{candidate}|\text{data})}}{{\Pr(\text{current}|\text{data})}}}\)</span>. This is where the magic of MCMC happens, in that <span class="math inline">\(\Pr(\text{data})\)</span>, the denominator in the Bayes’ theorem, appears in both the numerator and the denominator in <span class="math inline">\(R\)</span> therefore cancels out and does not need to be calculated.</p></li>
</ol>
<!-- -- *the Hastings ratio* --><ol start="4" style="list-style-type: decimal">
<li><p>If the posterior at the candidate location <span class="math inline">\(\Pr(\text{candidate}|\text{data})\)</span> is higher than at the current location <span class="math inline">\(\Pr(\text{current}|\text{data})\)</span>, in other words when the candidate value is more plausible than the current value, we definitely accept the candidate value. If not, then we accept the candidate value with probability <span class="math inline">\(R\)</span> and reject with probability <span class="math inline">\(1-R\)</span>. For example, if the candidate value is ten times less plausible than the current value, then we accept with probability 0.1 and reject with probability 0.9. How does it work in practice? We use a continuous spinner that lands somewhere between 0 and 1 – call the random spin <span class="math inline">\(X\)</span>. If <span class="math inline">\(X\)</span> is smaller than <span class="math inline">\(R\)</span>, we move to the candidate location, otherwise we remain at the current location. We do not want to accept or reject too often. In practice, the Metropolis algorithm should have an acceptance probability between 0.2 and 0.4, which can be achieved by <em>tuning</em> the variance of the normal proposal distribution.</p></li>
<li><p>We repeat 2-4 a number of times – or <em>steps</em>.</p></li>
</ol>
<p>Enough of the theory, let’s implement the Metropolis algorithm in <code>R</code>. Let’s start by setting the scene:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">steps</span> <span class="op">&lt;-</span> <span class="fl">100</span> <span class="co"># number of steps</span></span>
<span><span class="va">theta.post</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="va">steps</span><span class="op">)</span> <span class="co"># vector to store samples</span></span>
<span><span class="va">accept</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="va">steps</span><span class="op">)</span> <span class="co"># keep track of accept/reject</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span> <span class="co"># for reproducibility</span></span></code></pre></div>
<p>Now follow the 5 steps we’ve just described. First, we pick a starting value, and store it (step 1):</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">inits</span> <span class="op">&lt;-</span> <span class="fl">0.5</span></span>
<span><span class="va">theta.post</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">inits</span></span>
<span><span class="va">accept</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span></span></code></pre></div>
<p>Then, we need a function to propose a candidate value:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">move</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">away</span> <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">{</span> <span class="co"># by default, standard deviation of the proposal distribution is 1</span></span>
<span>  <span class="va">logitx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">x</span> <span class="op">/</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">x</span><span class="op">)</span><span class="op">)</span> <span class="co"># apply logit transform (-infinity,+infinity)</span></span>
<span>  <span class="va">logit_candidate</span> <span class="op">&lt;-</span> <span class="va">logitx</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="va">away</span><span class="op">)</span> <span class="co"># add a value taken from N(0,sd=away) to current value</span></span>
<span>  <span class="va">candidate</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Logistic.html">plogis</a></span><span class="op">(</span><span class="va">logit_candidate</span><span class="op">)</span> <span class="co"># back-transform (0,1)</span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">candidate</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>We add a value taken from a normal distribution with mean zero and standard deviation we call <em>away</em>. We work on the logit scale to make sure the candidate value for survival lies between 0 and 1.</p>
<p>Now we’re ready for steps 2, 3 and 4. We write a loop to take care of step 5. We start at initial value 0.5 and run the algorithm for 100 steps or iterations:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw">for</span> <span class="op">(</span><span class="va">t</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="va">steps</span><span class="op">)</span><span class="op">{</span> <span class="co"># repeat steps 2-4 (step 5)</span></span>
<span>  </span>
<span>  <span class="co"># propose candidate value for survival (step 2)</span></span>
<span>  <span class="va">theta_star</span> <span class="op">&lt;-</span> <span class="fu">move</span><span class="op">(</span><span class="va">theta.post</span><span class="op">[</span><span class="va">t</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># calculate ratio R (step 3)</span></span>
<span>  <span class="va">pstar</span> <span class="op">&lt;-</span> <span class="fu">posterior</span><span class="op">(</span><span class="va">survived</span>, p <span class="op">=</span> <span class="va">theta_star</span><span class="op">)</span>  </span>
<span>  <span class="va">pprev</span> <span class="op">&lt;-</span> <span class="fu">posterior</span><span class="op">(</span><span class="va">survived</span>, p <span class="op">=</span> <span class="va">theta.post</span><span class="op">[</span><span class="va">t</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="va">logR</span> <span class="op">&lt;-</span> <span class="va">pstar</span> <span class="op">-</span> <span class="va">pprev</span> <span class="co"># likelihood and prior are on the log scale</span></span>
<span>  <span class="va">R</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">logR</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># accept candidate value or keep current value (step 4)</span></span>
<span>  <span class="va">X</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span> <span class="co"># spin continuous spinner</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="va">X</span> <span class="op">&lt;</span> <span class="va">R</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">theta.post</span><span class="op">[</span><span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">theta_star</span> <span class="co"># accept candidate value</span></span>
<span>    <span class="va">accept</span><span class="op">[</span><span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="co"># accept</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="kw">else</span><span class="op">{</span></span>
<span>    <span class="va">theta.post</span><span class="op">[</span><span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">theta.post</span><span class="op">[</span><span class="va">t</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="co"># keep current value</span></span>
<span>    <span class="va">accept</span><span class="op">[</span><span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span> <span class="co"># reject</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>We get the following values:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">theta.post</span><span class="op">)</span> <span class="co"># first values</span></span>
<span><span class="co">## [1] 0.5000 0.2302 0.2906 0.2906 0.2980 0.2980</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">tail</a></span><span class="op">(</span><span class="va">theta.post</span><span class="op">)</span> <span class="co"># last values</span></span>
<span><span class="co">## [1] 0.2622 0.2622 0.2622 0.3727 0.3232 0.3862</span></span></code></pre></div>
<p>Visually, you may look at the chain:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">steps</span>, y <span class="op">=</span> <span class="va">theta.post</span><span class="op">)</span></span>
<span><span class="va">df</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">ggplot</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_line</span><span class="op">(</span><span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">x</span>, y <span class="op">=</span> <span class="va">y</span><span class="op">)</span>, size <span class="op">=</span> <span class="fl">1.5</span>, color <span class="op">=</span> <span class="fu">wesanderson</span><span class="fu">::</span><span class="va"><a href="https://rdrr.io/pkg/wesanderson/man/wes_palettes.html">wes_palettes</a></span><span class="op">$</span><span class="va">Zissou1</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">labs</span><span class="op">(</span>x <span class="op">=</span> <span class="st">"iterations"</span>, y <span class="op">=</span> <span class="st">"samples"</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">ylim</span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">0.6</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="banana-book_files/figure-html/chain-1.png" width="672"></div>
<p>In this visualisation, remember that our Markov chain starts at value 0.5. The steps or iterations are on the x-axis, and samples on the y-axis. This graphical representation is called a trace plot.</p>
<p>The acceptance probability is the average number of times we accepted a candidate value, which is 0.44 and almost satisfying.</p>
<p>To make our life easier and avoid repeating the same lines of code again and again, let’s make a function out of the code we have written so far:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">metropolis</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">steps</span> <span class="op">=</span> <span class="fl">100</span>, <span class="va">inits</span> <span class="op">=</span> <span class="fl">0.5</span>, <span class="va">away</span> <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">{</span></span>
<span>  </span>
<span>  <span class="co"># pre-alloc memory</span></span>
<span>  <span class="va">theta.post</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="va">steps</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># start</span></span>
<span>  <span class="va">theta.post</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">inits</span></span>
<span>  </span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">t</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="va">steps</span><span class="op">)</span><span class="op">{</span></span>
<span>    </span>
<span>    <span class="co"># propose candidate value for prob of success</span></span>
<span>    <span class="va">theta_star</span> <span class="op">&lt;-</span> <span class="fu">move</span><span class="op">(</span><span class="va">theta.post</span><span class="op">[</span><span class="va">t</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span>, away <span class="op">=</span> <span class="va">away</span><span class="op">)</span></span>
<span>    </span>
<span>    <span class="co"># calculate ratio R</span></span>
<span>    <span class="va">pstar</span> <span class="op">&lt;-</span> <span class="fu">posterior</span><span class="op">(</span><span class="va">survived</span>, p <span class="op">=</span> <span class="va">theta_star</span><span class="op">)</span>  </span>
<span>    <span class="va">pprev</span> <span class="op">&lt;-</span> <span class="fu">posterior</span><span class="op">(</span><span class="va">survived</span>, p <span class="op">=</span> <span class="va">theta.post</span><span class="op">[</span><span class="va">t</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span></span>
<span>    <span class="va">logR</span> <span class="op">&lt;-</span> <span class="va">pstar</span> <span class="op">-</span> <span class="va">pprev</span></span>
<span>    <span class="va">R</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">logR</span><span class="op">)</span></span>
<span>    </span>
<span>    <span class="co"># accept candidate value or keep current value (step 4)</span></span>
<span>    <span class="va">X</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span> <span class="co"># spin continuous spinner</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="va">X</span> <span class="op">&lt;</span> <span class="va">R</span><span class="op">)</span><span class="op">{</span></span>
<span>      <span class="va">theta.post</span><span class="op">[</span><span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">theta_star</span></span>
<span>    <span class="op">}</span></span>
<span>    <span class="kw">else</span><span class="op">{</span></span>
<span>      <span class="va">theta.post</span><span class="op">[</span><span class="va">t</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">theta.post</span><span class="op">[</span><span class="va">t</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span></span>
<span>    <span class="op">}</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="va">theta.post</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Can we run another chain and start at initial value 0.2 this time? Yes, just go through the same algorithm again, and visualise the results with trace plot of survival for two chains starting at 0.2 (yellow) and 0.5 (blue) run for 100 steps:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">theta.post2</span> <span class="op">&lt;-</span> <span class="fu">metropolis</span><span class="op">(</span>steps <span class="op">=</span> <span class="fl">100</span>, inits <span class="op">=</span> <span class="fl">0.2</span><span class="op">)</span></span>
<span><span class="va">df2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">steps</span>, y <span class="op">=</span> <span class="va">theta.post2</span><span class="op">)</span></span>
<span><span class="fu">ggplot</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_line</span><span class="op">(</span>data <span class="op">=</span> <span class="va">df</span>, <span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">x</span>, y <span class="op">=</span> <span class="va">y</span><span class="op">)</span>, size <span class="op">=</span> <span class="fl">1.5</span>, color <span class="op">=</span> <span class="fu">wesanderson</span><span class="fu">::</span><span class="va"><a href="https://rdrr.io/pkg/wesanderson/man/wes_palettes.html">wes_palettes</a></span><span class="op">$</span><span class="va">Zissou1</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">geom_line</span><span class="op">(</span>data <span class="op">=</span> <span class="va">df2</span>, <span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">x</span>, y <span class="op">=</span> <span class="va">y</span><span class="op">)</span>, size <span class="op">=</span> <span class="fl">1.5</span>, color <span class="op">=</span> <span class="fu">wesanderson</span><span class="fu">::</span><span class="va"><a href="https://rdrr.io/pkg/wesanderson/man/wes_palettes.html">wes_palettes</a></span><span class="op">$</span><span class="va">Zissou1</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">labs</span><span class="op">(</span>x <span class="op">=</span> <span class="st">"iterations"</span>, y <span class="op">=</span> <span class="st">"values from posterior distribution"</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">ylim</span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">0.6</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="banana-book_files/figure-html/twochains-1.png" width="672"></div>
<p>Notice that we do not get the exact same results because the algorithm is stochastic. The question is to know whether we have reached the stationary distribution. Let’s increase the number of steps, start at 0.5 and run a chain with 5000 iterations:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">steps</span> <span class="op">&lt;-</span> <span class="fl">5000</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span></span>
<span><span class="va">theta.post</span> <span class="op">&lt;-</span> <span class="fu">metropolis</span><span class="op">(</span>steps <span class="op">=</span> <span class="va">steps</span>, inits <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span>
<span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">steps</span>, y <span class="op">=</span> <span class="va">theta.post</span><span class="op">)</span></span>
<span><span class="va">df</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">ggplot</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_line</span><span class="op">(</span><span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">x</span>, y <span class="op">=</span> <span class="va">y</span><span class="op">)</span>, size <span class="op">=</span> <span class="fl">1</span>, color <span class="op">=</span> <span class="fu">wesanderson</span><span class="fu">::</span><span class="va"><a href="https://rdrr.io/pkg/wesanderson/man/wes_palettes.html">wes_palettes</a></span><span class="op">$</span><span class="va">Zissou1</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">labs</span><span class="op">(</span>x <span class="op">=</span> <span class="st">"iterations"</span>, y <span class="op">=</span> <span class="st">"values from posterior distribution"</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">ylim</span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">0.6</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">geom_hline</span><span class="op">(</span><span class="fu">aes</span><span class="op">(</span>yintercept <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">theta.post</span><span class="op">)</span>, linetype <span class="op">=</span> <span class="st">"posterior mean"</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">scale_linetype_manual</span><span class="op">(</span>name <span class="op">=</span> <span class="st">""</span>, values <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span> </span></code></pre></div>
<div class="inline-figure"><img src="banana-book_files/figure-html/longchain-1.png" width="672"></div>
<p>This is what we’re after, a trace plot that looks like a beautiful lawn, see Section <a href="crashcourse.html#convergence-diag">1.6</a>.</p>
<!-- I find it informative to look at the animated version of the figure above, it helps understanding the stochastic behavior of the algorithm, and also to realise how the chains converge to their stationary distribution, see Figure \@ref(fig:animlongchain). -->
<!-- ```{r echo = FALSE, eval = FALSE} -->
<!-- # load packages -->
<!-- library(tidyverse) -->
<!-- theme_set(theme_light(base_size = 16)) -->
<!-- library(gganimate) -->
<!-- library(magick) -->
<!-- # deer data, 19 "success" out of 57 "attempts" -->
<!-- survived <- 19 -->
<!-- released <- 57 -->
<!-- #---------- apply Metropolis -->
<!-- steps <- 1000 -->
<!-- chain1 <- metropolis(steps = steps, inits = 0.2) -->
<!-- chain2 <- metropolis(steps = steps, inits = 0.5) -->
<!-- chain3 <- metropolis(steps = steps, inits = 0.7) -->
<!-- df <- data.frame(iter = rep(1:steps, 3),  -->
<!--                  value = c(chain1, chain2, chain3), -->
<!--                  chain = c(rep("chain1", steps),  -->
<!--                            rep("chain2", steps),  -->
<!--                            rep("chain3", steps))) -->
<!-- #---------- time series -->
<!-- static_tsplot <- df %>% -->
<!--   mutate(posterior_mean = mean(value)) %>% -->
<!--   ggplot(aes(x = iter, y = value, group = chain, color = chain)) + -->
<!--   geom_line(size = 1, alpha = 0.5) +  -->
<!--   geom_hline(aes(yintercept = posterior_mean, linetype = "posterior mean")) +  -->
<!--   scale_linetype_manual(name = "", values = c(2,2)) +  -->
<!--   labs(color = "", x = "iterations", y = "survival") -->
<!-- static_tsplot   -->
<!-- # animate -->
<!-- animated_tsplot <- static_tsplot + -->
<!--   transition_reveal(along = iter,  -->
<!--                     range = as.integer(c(1, max(df$iter) + 50))) # trick to pause -->
<!-- animated_tsplot   -->
<!-- # save -->
<!-- a_gif <- animate(animated_tsplot, -->
<!--                  width = 6,  -->
<!--                  height = 3, -->
<!--                  res = 600, -->
<!--                  units = "in") -->
<!-- # get file in directory str(a_gif) -->
<!-- ``` -->
<!-- ```{r animlongchain, echo = FALSE, out.width="100%", fig.align='center', fig.cap = "Animated trace plot of survival with three chains starting at 0.2, 0.5 and 0.7 run for 1000 steps."} -->
<!-- knitr::include_graphics("images/traceplotMCMC.gif") -->
<!-- ``` -->
<p>Once the stationary distribution is reached, you may regard the realisations of the Markov chain as a sample from the posterior distribution, and obtain numerical summaries. In the next section, we consider several important implementation issues.</p>
</div>
</div>
<div id="convergence-diag" class="section level2" number="1.6">
<h2>
<span class="header-section-number">1.6</span> Assessing convergence<a class="anchor" aria-label="anchor" href="#convergence-diag"><i class="fas fa-link"></i></a>
</h2>
<div class="blackbox">
<p>When implementing MCMC, we need to determine how long it takes for our Markov chain to converge to the target distribution, and the number of iterations we need after achieving convergence to get reasonable Monte Carlo estimates of numerical summaries (posterior means and credible intervals).</p>
</div>
<div id="burn-in" class="section level3" number="1.6.1">
<h3>
<span class="header-section-number">1.6.1</span> Burn-in<a class="anchor" aria-label="anchor" href="#burn-in"><i class="fas fa-link"></i></a>
</h3>
<p>In practice, we discard observations from the start of the Markov chain and just use observations from the chain once it has converged. The initial observations that we discard are usually referred to as the <em>burn-in</em>.</p>
<p>The simplest method to determine the length of the burn-in period is to look at trace plots. Going back to our example, let’s have a look to a trace plot of a chain that starts at value 0.99.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># set up the scene</span></span>
<span><span class="va">steps</span> <span class="op">&lt;-</span> <span class="fl">1000</span></span>
<span><span class="va">theta.post</span> <span class="op">&lt;-</span> <span class="fu">metropolis</span><span class="op">(</span>steps <span class="op">=</span> <span class="va">steps</span>, inits <span class="op">=</span> <span class="fl">0.99</span><span class="op">)</span></span>
<span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">steps</span>, y <span class="op">=</span> <span class="va">theta.post</span><span class="op">)</span></span>
<span><span class="va">df</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">ggplot</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_line</span><span class="op">(</span><span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">x</span>, y <span class="op">=</span> <span class="va">y</span><span class="op">)</span>, size <span class="op">=</span> <span class="fl">1.2</span>, color <span class="op">=</span> <span class="fu">wesanderson</span><span class="fu">::</span><span class="va"><a href="https://rdrr.io/pkg/wesanderson/man/wes_palettes.html">wes_palettes</a></span><span class="op">$</span><span class="va">Zissou1</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">labs</span><span class="op">(</span>x <span class="op">=</span> <span class="st">"iterations"</span>, y <span class="op">=</span> <span class="st">"survival"</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">theme_light</span><span class="op">(</span>base_size <span class="op">=</span> <span class="fl">14</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">annotate</span><span class="op">(</span><span class="st">"rect"</span>, </span>
<span>           xmin <span class="op">=</span> <span class="fl">0</span>, </span>
<span>           xmax <span class="op">=</span> <span class="fl">100</span>, </span>
<span>           ymin <span class="op">=</span> <span class="fl">0.1</span>, </span>
<span>           ymax <span class="op">=</span> <span class="fl">1</span>, </span>
<span>           alpha <span class="op">=</span> <span class="fl">.3</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">scale_y_continuous</span><span class="op">(</span>expand <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="banana-book_files/figure-html/burnin-1.png" width="672"></div>
<p>The chain starts at value 0.99 and rapidly stabilises, with values bouncing back and forth around 0.3 from the 100th iteration onwards. You may choose the shaded area as the burn-in, and discard the first 100th values.</p>
<p>We see from the trace plot below that we need at least 100 iterations to achieve convergence toward an average survival around 0.3. It is always better to be conservative when specifying the length of the burn-in period, and in this example, we would use 250 or even 500 iterations as a burn-in. The length of the burn-in period can be determined by performing preliminary MCMC short runs.</p>
<p>Inspecting the trace plot for a single run of the Markov chain is useful. However, we usually run the Markov chain several times, starting from different over-dispersed points, to check that all runs achieve the same stationary distribution. This approach is formalised by using the Brooks-Gelman-Rubin (BGR) statistic <span class="math inline">\(\hat{R}\)</span> which measures the ratio of the total variability combining multiple chains (between-chain plus within-chain) to the within-chain variability. The BGR statistic asks whether there is a chain effect, and is very much alike the <span class="math inline">\(F\)</span> test in an analysis of variance. Values below 1.1 indicate likely convergence.</p>
<p>Back to our example, we run two Markov chains with starting values 0.2 and 0.8 using 100 up to 5000 iterations, and calculate the BGR statistic using half the number of iterations as the length of the burn-in (code not shown):</p>
<div class="inline-figure"><img src="banana-book_files/figure-html/bgr-1.png" width="672"></div>
<p>We get a value of the BGR statistic near 1 by up to 2000 iterations, which suggests that with 2000 iterations as a burn-in, there is no evidence of a lack of convergence.</p>
<p>It is important to bear in mind that a value near 1 for the BGR statistic is only a necessary <em>but not sufficient</em> condition for convergence. In other words, this diagnostic cannot tell you for sure that the Markov chain has achieved convergence, only that it has not.</p>
</div>
<div id="chain-length" class="section level3" number="1.6.2">
<h3>
<span class="header-section-number">1.6.2</span> Chain length<a class="anchor" aria-label="anchor" href="#chain-length"><i class="fas fa-link"></i></a>
</h3>
<p>How long of a chain is needed to produce reliable parameter estimates? To answer this question, you need to keep in mind that successive steps in a Markov chain are not independent – this is usually referred to as <em>autocorrelation</em>. Ideally, we would like to keep autocorrelation as low as possible. Here again, trace plots are useful to diagnose issues with autocorrelation. Let’s get back to our survival example. The figure below shows trace plots for different values of the standard deviation (parameter <em>away</em>) of the normal proposal distribution we use to propose a candidate value (Section <a href="crashcourse.html#metropolis-algorithm">1.5.3</a>):</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># inspired from https://bookdown.org/content/3686/markov-chain-monte-carlo.html</span></span>
<span></span>
<span><span class="va">n_steps</span> <span class="op">&lt;-</span> <span class="fl">10000</span></span>
<span></span>
<span><span class="va">d</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu">tibble</span><span class="op">(</span>away <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">1</span>, <span class="fl">10</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span> </span>
<span>  <span class="fu">mutate</span><span class="op">(</span>accepted_traj <span class="op">=</span> <span class="fu">map</span><span class="op">(</span><span class="va">away</span>, <span class="va">metropolis</span>, steps <span class="op">=</span> <span class="va">n_steps</span>, inits <span class="op">=</span> <span class="fl">0.1</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span> </span>
<span>  <span class="fu">unnest</span><span class="op">(</span><span class="va">accepted_traj</span><span class="op">)</span></span>
<span></span>
<span><span class="va">d</span> <span class="op">&lt;-</span></span>
<span>  <span class="va">d</span> <span class="op">%&gt;%</span> </span>
<span>  <span class="fu">mutate</span><span class="op">(</span>proposal_sd <span class="op">=</span> <span class="fu">str_c</span><span class="op">(</span><span class="st">"Proposal SD = "</span>, <span class="va">away</span><span class="op">)</span>,</span>
<span>         iter        <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">n_steps</span>, times <span class="op">=</span> <span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">trace</span> <span class="op">&lt;-</span> <span class="va">d</span> <span class="op">%&gt;%</span> </span>
<span>  <span class="fu">ggplot</span><span class="op">(</span><span class="fu">aes</span><span class="op">(</span>y <span class="op">=</span> <span class="va">accepted_traj</span>, x <span class="op">=</span> <span class="va">iter</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_path</span><span class="op">(</span>size <span class="op">=</span> <span class="fl">1</span><span class="op">/</span><span class="fl">4</span>, color <span class="op">=</span> <span class="st">"steelblue"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_point</span><span class="op">(</span>size <span class="op">=</span> <span class="fl">1</span><span class="op">/</span><span class="fl">2</span>, alpha <span class="op">=</span> <span class="fl">1</span><span class="op">/</span><span class="fl">2</span>, color <span class="op">=</span> <span class="st">"steelblue"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">scale_y_continuous</span><span class="op">(</span><span class="st">"survival"</span>, breaks <span class="op">=</span> <span class="fl">0</span><span class="op">:</span><span class="fl">5</span> <span class="op">*</span> <span class="fl">0.1</span>, limits <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.15</span>, <span class="fl">0.5</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">scale_x_continuous</span><span class="op">(</span><span class="st">"iterations"</span>, </span>
<span>                     breaks <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="va">n_steps</span><span class="op">-</span><span class="va">n_steps</span><span class="op">*</span><span class="fl">10</span><span class="op">/</span><span class="fl">100</span>,<span class="va">n_steps</span>,by <span class="op">=</span> <span class="fl">600</span><span class="op">)</span>, </span>
<span>                     limits <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">n_steps</span><span class="op">-</span><span class="va">n_steps</span><span class="op">*</span><span class="fl">10</span><span class="op">/</span><span class="fl">100</span>, <span class="va">n_steps</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">facet_wrap</span><span class="op">(</span><span class="op">~</span><span class="va">proposal_sd</span>, ncol <span class="op">=</span> <span class="fl">3</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">theme_light</span><span class="op">(</span>base_size <span class="op">=</span> <span class="fl">14</span><span class="op">)</span></span>
<span></span>
<span><span class="va">trace</span></span></code></pre></div>
<div class="inline-figure"><img src="banana-book_files/figure-html/unnamed-chunk-30-1.png" width="672"></div>
<p>Small and big moves in the left and right panels provide high correlations between successive observations of the Markov chain, whereas a standard deviation of 1 in the center panel allows efficient exploration of the parameter space. The movement around the parameter space is referred to as <em>mixing</em>. Mixing is bad when the chain makes small and big moves, and good otherwise.</p>
<p>In addition to trace plots, autocorrelation function (ACF) plots are a convenient way of displaying the strength of autocorrelation in a given sample values. ACF plots provide the autocorrelation between successively sampled values separated by an increasing number of iterations, or <em>lag</em>. We obtain the autocorrelation function plots for different values of the standard deviation of the proposal distribution with the R <code><a href="https://pkg.robjhyndman.com/forecast/reference/autoplot.acf.html">forecast::ggAcf()</a></code> function:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://pkg.robjhyndman.com/forecast/">forecast</a></span><span class="op">)</span></span>
<span><span class="va">plot1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://pkg.robjhyndman.com/forecast/reference/autoplot.acf.html">ggAcf</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">d</span><span class="op">$</span><span class="va">accepted_traj</span><span class="op">[</span><span class="va">d</span><span class="op">$</span><span class="va">proposal_sd</span><span class="op">==</span><span class="st">"Proposal SD = 0.1"</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span> <span class="fu">ggtitle</span><span class="op">(</span><span class="st">"Proposal SD = 0.1"</span><span class="op">)</span></span>
<span><span class="va">plot2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://pkg.robjhyndman.com/forecast/reference/autoplot.acf.html">ggAcf</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">d</span><span class="op">$</span><span class="va">accepted_traj</span><span class="op">[</span><span class="va">d</span><span class="op">$</span><span class="va">proposal_sd</span><span class="op">==</span><span class="st">"Proposal SD = 1"</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span> <span class="fu">ggtitle</span><span class="op">(</span><span class="st">"Proposal SD = 1"</span><span class="op">)</span></span>
<span><span class="va">plot3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://pkg.robjhyndman.com/forecast/reference/autoplot.acf.html">ggAcf</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">d</span><span class="op">$</span><span class="va">accepted_traj</span><span class="op">[</span><span class="va">d</span><span class="op">$</span><span class="va">proposal_sd</span><span class="op">==</span><span class="st">"Proposal SD = 10"</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span> <span class="fu">ggtitle</span><span class="op">(</span><span class="st">"Proposal SD = 10"</span><span class="op">)</span></span>
<span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://patchwork.data-imaginist.com">patchwork</a></span><span class="op">)</span></span>
<span><span class="op">(</span><span class="va">plot1</span> <span class="op">+</span> <span class="va">plot2</span> <span class="op">+</span> <span class="va">plot3</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="banana-book_files/figure-html/unnamed-chunk-31-1.png" width="672"></div>
<p>In the left and right panels, autocorrelation is strong, decreases slowly with increasing lag and mixing is bad. In the center panel, autocorrelation is weak, decreases rapidly with increasing lag and mixing is good.</p>
<p>Autocorrelation is not necessarily a big issue. Strongly correlated observations just require large sample sizes and therefore longer simulations. But how many iterations exactly? The effective sample size (<code>n.eff</code>) measures chain length while taking into account chain autocorrelation. You should check the <code>n.eff</code> of every parameter of interest, and of any interesting parameter combinations. In general, we need <span class="math inline">\(\text{n.eff} \geq 400\)</span> independent steps to get reasonable Monte Carlo estimates of model parameters. In the animal survival example, <code>n.eff</code> can be calculated with the R <code><a href="https://rdrr.io/pkg/coda/man/effectiveSize.html">coda::effectiveSize()</a></code> function:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">neff1</span> <span class="op">&lt;-</span> <span class="fu">coda</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/coda/man/effectiveSize.html">effectiveSize</a></span><span class="op">(</span><span class="va">d</span><span class="op">$</span><span class="va">accepted_traj</span><span class="op">[</span><span class="va">d</span><span class="op">$</span><span class="va">proposal_sd</span><span class="op">==</span><span class="st">"Proposal SD = 0.1"</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="va">neff2</span> <span class="op">&lt;-</span> <span class="fu">coda</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/coda/man/effectiveSize.html">effectiveSize</a></span><span class="op">(</span><span class="va">d</span><span class="op">$</span><span class="va">accepted_traj</span><span class="op">[</span><span class="va">d</span><span class="op">$</span><span class="va">proposal_sd</span><span class="op">==</span><span class="st">"Proposal SD = 1"</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="va">neff3</span> <span class="op">&lt;-</span> <span class="fu">coda</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/coda/man/effectiveSize.html">effectiveSize</a></span><span class="op">(</span><span class="va">d</span><span class="op">$</span><span class="va">accepted_traj</span><span class="op">[</span><span class="va">d</span><span class="op">$</span><span class="va">proposal_sd</span><span class="op">==</span><span class="st">"Proposal SD = 10"</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu">tibble</span><span class="op">(</span><span class="st">"Proposal SD"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">1</span>, <span class="fl">10</span><span class="op">)</span>,</span>
<span>             <span class="st">"n.eff"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">neff1</span>, <span class="va">neff2</span>, <span class="va">neff3</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">df</span></span>
<span><span class="co">## # A tibble: 3 × 2</span></span>
<span><span class="co">##   `Proposal SD` n.eff</span></span>
<span><span class="co">##           &lt;dbl&gt; &lt;dbl&gt;</span></span>
<span><span class="co">## 1           0.1   224</span></span>
<span><span class="co">## 2           1    1934</span></span>
<span><span class="co">## 3          10     230</span></span></code></pre></div>
<p>As expected, <code>n.eff</code> is less than the number of MCMC iterations because of autocorrelation. Only when the standard deviation of the proposal distribution is 1 is the mixing good and we get a satisfying effective sample size.</p>
</div>
<div id="what-if-you-have-issues-of-convergence" class="section level3" number="1.6.3">
<h3>
<span class="header-section-number">1.6.3</span> What if you have issues of convergence?<a class="anchor" aria-label="anchor" href="#what-if-you-have-issues-of-convergence"><i class="fas fa-link"></i></a>
</h3>
<p>When diagnosing MCMC convergence, you will (very) often run into troubles. In this section you will find some helpful tips I hope.</p>
<p>When mixing is bad and effective sample size is small, you may just need to increase burn-in and/or sample more. Using more informative priors might also make Markov chains converge faster by helping your MCMC sampler (e.g. the Metropolis algorithm) navigating more efficiently the parameter space. In the same spirit, picking better initial values for starting the chain does not harm. For doing that, a strategy consists in using estimates from a simpler model for which your MCMC chains do converge.</p>
<p>If convergence issues persist, often there is a problem with your model (also known as <em>the folk theorem of statistical computing</em> as stated by Andrew Gelman, see <a href="https://statmodeling.stat.columbia.edu/2008/05/13/the_folk_theore/" class="uri">https://statmodeling.stat.columbia.edu/2008/05/13/the_folk_theore/</a>). A bug in the code? A typo somewhere? A mistake in your maths? As often when coding is involved, the issue can be identified by removing complexities, and start with a simpler model until you find what the problem is.</p>
<p>A general advice is to see your model as a data generating tool in the first place, simulate data from it using some realistic values for the parameters, and try to recover these parameter values by fitting the model to the simulated data. Simulating from a model will help you understanding how it works, what it does not do, and the data you need to get reasonable parameter estimates (e.g. Chapter <a href="hmmcapturerecapture.html#hmmcapturerecapture">3</a> and Section <a href="lackoffit.html#indhet">7.4</a>).</p>
<!-- We will see other strategies to improve convergence in the next chapters. Cross reference relevant chapters. Option 1. Change your sampler. Option 2. Reparameterize (standardize covariates, plus non-centering: $\alpha \sim N(0,\sigma)$ becomes $\alpha = z \sigma$ with $z \sim N(0,1)$). -->
</div>
</div>
<div id="summary" class="section level2" number="1.7">
<h2>
<span class="header-section-number">1.7</span> Summary<a class="anchor" aria-label="anchor" href="#summary"><i class="fas fa-link"></i></a>
</h2>
<ul>
<li><p>With the Bayes’ theorem, you update your beliefs (prior) with new data (likelihood) to get posterior beliefs (posterior): posterior <span class="math inline">\(\propto\)</span> likelihood <span class="math inline">\(\times\)</span> prior.</p></li>
<li><p>The idea of Markov chain Monte Carlo (MCMC) is to simulate values from a Markov chain which has a stationary distribution equal to the posterior distribution you’re after.</p></li>
<li><p>In practice, you run a Markov chain multiple times starting from over-dispersed initial values.</p></li>
<li><p>You discard iterations in an initial burn-in phase and achieve convergence when all chains reach the same regime.</p></li>
<li><p>From there, you run the chains long enough and proceed with calculating Monte Carlo estimates of numerical summaries (e.g. posterior means and credible intervals) for parameters.</p></li>
</ul>
</div>
<div id="suggested-reading" class="section level2" number="1.8">
<h2>
<span class="header-section-number">1.8</span> Suggested reading<a class="anchor" aria-label="anchor" href="#suggested-reading"><i class="fas fa-link"></i></a>
</h2>
<ul>
<li><p><span class="citation">McCarthy (<a href="references.html#ref-mccarthy2007">2007</a>)</span> and <span class="citation">Kéry and Schaub (<a href="references.html#ref-KerySchaub2011">2011</a>)</span> are excellent introductions to Bayesian statistics for ecologists. The forthcoming second edition of the latter will also include NIMBLE code. See also <span class="citation">Kéry and Kellner (<a href="references.html#ref-keryAppliedStatisticalModelling2024">2024</a>)</span>.</p></li>
<li><p>For deeper insights, I recommend <span class="citation">Gelman and Hill (<a href="references.html#ref-gelmanhill2006">2006</a>)</span> which analyse data using the frequentist and Bayesian approaches side-by-side. The book by <span class="citation">McElreath (<a href="references.html#ref-mcelreathbook">2020</a>)</span> is also an excellent read. The presentation of the Metropolis algorithm in Section <a href="crashcourse.html#metropolis-algorithm">1.5.3</a> was inspired by <span class="citation">Albert and Hu (<a href="references.html#ref-alberthu2019">2019</a>)</span>. If you’d like to know more about Monte Carlo methods, the book <span class="citation">Robert and Casella (<a href="references.html#ref-robert2004montecarlo">2004</a>)</span> is a must <span class="citation">(see also its R counterpart <a href="references.html#ref-robert2004montecarloinr">Robert and Casella 2010</a>)</span>. See also <span class="citation">Vehtari et al. (<a href="references.html#ref-vehtariRankNormalizationFoldingLocalization2021">2021</a>)</span> for a discussion on <span class="math inline">\(\hat{R}\)</span> and the effective sample size.</p></li>
<li><p>I also recommend <span class="citation">Gelman et al. (<a href="references.html#ref-gelman2020workflow">2020</a>)</span> in which the authors offer a workflow for Bayesian analyses. They discuss model building, model comparison, model checking, model validation, model understanding and troubleshooting of computational problems.</p></li>
</ul>
</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="introduction.html">Introduction</a></div>
<div class="next"><a href="intronimble.html"><span class="header-section-number">2</span> NIMBLE tutorial</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#crashcourse"><span class="header-section-number">1</span> Bayesian statistics &amp; MCMC</a></li>
<li><a class="nav-link" href="#introduction-1"><span class="header-section-number">1.1</span> Introduction</a></li>
<li><a class="nav-link" href="#bayes-theorem"><span class="header-section-number">1.2</span> Bayes’ theorem</a></li>
<li><a class="nav-link" href="#what-is-the-bayesian-approach"><span class="header-section-number">1.3</span> What is the Bayesian approach?</a></li>
<li><a class="nav-link" href="#numerical-approx"><span class="header-section-number">1.4</span> Approximating posteriors via numerical integration</a></li>
<li>
<a class="nav-link" href="#markov-chain-monte-carlo-mcmc"><span class="header-section-number">1.5</span> Markov chain Monte Carlo (MCMC)</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#monte-carlo-integration"><span class="header-section-number">1.5.1</span> Monte Carlo integration</a></li>
<li><a class="nav-link" href="#markovmodelmcmc"><span class="header-section-number">1.5.2</span> Markov chains</a></li>
<li><a class="nav-link" href="#metropolis-algorithm"><span class="header-section-number">1.5.3</span> Metropolis algorithm</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#convergence-diag"><span class="header-section-number">1.6</span> Assessing convergence</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#burn-in"><span class="header-section-number">1.6.1</span> Burn-in</a></li>
<li><a class="nav-link" href="#chain-length"><span class="header-section-number">1.6.2</span> Chain length</a></li>
<li><a class="nav-link" href="#what-if-you-have-issues-of-convergence"><span class="header-section-number">1.6.3</span> What if you have issues of convergence?</a></li>
</ul>
</li>
<li><a class="nav-link" href="#summary"><span class="header-section-number">1.7</span> Summary</a></li>
<li><a class="nav-link" href="#suggested-reading"><span class="header-section-number">1.8</span> Suggested reading</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/oliviergimenez/banana-book/blob/master/1-bayesmcmc.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/oliviergimenez/banana-book/edit/master/1-bayesmcmc.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Bayesian analysis of capture-recapture data with hidden Markov models</strong>: Theory and case studies in R and NIMBLE" was written by Olivier Gimenez. It was last built on 2025-08-18.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
