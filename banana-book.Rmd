---
title: "Bayesian analysis of capture-recapture data with hidden Markov models"
subtitle: "Theory and case studies in R and NIMBLE"
author: "Olivier Gimenez"
date: "`r Sys.Date()`"
params:
  bw: false
documentclass: krantz
bibliography: [book.bib]
#biblio-style: apalike
link-citations: yes
colorlinks: yes
lot: yes
lof: yes
fontsize: 12pt
site: bookdown::bookdown_site
description: "This is a textbook on the analysis of capture-recapture data with hidden Markov models (HMM) implemented in the Bayesian framework with R and NIMBLE."
url: 'https://oliviergimenez.github.io/banana-book/'
github-repo: oliviergimenez/banana-book
header-includes: 
  - \usepackage{tikz}
  - \usepackage{pgfplots}
  - \usepackage{blkarray}
  - \pgfplotsset{compat=1.18} 
  - \usepackage{tcolorbox}
  - \usepackage{arydshln}
  - \newtcolorbox{blackbox}{
    colback=white,
    colframe=purple,
    coltext=black,
    boxsep=5pt,
    arc=4pt}
  - \usepackage{subfig}
  - \usepackage{ragged2e}
  - \usepackage[table]{xcolor}
---
```{r include=FALSE, cache=FALSE}
# packages
library(tidyverse)
theme_set(theme_light(base_size = 14))
library(nimble)
library(MCMCvis)
library(magick)
library(pdftools)
library(wesanderson)
library(RColorBrewer)
library(patchwork)
library(emo)
#library(nimbleEcology)
#library(basicMCMCplots)

# R options
options(width = 60)

# chunk options
knitr::opts_chunk$set(
  comment = "##",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE
  )
```

```{r setup, include=FALSE}
options(
#  htmltools.dir.version = FALSE, 
  formatR.indent = 2,
  width = 55, 
  digits = 4, 
  warnPartialMatchAttr = FALSE, 
  warnPartialMatchDollar = FALSE
)
```

# Welcome {-}

<!-- bookdown::serve_book("index.Rmd") -->
<!-- bookdown::render_book("index.Rmd", "bookdown::pdf_book") -->
<!-- bookdown::render_book("index.Rmd", output_format = "bookdown::pdf_book",  -->
<!--                       params = list(bw = TRUE))   # version N&B -->

Welcome to the online free version of the book *Bayesian analysis of capture-recapture data with hidden Markov models: Theory and case studies in R and NIMBLE*. If you'd like a physical copy of the book, you can order it on [Routledge](https://www.routledge.com/Bayesian-Analysis-of-Capture-Recapture-Data-with-Hidden-Markov-Models-Theory-and-Case-Studies-in-R/Gimenez/p/book/9781032154237) or [Amazon](https://www.amazon.fr/dp/1032154233). 

```{r echo=FALSE, fig.align='center', out.width='100%'}
knitr::include_graphics("cover.png")
```

Here, I write about three of my favorite research topics -- capture-recapture, hidden Markov models and Bayesian statistics -- let's enjoy this great m/cocktail together `r emo::ji("tropical_drink")`

<!-- The book is also available in [PDF format](https://github.com/oliviergimenez/banana-book/blob/master/docs/banana-book.pdf).  -->

I welcome any feedback. You may raise an issue [here](https://github.com/oliviergimenez/banana-book/issues), amend directly the R Markdown file that generated the page you're reading by clicking on the 'Edit this page' icon in the right panel, or [email me](mailto:olivier.gimenez@cefe.cnrs.fr). Many thanks!

Olivier Gimenez. Written in Montpellier, France and Athens, Greece.
Last updated: `r Sys.setlocale("LC_TIME", "C"); format(Sys.Date(), "%B %d, %Y")`

## How to cite {-}

Gimenez, O. 2026. Bayesian analysis of capture-recapture data with hidden Markov models: Theory and case studies in R and NIMBLE. Chapman & Hall/CRC Interdisciplinary Statistics series.

```bibtex
@book{gimenez2026,
  title = {Bayesian Analysis of Capture-Recapture Data with Hidden {{Markov}} Models: {{Theory}} and Case Studies in {{R}} and {{NIMBLE}}},
  author = {Gimenez, Olivier},
  year = {2026},
  publisher = {Chapman & Hall/CRC Interdisciplinary Statistics series}
}
```

## License {-}

The online version of this book is licensed under the [Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License](http://creativecommons.org/licenses/by-nc-nd/4.0/).

The code is public domain, licensed under [Creative Commons CC0 1.0 Universal (CC0 1.0)](https://creativecommons.org/publicdomain/zero/1.0/).


<!--chapter:end:index.Rmd-->

```{r include=FALSE, cache=FALSE}
# packages
library(tidyverse)
theme_set(theme_light(base_size = 14))
library(nimble)
library(MCMCvis)
library(magick)
library(pdftools)
library(wesanderson)
library(RColorBrewer)
library(patchwork)
library(emo)
#library(nimbleEcology)
#library(basicMCMCplots)

# R options
options(width = 60)

# chunk options
knitr::opts_chunk$set(
  comment = "##",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE
  )
```
# Preface {-}

## Why this book? {-}

The hidden Markov modelling (HMM) framework has gained much attention in the ecological literature over the last decade, and has been suggested as a general modelling framework for the demography of plant and animal populations. HMMs are increasingly used to analyse capture-recapture data and estimate key population parameters (e.g., survival, dispersal, or recruitment) with applications in all fields of ecology (check out <https://oliviergimenez.github.io/curated-list-of-HMM-CR-papers/>). The first objective of this book is to illustrate the flexibility of HMM to decompose complex problems in smaller pieces that are easier to understand, model and analyse. 

In parallel, Bayesian statistics is well established and fast expanding in ecology and related disciplines, as it resonates with the scientific reasoning and offers a natural framework for handling uncertainty. The popularity of Bayesian statistics also comes from the availability of free pieces of software (WinBUGS, OpenBUGS, JAGS, Stan) that allow practitioners to code their own analyses. The second objective of this book is to illustrate the use of the R package NIMBLE [@deValpine2017] to analyse capture-recapture data with HMM in a Bayesian framework. NIMBLE is seen by many as the future of Bayesian statistical ecology to deal with complex models. 

An important part of the book consists in case studies from published papers presented in a tutorial style to abide by the “learning by doing” philosophy. The third objective of this book is to provide reproducible analyses with code and data to teach yourself by example. 

## Who should read this book? {-}

This book is aimed at beginners who're comfortable using R and write basic code, as well as connoisseurs of capture-recapture who'd like to tap into the power of the Bayesian side of statistics. For both audiences, thinking in the HMM framework will help you in confidently building models and make the most of your capture-recapture data. 

I won't lie, there is some math in this book. But the equations I use are either simple enough to follow without a strong mathematical background, or they can be skipped without losing the thread. For those with a solid math background, you'll find there isn't much, and most of the derivations (e.g. posterior distributions) are tucked away in the code. I recognize that a certain level of abstraction can be useful, but my target audience is ecologists. I worried that leaning too heavily on formal math would feel like speaking a foreign language, and to be honest, I'm not even sure I could still 'speak math' as fluently as I once did.

## What will you learn? {-}

The book is divided into three parts. The first part `Foundations` is aimed at getting you up-to-speed with Bayesian statistics, NIMBLE, and hidden Markov models. The second part `Transitions` will teach you all about capture-recapture models for open populations, with reproducible R code to ease the learning process. The third part `Case studies` provides real-world case studies from the scientific literature that you can reproduce using material covered in previous chapters. These problems can either i) be used to cement and deepen your understanding of methods and models, ii) be adapted for your own purpose, or iii) serve as teaching projects. The data and code are available at <https://github.com/oliviergimenez/banana-book/tree/master/appendix>. The last chapter closes the book with take-home messages and recommendations.

## What won't you learn? {-}

I do not cover Bayesian statistics or even hidden Markov models exhaustively, I provide just what you need to work with capture-recapture data. If you are interested in knowing more about these topics, hopefully the section `Suggested reading` at the end of each chapter will put you in the right direction. There are also a number of important topics specific to capture-recapture that I do not cover, including closed-population capture-recapture models [@WilliamsEtAl2002], spatial capture-recapture models [@RoyleEtAl2013book], integrated population models [@BesbeasMorgan2019], semi-Markov models [e.g. @choquet_semi-markov_2011] and continuous-time models [@rushing2023continuouscr]. These models can be treated as HMMs, but for now the usual formulation is just fine. These developments will be the subject of new chapters in a second edition, hopefully.

## Prerequisites {-}

This book uses primarily the R package NIMBLE, so you need to install at least R and NIMBLE. A bunch of other R packages are used. You can install them all at once by running:

```{r, echo = FALSE, cache = FALSE}
deps <- desc::desc_get_deps()
pkgs <- sort(deps$package[deps$type == "Imports"])
pkgs2 <- strwrap(paste(encodeString(pkgs, quote = '"'), collapse = ", "), exdent = 2)
install <- paste0(
  "install.packages(c(\n  ", 
  paste(pkgs2, "\n", collapse = ""), 
  "))"
)
```

```{r code = install, eval = FALSE}
```

Besides NIMBLE, I also make frequent use of the tidyverse packages in R and RStudio. For piping, I stick to `%>%` from the magrittr package. Since R 4.1.0, R has its own native pipe `|>`. Most of the code here should work with it too, although I have to admit, I haven't really checked.

## How this book was written {-}

I wrote this book in RStudio <http://www.rstudio.com/ide/> using bookdown <http://bookdown.org/>. The book website <https://oliviergimenez.github.io/banana-book> is hosted with GitHub Pages <https://pages.github.com/>, and automatically updated after every push by Github Actions <https://github.com/features/actions>. The source is available from GitHub <https://github.com/oliviergimenez/banana-book>.

The version of the book you're reading was built with `r R.version.string` and the following packages:

```{r, echo = FALSE, results="asis"}
pkgs <- sessioninfo::package_info(pkgs, dependencies = FALSE)
df <- tibble(
  package = pkgs$package,
  version = pkgs$ondiskversion,
  source = gsub("@", "\\\\@", pkgs$source)
)
knitr::kable(df, format = "markdown")
```

```{r, echo = FALSE}
ruler <- function(width = getOption("width")) {
  x <- seq_len(width)
  y <- dplyr::case_when(
    x %% 10 == 0 ~ as.character((x %/% 10) %% 10),
    x %% 5 == 0  ~ "+",
    TRUE         ~ "-"
  )
  cat(y, "\n", sep = "")
  cat(x %% 10, "\n", sep = "")
}
```

```{r, include = FALSE}
ruler()
```


## About the author {-}

My name is Olivier Gimenez (<https://oliviergimenez.github.io/>). I am a senior (euphemism for not so young anymore) scientist at the National Centre for Scientific Research (CNRS; <https://www.cnrs.fr/en>) in the beautiful city of Montpellier, France.

I struggled studying maths, obtained a PhD in applied statistics a long time ago in a galaxy of wine and cheese. I was awarded my habilitation (<https://en.wikipedia.org/wiki/Habilitation>) in ecology and evolution so that I could stop pretending to understand what my colleagues were talking about. More recently I embarked in sociology studies because hey, why not. 

Lost somewhere at the interface of animal ecology, statistical modeling and social sciences, my so-called expertise lies in population dynamics and species distribution modeling to address questions in ecology and conservation biology about the impact of human activities and the wildlife management. I would be nothing without the students and colleagues who are kind enough to bear with me.

You may find me on BlueSky (https://bsky.app/profile/oaggimenez.bsky.social), LinkedIn (https://www.linkedin.com/in/olivier-gimenez-545451115/), GitHub (https://github.com/oliviergimenez), or get in touch by email at olivier|dot|gimenez|at|cefe|dot|cnrs|dot|fr.

## Acknowledgements {-}

Writing a book is quite an adventure, and a lot of people contributed to make this book a reality. I wish to thank: 

+ Rob Calver, Sherry Thomas, Vaishali Singh and Kumar Shashi at Chapman and Hall/CRC.  
+ Marc Kéry, Rachel McCrea, Byron Morgan and Etienne Prévost for their positive reviews of the book proposal I sent to Chapman and Hall/CRC, and their constructive comments and suggestions.  
+ Marc Kéry for his precious pieces of advice on the process of writing.  
+ Perry de Valpine, Daniel Turek, Chris Paciorek and Ben Goldstein for the `NIMBLE` and `nimbleEcology` R packages.  
+ Colleagues who shared their data; See list at <https://github.com/oliviergimenez/banana-book#readme>
+ People who commented, corrected, offered pieces of advice; See list at <https://github.com/oliviergimenez/banana-book#readme>. 
+ Yihui Xie for the `bookdown` R package. 
+ Attendees of the workshops we run in relation to the content of this book (latest edition was in 2023, see <https://oliviergimenez.github.io/bayesian-hmm-cr-workshop-valencia/>)
+ Perry de Valpine, Sarah Cubaynes, Chloé Nater, Maud Quéroué and Daniel Turek for their help with running workshops in relation to the content of this book (2021 edition: https://oliviergimenez.github.io/bayesian-cr-workshop/; 2022 edition: https://oliviergimenez.github.io/hmm-cr-nimble-isec2022-workshop/).   
+ Ruth King, Steve Brooks and Byron Morgan for the workshop on Bayesian statistics for ecologists we taught in Cambridge, the book we wrote together [@king_bayesian_2009], and their contribution to statistical ecology.  
+ Jean-Dominique Lebreton, Roger Pradel and Rémi Choquet for the workshops on modelling individual histories with state uncertainty we taught over the years, and sharing their science of capture-recapture with me. 
+ My employer the Centre National de la Recherche Scientifique (CNRS) and folks at the Centre d’Écologie Fonctionnelle et Évolutive (CEFE): Being a researcher is a wonderful and meaningful profession, even though academia faces growing challenges with more competition, greater precarity, and fewer permanent positions. I am fortunate to work in a supportive environment at CNRS and CEFE, where people cultivate collaboration and a strong sense of community.
+ My family, including my mother, my parents-in-law for their kindness and hospitality, my amazing kids and wonderful wife for putting up with me while I was writing this book.  


<!--chapter:end:0-preface.Rmd-->

```{r include=FALSE, cache=FALSE}
# packages
library(tidyverse)
theme_set(theme_light(base_size = 14))
library(nimble)
library(MCMCvis)
library(magick)
library(pdftools)
library(wesanderson)
library(RColorBrewer)
library(patchwork)
library(emo)
#library(nimbleEcology)
#library(basicMCMCplots)

# R options
options(width = 60)

# chunk options
knitr::opts_chunk$set(
  comment = "##",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE
  )
```
\mainmatter

# (PART) Foundations {-}

# Introduction {-}

This first part `Foundations` is aimed at getting you up-to-speed with Bayesian statistics, NIMBLE, and hidden Markov models. The code is available at <https://github.com/oliviergimenez/banana-book/tree/master/appendix>. 

<!--chapter:end:introductionpartone.Rmd-->

```{r include=FALSE, cache=FALSE}
# packages
library(tidyverse)
theme_set(theme_light(base_size = 14))
library(nimble)
library(MCMCvis)
library(magick)
library(pdftools)
library(wesanderson)
library(RColorBrewer)
library(patchwork)
library(emo)
#library(nimbleEcology)
#library(basicMCMCplots)

# R options
options(width = 60)

# chunk options
knitr::opts_chunk$set(
  comment = "##",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE
  )
```
# Bayesian statistics & MCMC {#crashcourse}

## Introduction

In this first chapter, you will learn what the Bayesian theory is, and how you may use it with a simple example. You will also see how to implement simulation algorithms to implement the Bayesian method for more complex analyses. This is not an exhaustive treatment of Bayesian statistics, but you should get what you need to navigate through the rest of the book. 

## Bayes' theorem

Let's not wait any longer and jump into it. Bayesian statistics relies on the Bayes' theorem (or law, or rule, whatever you prefer) named after Reverend Thomas Bayes (Figure \@ref(fig:revbayes)). This theorem was published in 1763 two years after Bayes' death thanks to his friend's efforts Richard Price, and was independently discovered by Pierre-Simon Laplace [@mcgrayne2011]. 

```{r revbayes, echo = FALSE, fig.align="center", out.width="100%", fig.cap = "Cartoon of Thomas Bayes with Bayes' theorem in background. Source: James Kulich at <https://www.elmhurst.edu/blog/thomas-bayes/>"}
knitr::include_graphics("images/amazing-thomas-bayes-illustration.jpg")
```

As we will see in a minute, Bayes' theorem is all about conditional probabilities, which are somehow tricky to understand. Conditional probability of outcome or event A given event B, which we denote $\Pr(A \mid B)$, is the probability that A occurs, revised by considering the additional information that event B has occurred. For example, a friend of yours rolls a fair dice and asks you the probability that the outcome was a six (event A). Your answer is 1/6 because each side of the dice is equally likely to come up. Now imagine that you're told the number rolled was even (event B) before you answer your friend's question. Because there are only three even numbers, one of which is six, you may revise your answer for the probability that a six was rolled from 1/6 to $\Pr(A \mid B) = 1/3$. The order in which A and B appear is important, make sure you do not confuse $\Pr(A \mid B)$ and $\Pr(B \mid A)$.

Bayes' theorem gives you $\Pr(A \mid B)$ using marginal probabilities $\Pr(A)$ and $\Pr(B)$ and $\Pr(B \mid A)$:

$$\Pr(A \mid B) = \displaystyle{\frac{ \Pr(B \mid A) \; \Pr(A)}{\Pr(B)}}.$$

We talk about a marginal probability when we are interested in the probability of an event "on its own", without any particular condition. For example, $\Pr(A)$ or $\Pr(B)$ are the overall chances of $A$ or $B$, without taking anything else into account. It is called marginal because, if you built a table with all possible combinations (for instance, dice outcomes classified as even/odd and as "six/not six"), then $\Pr(A)$ and $\Pr(B)$ are obtained by adding up the entries of a row or a column, that is, what you read in the margins of the table.

Originally, Bayes' theorem was seen as a way to infer an unkown cause A of a particular effect B, knowing the probability of effect B given cause A. Think for example of a situation where a medical diagnosis is needed, with A an unknown disease and B symptoms, the doctor knows Pr(symptoms|disease) and wants to derive Pr(disease|symptoms). This way of reversing $\Pr(B \mid A)$ into $\Pr(A \mid B)$ explains why Bayesian thinking used to be referred to as 'inverse probability'. 


<!-- ```{r bayestheorem, echo = FALSE, fig.align="center", fig.cap = "Bayes' theorem spelt out in blue neon. Source: https://en.wikipedia.org/wiki/Bayes%27_theorem.", out.width="60%"} -->
<!-- knitr::include_graphics("images/bayes_neon.jpeg") -->
<!-- ``` -->

I don't know about you, but I need to think twice for not messing the letters around. 

:::: {.blackbox data-latex=""}
I find it easier to remember Bayes' theorem written like this:

$$\Pr(\text{hypothesis} \mid \text{data}) = \frac{ \Pr(\text{data} \mid \text{hypothesis}) \; \Pr(\text{hypothesis})}{\Pr(\text{data})}$$
The *hypothesis* is a working assumption about which you want to learn using *data*. In capture--recapture analyses, the hypothesis might be a parameter like detection probability, or regression parameters in a relationship between survival probability and a covariate (see Chapter \@ref(survival)). Bayes' theorem tells us how to obtain the probability of a hypothesis given the data we have. 
::::

This is great because think about it, this is exactly what the scientific method is! We'd like to know how plausible some hypothesis is based on some data we collected, and possibly compare several hypotheses among them. In that respect, the Bayesian reasoning matches the scientific reasoning, which probably explains why the Bayesian framework is so natural for doing and understanding statistics. 

You might ask then, why is Bayesian statistics not the default in statistics? Until recently, there were practical problems to implement Bayes' theorem. Recent advances in computational power coupled with the development of new algorithms have led to a great increase in the application of Bayesian methods within the last three decades.

<!-- Clearly, because of futile wars between male statisticians (including Ronald Fisher, Jerzy Neyman and Egon Sharpe Pearson among others), little progress was made for over two centuries. Also,  -->

## What is the Bayesian approach?	

Typical statistical problems involve estimating a parameter (or several parameters) $\theta$ with available data. To do so, you might be more used to the frequentist rather than the Bayesian method. The frequentist approach, and in particular maximum likelihood estimation (MLE), assumes that the parameters are fixed, and have unknown values to be estimated. Therefore classical estimates are generally point estimates of the parameters of interest. In contrast, the Bayesian approach assumes that the parameters are not fixed, and have some unknown distribution. A probability distribution is a mathematical expression that gives the probability for a random variable to take particular values. It may be either discrete (e.g., the Bernoulli, Binomial or Poisson distribution) or continuous (e.g., the Gaussian distribution also known as the normal distribution).

The Bayesian approach is based upon the idea that you, as an experimenter, begin with some prior beliefs about the system. Then you collect data and update your prior beliefs on the basis of observations. These observations might arise from field work, lab work or from expertise of your esteemed colleagues. This updating process is based upon Bayes' theorem. Loosely, let's say $A = \theta$ and $B = \text{data}$, then Bayes' theorem gives you a way to estimate parameter $\theta$ given the data you have:

$${\color{red}{\Pr(\theta \mid \text{data})}} = \frac{\color{blue}{\Pr(\text{data} \mid \theta)} \times \color{green}{\Pr(\theta)}}{\color{orange}{\Pr(\text{data})}}.$$
Let's spend some time going through each quantity in this formula. 

On the left-hand side is $\color{red}{\Pr(\theta \mid \text{data})}$ the $\color{red}{\text{posterior distribution}}$. It represents what you know after having seen the data. This is the basis for inference and clearly what you're after, a distribution, possibly multivariate if you have more than one parameter. 

On the right-hand side, there is $\color{blue}{\Pr(\text{data} \mid \theta)}$ the $\color{blue}{\text{likelihood}}$. This quantity is the same as in the MLE approach. Yes, the Bayesian and frequentist approaches have the same likelihood at their core, which mostly explains why results often do not differ much. The likelihood captures the information you have in your data, given a model parameterized with $\theta$. 

Then we have $\color{green}{\Pr(\theta)}$ the $\color{green}{\text{prior distribution}}$. This quantity represents what you know before seeing the data. This is the source of much discussion about the Bayesian approach. It may be vague if you don't know anything about $\theta$. Usually however, you never start from scratch, and you'd like your prior to reflect the information you have (see Section \@ref(elicitprior) for how to accomplish that).

Last, we have $\color{orange}{\Pr(\text{data})}$ which is sometimes called the average likelihood because it is obtained by integrating the likelihood with respect to the prior $\color{orange}{\Pr(\text{data}) = \int{\Pr(\text{data} \mid \theta)\Pr(\theta) d\theta}}$ so that the posterior is standardized, that is it integrates to one for the posterior to be a distribution. The average likelihood is an integral with dimension the number of parameters $\theta$ you need to estimate. This quantity is difficult, if not impossible, to calculate in general. This is one of the reasons why the Bayesian method wasn't used until recently, and why we need algorithms to estimate posterior distributions as I illustrate in the next section.

## Approximating posteriors via numerical integration {#numerical-approx}

Let's take an example to illustrate Bayes' theorem. Say we capture, mark and release $n = 57$ animals at the beginning of a winter, out of which we recapture $y = 19$ animals alive [we used a similar example in @king_bayesian_2009]. We'd like to estimate winter survival $\theta$. The data are:
```{r}
y <- 19 # nb of success
n <- 57 # nb of attempts
```

We build our model first. Assuming all animals are independent of each other and have the same survival probability, then $y$ the number of alive animals at the end of the winter is a binomial distribution with $n$ trials and $\theta$ the probability of success:
  
\begin{align*}
y &\sim \text{Binomial}(n, \theta) &\text{[likelihood]}
\end{align*}

Note that I follow @mcelreathbook and use labels on the right to help remember what each line is about. This likelihood can be visualised in `R`: 
```{r}
grid <- seq(0, 1, 0.01) # grid of values for survival
likelihood <- dbinom(y, n, grid) # compute binomial likelihood
df <- data.frame(survival = grid, likelihood = likelihood) 
df %>%
  ggplot() + 
  aes(x = survival, y = likelihood) + 
  geom_line(linewidth = 1.5)
```

This is the binomial likelihood with $n = 57$ released animals and $y = 19$ survivors after winter. The value of survival (on the x-axis) that corresponds to the maximum of the likelihood function (on the y-axis) is the MLE, or the proportion of success in this example, close to 0.33.

Besides the likelihood, priors are another component of the model in the Bayesian approach. For a parameter that is a probability, the one thing we know is that the prior should be a continuous random variable that lies between 0 and 1. To reflect that, we often go for the uniform distribution $U(0,1)$ to imply *vague* priors. Here vague means that survival has, before we see the data, the same probability of falling between 0.1 and 0.2 and between 0.8 and 0.9, for example. 

\begin{align*}
\theta &\sim \text{Uniform}(0, 1) &\text{[prior for }\theta \text{]}
\end{align*}

```{r, echo = FALSE}
a <- 1; b <- 1; grid <- seq(0,1,0.01); prior <- dbeta(grid,a,b)
dfprior <- data.frame(survival = grid, prior = prior) 
#dfprior %>%
#  ggplot() + 
#  geom_line(aes(x = p, y = prior), 
#            size = 1.5,
#            color = wesanderson::wes_palettes$Royal1[1])
#plot(p, dbeta(p,a,b), type='l', lwd=3)
```

Now we apply Bayes' theorem. We write a `R` function that computes the product of the likelihood times the prior, or the numerator in Bayes' theorem: $\Pr(\text{data} \mid \theta) \times \Pr(\theta)$
```{r}
numerator <- function(theta) dbinom(y, n, theta) * dunif(theta, 0, 1)
```

We write another function that calculates the denominator, the average likelihood: $\Pr(\text{data}) = \int{\Pr(\text{data} \mid \theta) \Pr(\theta) d\theta}$
```{r}
denominator <- integrate(numerator,0,1)$value
```

We use the `R` function `integrate` to calculate the integral in the denominator, which implements quadrature techniques to divide in little squares the area underneath the curve delimited by the function to integrate (here the numerator), and count them.

Then we get a numerical approximation of the posterior of winter survival by applying Bayes' theorem:
```{r}
grid <- seq(0, 1, 0.01) # grid of values for theta
numerical_posterior <- data.frame(survival = grid, 
  posterior = numerator(grid)/denominator) # Bayes' theorem
numerical_posterior %>%
  ggplot() +
  aes(x = survival, y = posterior) + 
  geom_line(linewidth = 1.5)
```

How good is our numerical approximation of survival posterior distribution? Ideally, we would want to compare the approximation to the true posterior distribution. Although a closed-form expression for the posterior distribution is in general intractable, when you combine a binomial likelihood together with a beta distribution as a prior, then the posterior distribution is also a beta distribution, which makes it amenable to all sorts of exact calculations. We say that the beta distribution is the conjugate prior distribution for the binomial distribution. The beta distribution is continuous between 0 and 1, and extends the uniform distribution to situations where not all outcomes are equally likely. It has two parameters $a$ and $b$ that control its shape (Figure \@ref(fig:betadistribution)).

(ref:captionbeta) The distribution beta($a$,$b$) for different values of $a$ and $b$. Note that for $a = b = 1$, we get the uniform distribution between 0 and 1 in the top left panel. When $a$ and $b$ are equal, the distribution is symmetric, and the bigger $a$ and $b$, the more peaked the distribution around the mean (the smaller the variance). The expectation (or mean) of a beta($a$,$b$) is $\displaystyle{\frac{a}{a + b}}$.

```{r betadistribution, echo = FALSE, fig.cap='(ref:captionbeta)'}
x <- seq(0, 1, length=200)
par(mfrow = c(2,3))
# distribution a posteriori beta
plot(x,dbeta(x, 1, 1),type='l',xlab='',ylab='Density',main='beta(1,1)',lwd=3,col='black',ylim=c(0,1.5))
plot(x,dbeta(x, 2, 1),type='l',xlab='',ylab='',main='beta(2,1)',lwd=3,col='black',ylim=c(0,2))
plot(x,dbeta(x, 1, 2),type='l',xlab='',ylab='',main='beta(1,2)',lwd=3,col='black',ylim=c(0,2))
plot(x,dbeta(x, 2, 2),type='l',xlab='',ylab='Density',main='beta(2,2)',lwd=3,col='black',ylim=c(0,1.5))
plot(x,dbeta(x, 10, 10),type='l',xlab='',ylab='',main='beta(10,10)',lwd=3,col='black',ylim=c(0,3.5))
plot(x,dbeta(x, 0.8, 0.8),type='l',xlab='',ylab='',main='beta(0.8,0.8)',lwd=3,col='black',ylim=c(0.5,2.5))
```

If the likelihood of the data $y$ is binomial with $n$ trials and probability of success $\theta$, and the prior is a beta distribution with parameters $a$ and $b$, then the posterior is a beta distribution with parameters $a + y$ and $b + n - y$. In our example, we have $n = 57$ trials and $y = 19$ animals that survived and a uniform prior between 0 and 1 or a beta distribution with parameters $a = b = 1$, therefore survival has a beta posterior distribution with parameters 20 and 39. Let's superimpose the exact posterior and the numerical approximation:
```{r echo = FALSE}
explicit_posterior <- dbeta(grid, y + a, n - y + b)
dfexpposterior <- data.frame(survival = grid, explicit_posterior = explicit_posterior)
if (params$bw) {
  # version noir et blanc
  ggplot() + 
    geom_line(data = numerical_posterior, 
              aes(x = survival, y = posterior), 
              linewidth = 1.5, 
              col = 'grey',
              alpha = 0.5) + 
    geom_line(data = dfexpposterior, 
              aes(x = survival, y = explicit_posterior),
              linewidth = 1.5, 
              col = 'black', 
              linetype = "dashed")
  } else {
                # version couleur
  ggplot() + 
    geom_line(data = numerical_posterior, 
              aes(x = survival, y = posterior), 
              linewidth = 1.5, 
              col = wesanderson::wes_palettes$Royal1[2],
              alpha = 0.5) + 
    geom_line(data = dfexpposterior, 
              aes(x = survival, y = explicit_posterior),
              linewidth = 1.5, 
              col = wesanderson::wes_palettes$Royal1[3], 
              linetype = "dashed")
  }
```

Clearly, the exact (black or brick-red in the online version) vs. numerical approximation (grey or cream in the online version) of winter survival posterior distribution are indistinguishable, suggesting that the numerical approximation is more than fine. 

<!-- To finish up, let's add the prior.  -->
<!-- ```{r, echo = FALSE} -->
<!-- ggplot() +  -->
<!--   geom_line(data = numerical_posterior,  -->
<!--             aes(x = survival, y = posterior),  -->
<!--             size = 1.5,  -->
<!--             col = wesanderson::wes_palettes$Royal1[2],  -->
<!--             alpha = 0.5) +  -->
<!--   geom_line(data = dfexpposterior,  -->
<!--             aes(x = survival, y = explicit_posterior), -->
<!--             col = wesanderson::wes_palettes$Royal1[3],  -->
<!--             size = 1.5,  -->
<!--             linetype = "dashed") +  -->
<!--   geom_line(data = dfprior, -->
<!--             aes(x = survival, y = prior), -->
<!--             col = wesanderson::wes_palettes$Royal1[1], -->
<!--             size = 1.5) -->
<!-- ``` -->

In our example, we have a single parameter to estimate, winter survival. This means dealing with a one-dimensional integral in the denominator which is pretty easy with quadrature techniques and the `R` function `integrate()`. Now what if we had multiple parameters? For example, imagine you'd like to fit a capture-recapture model with detection probability $p$ and regression parameters $\alpha$ and $\beta$ for the intercept and slope of a relationship between survival probability and a covariate, then Bayes' theorem gives you the posterior distribution of all three parameters together:

$$ \Pr(\alpha, \beta, p \mid \text{data}) = \frac{ \Pr(\text{data} \mid \alpha, \beta, p) \times \Pr(\alpha, \beta, p)}{\iiint \, \Pr(\text{data} \mid \alpha, \beta, p) \Pr(\alpha, \beta, p) d\alpha d\beta dp} $$
There are two computational challenges with this formula. First, do we really wish to calculate a three-dimensional integral? The answer is no, one-dimensional and two-dimensional integrals are so much further we can go with standard methods. Second, we're more interested in a posterior distribution for each parameter separately than the joint posterior distribution. The so-called marginal distribution of $p$ for example is obtained by integrating over all the other parameters -- a two-dimensional integral in this example. Now imagine with tens or hundreds of parameters to estimate, these integrals become highly multi-dimensional and simply intractable. In the next section, I introduce powerful simulation methods to circumvent this issue. 

## Markov chain Monte Carlo (MCMC)

In the early 1990s, statisticians rediscovered work from the 1950's in physics. In a famous paper that would lay the fundations of modern Bayesian statistics (Figure \@ref(fig:mcmcpaper)), the authors use simulations to approximate posterior distributions with some precision by drawing large samples. This is a neat trick to avoid explicit calculation of the multi-dimensional integrals we struggle with when using Bayes' theorem. 

```{r mcmcpaper, echo = FALSE, fig.align='center', fig.cap = "MCMC article cover. Source: The Journal of Chemical Physics -- https://aip.scitation.org/doi/10.1063/1.1699114", out.width="100%"}
knitr::include_graphics("images/metropolis.png")
```

These simulation algorithms are called Markov chain Monte Carlo (MCMC), and they definitely gave a boost to Bayesian statistics. There are two parts in MCMC, Markov chain and Monte Carlo, let's try and make sense of these terms. 

### Monte Carlo integration

What does Monte Carlo stand for? Monte Carlo integration is a simulation technique to calculate integrals of any function $f$ of random variable $X$ with distribution $\Pr(X)$ say $\int f(X) \Pr(X)dX$. You draw values $X_1,\ldots,X_k$ from $\Pr(X)$ the distribution of $X$, apply function $f$ to these values, then calculate the mean of these new values $\displaystyle{\frac{1}{k}}\sum_{i=1}^k{f(X_i)}$ to approximate the integral. How is Monte Carlo integration used in a Bayesian context? The posterior distribution contains all the information we need about the parameter to be estimated. When dealing with many parameters however, you may want to summarise posterior results by calculating numerical summaries. The simplest numerical summary is the mean of the posterior distribution, $E(\theta) = \int \theta \Pr(\theta|\text{data})$, where $X$ is $\theta$ now and $f$ is the identity function. Posterior mean can be calculated with Monte Carlo integration:
```{r}
# draw 1000 values from posterior survival beta(20,39)
sample_from_posterior <- rbeta(1000, 20, 39) 
# compute mean with Monte Carlo integration
mean(sample_from_posterior) 
```

You may check that the mean we have just calculated matches closely the expectation of a beta distribution:
```{r}
20/(20+39) # expectation of beta(20,39)
```

Another useful numerical summary is the credible interval within which our parameter falls with some probability, usually 0.95 hence a 95$\%$ credible interval. Finding the bounds of a credible interval requires calculating quantiles, which in turn involves integrals and the use of Monte Carlo integration. A 95$\%$ credible interval for winter survival can be obtained in `R` with:
```{r}
quantile(sample_from_posterior, probs = c(2.5/100, 97.5/100))
```

### Markov chains {#markovmodelmcmc}

What is a Markov chain? A Markov chain is a random sequence of numbers, in which each number depends only on the previous number. An example is the weather in my home town in Southern France, Montpellier, in which a sunny day is most likely to be followed by another sunny day, say with probability 0.8, and a rainy day is rarely followed by another rainy day, say with probability 0.1. The dynamic of this Markov chain is captured by the transition matrix $\Gamma$:
\vspace{0.9em}
$$
\begin{matrix}
& \\
\Gamma = 
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    \text{sunny tomorrow} & \text{rainy tomorrow} \\[0.3em]
0.8 & 0.2 \\ 
0.9 & 0.1 \\ 
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \end{matrix} } \right )
    \begin{matrix}
    \text{sunny today} \\ \text{rainy today}
    \end{matrix}
\end{matrix}
$$

In rows the weather today, and in columns the weather tomorrow. The cells give the probability of a sunny or rainy day tomorrow, given the day is sunny or rainy today. Under certain conditions, a Markov chain will converge to a unique stationary distribution. In our weather example, let's run the Markov chain for 20 steps:
```{r}
# transition matrix
weather <- matrix(c(0.8, 0.2, 0.9, 0.1), nrow = 2, byrow = T) 
steps <- 20
for (i in 1:steps){
  weather <- weather %*% weather # matrix multiplication
}
round(weather, 2) # matrix product after 20 steps
```

Each row of the transition matrix converges to the same distribution $(0.82, 0.18)$ as the number of steps increases. Convergence happens no matter which state you start in, and you always have probability 0.82 of the day being sunny and 0.18 of the day being rainy. 

Back to MCMC, the core idea is that you can build a Markov chain with a given stationary distribution set to be the desired posterior distribution. 

:::: {.blackbox data-latex=""}
Putting Monte Carlo and Markov chains together, MCMC allows us to generate a sample of values (Markov chain) whose distribution converges to the posterior distribution, and we can use this sample of values to calculate any posterior summaries (Monte Carlo), such as posterior means and credible intervals. 
:::: 

### Metropolis algorithm {#metropolis-algorithm}

There are several ways of constructing Markov chains for Bayesian inference. You might have heard about the Metropolis-Hastings or the Gibbs sampler. Have a look to <https://chi-feng.github.io/mcmc-demo/> for an interactive gallery of MCMC algorithms. Here I illustrate the Metropolis algorithm and how to implement it in practice.

Let's go back to our example on animal survival estimation. We illustrate sampling from survival posterior distribution. We write functions for likelihood, prior and posterior:

```{r}
# 19 recaptured alive out of 57 captured, marked and released
survived <- 19
released <- 57

# binomial log-likelihood function
loglikelihood <- function(x, p){
  dbinom(x = x, size = released, prob = p, log = TRUE)
}

# uniform prior density
logprior <- function(p){
  dunif(x = p, min = 0, max = 1, log = TRUE)
}

# posterior density function (log scale)
posterior <- function(x, p){
  loglikelihood(x, p) + logprior(p) # - log(Pr(data))
}
```

The Metropolis algorithm works as follows: 
  
1. We pick a value of the parameter to be estimated. This is where we start our Markov chain -- this is a *starting* value, or a starting location. 

2. To decide where to go next, we propose to move away from the current value of the parameter -- this is a *candidate* value. To do so, we add to the current value some random value from e.g. a normal distribution with some variance -- this is a *proposal* distribution. The Metropolis algorithm is a particular case of the Metropolis-Hastings algorithm with symmetric proposals.
  
3. We compute the ratio of the probabilities at the candidate and current locations $R=\displaystyle{\frac{{\Pr(\text{candidate}|\text{data})}}{{\Pr(\text{current}|\text{data})}}}$. This is where the magic of MCMC happens, in that $\Pr(\text{data})$, the denominator in the Bayes' theorem, appears in both the numerator and the denominator in $R$ therefore cancels out and does not need to be calculated. 

<!-- -- *the Hastings ratio* -->

4. If the posterior at the candidate location $\Pr(\text{candidate}|\text{data})$ is higher than at the current location $\Pr(\text{current}|\text{data})$, in other words when the candidate value is more plausible than the current value, we definitely accept the candidate value. If not, then we accept the candidate value with probability $R$ and reject with probability $1-R$. For example, if the candidate value is ten times less plausible than the current value, then we accept with probability 0.1 and reject with probability 0.9. How does it work in practice? We use a continuous spinner that lands somewhere between 0 and 1 -- call the random spin $X$. If $X$ is smaller than $R$, we move to the candidate location, otherwise we remain at the current location.  We do not want to accept or reject too often. In practice, the Metropolis algorithm should have an acceptance probability between 0.2 and 0.4, which can be achieved by *tuning* the variance of the normal proposal distribution. 
  
5. We repeat 2-4 a number of times -- or *steps*.

Enough of the theory, let's implement the Metropolis algorithm in `R`. Let's start by setting the scene:
```{r}
steps <- 100 # number of steps
theta.post <- rep(NA, steps) # vector to store samples
accept <- rep(NA, steps) # keep track of accept/reject
set.seed(1234) # for reproducibility
```

Now follow the 5 steps we've just described. First, we pick a starting value, and store it (step 1):
```{r}
inits <- 0.5
theta.post[1] <- inits
accept[1] <- 1
```

Then, we need a function to propose a candidate value: 
```{r}
# by default, standard deviation of the proposal distribution is 1
move <- function(x, away = 1){
  # apply logit transform (-infinity,+infinity)
  logitx <- log(x / (1 - x)) 
  # add a value taken from N(0,sd=away) to current value
  logit_candidate <- logitx + rnorm(1, 0, away)
  # back-transform (0,1)
  candidate <- plogis(logit_candidate) 
  return(candidate)
}
```

We add a value taken from a normal distribution with mean zero and standard deviation we call *away*. We work on the logit scale to make sure the candidate value for survival lies between 0 and 1.

Now we're ready for steps 2, 3 and 4. We write a loop to take care of step 5. We start at initial value 0.5 and run the algorithm for 100 steps or iterations:
```{r}
for (t in 2:steps){ # repeat steps 2-4 (step 5)
  
  # propose candidate value for survival (step 2)
  theta_star <- move(theta.post[t-1])
  
  # calculate ratio R (step 3)
  pstar <- posterior(survived, p = theta_star)  
  pprev <- posterior(survived, p = theta.post[t-1])
  logR <- pstar - pprev # likelihood and prior are on the log scale
  R <- exp(logR)
  
  # accept candidate value or keep current value (step 4)
  X <- runif(1, 0, 1) # spin continuous spinner
  if (X < R){
    theta.post[t] <- theta_star # accept candidate value
    accept[t] <- 1 # accept
  }
  else{
    theta.post[t] <- theta.post[t-1] # keep current value
    accept[t] <- 0 # reject
  }
}
```

We get the following values:
```{r}
head(theta.post) # first values
tail(theta.post) # last values
```

Visually, you may look at the chain:
```{r chain}
df <- data.frame(x = 1:steps, y = theta.post)
df %>%
  ggplot() +
  geom_line(aes(x = x, y = y), 
            size = 1.5, 
            color = wesanderson::wes_palettes$Zissou1[1]) + 
  labs(x = "iterations", y = "samples") + 
  ylim(0.1, 0.6)
```

In this visualisation, remember that our Markov chain starts at value 0.5. The steps or iterations are on the x-axis, and samples on the y-axis. This graphical representation is called a trace plot.

The acceptance probability is the average number of times we accepted a candidate value, which is `r mean(accept)` and almost satisfying. 

```{r echo = FALSE}
# log-likelihood function
loglikelihood <- function(x, p){
  dbinom(x = x, size = released, prob = p, log = TRUE)
}

# prior density
logprior <- function(p){
  dunif(x = p, min = 0, max = 1, log = TRUE)
}

# posterior density function (log scale)
posterior <- function(x, p){
  loglikelihood(x, p) + logprior(p) # - log(Pr(data))
}

# propose candidate value
move <- function(x, away = .2){ 
  logitx <- log(x / (1 - x))
  logit_candidate <- logitx + rnorm(1, 0, away)
  candidate <- plogis(logit_candidate)
  return(candidate)
}
```

To make our life easier and avoid repeating the same lines of code again and again, let's make a function out of the code we have written so far:
```{r echo = TRUE}
metropolis <- function(steps = 100, inits = 0.5, away = 1){
  
  # pre-alloc memory
  theta.post <- rep(NA, steps)
  
  # start
  theta.post[1] <- inits
  
  for (t in 2:steps){
    
    # propose candidate value for prob of success
    theta_star <- move(theta.post[t-1], away = away)
    
    # calculate ratio R
    pstar <- posterior(survived, p = theta_star)  
    pprev <- posterior(survived, p = theta.post[t-1])
    logR <- pstar - pprev
    R <- exp(logR)
    
    # accept candidate value or keep current value (step 4)
    X <- runif(1, 0, 1) # spin continuous spinner
    if (X < R){
      theta.post[t] <- theta_star
    }
    else{
      theta.post[t] <- theta.post[t-1]
    }
  }
  theta.post
}
```

Can we run another chain and start at initial value 0.2 this time? Yes, just go through the same algorithm again, and visualise the results with trace plot of survival for two chains starting at 0.2 (grey, or yellow in the online version) and 0.5 (black, or blue in the online version) run for 100 steps:
```{r twochains}
theta.post2 <- metropolis(steps = 100, inits = 0.2)
df2 <- data.frame(x = 1:steps, y = theta.post2)

if (params$bw) {
  ggplot() +
  geom_line(data = df,
            aes(x = x, y = y), 
            size = 1.5, 
            color = 'black') + 
  geom_line(data = df2, 
            aes(x = x, y = y), 
            size = 1.5, 
            color = 'grey') + 
  labs(x = "iterations", y = "values from posterior distribution") + 
  ylim(0.1, 0.6)

} else {
  ggplot() +
  geom_line(data = df,
            aes(x = x, y = y), 
            size = 1.5, 
            color = wesanderson::wes_palettes$Zissou1[1]) + 
  geom_line(data = df2, 
            aes(x = x, y = y), 
            size = 1.5, 
            color = wesanderson::wes_palettes$Zissou1[3]) + 
  labs(x = "iterations", y = "values from posterior distribution") + 
  ylim(0.1, 0.6)
}
```

Notice that we do not get the exact same results because the algorithm is stochastic. The question is to know whether we have reached the stationary distribution. Let's increase the number of steps, start at 0.5 and run a chain with 5000 iterations:
```{r longchain}
steps <- 5000
set.seed(1234)
theta.post <- metropolis(steps = steps, inits = 0.5)
df <- data.frame(x = 1:steps, y = theta.post)
df %>%
  ggplot() +
  geom_line(aes(x = x, y = y), 
            size = 1, 
            color = wesanderson::wes_palettes$Zissou1[1]) + 
  labs(x = "iterations", y = "values from posterior distribution") + 
  ylim(0.1, 0.6) + 
  geom_hline(aes(yintercept = mean(theta.post), 
                 linetype = "posterior mean")) + 
  scale_linetype_manual(name = "", values = c(2,2)) 
```

This is what we're after, a trace plot that looks like a beautiful lawn, see Section \@ref(convergence-diag). 

<!-- I find it informative to look at the animated version of the figure above, it helps understanding the stochastic behavior of the algorithm, and also to realise how the chains converge to their stationary distribution, see Figure \@ref(fig:animlongchain). -->

<!-- ```{r echo = FALSE, eval = FALSE} -->
<!-- # load packages -->
<!-- library(tidyverse) -->
<!-- theme_set(theme_light(base_size = 16)) -->
<!-- library(gganimate) -->
<!-- library(magick) -->

<!-- # deer data, 19 "success" out of 57 "attempts" -->
<!-- survived <- 19 -->
<!-- released <- 57 -->

<!-- #---------- apply Metropolis -->

<!-- steps <- 1000 -->
<!-- chain1 <- metropolis(steps = steps, inits = 0.2) -->
<!-- chain2 <- metropolis(steps = steps, inits = 0.5) -->
<!-- chain3 <- metropolis(steps = steps, inits = 0.7) -->

<!-- df <- data.frame(iter = rep(1:steps, 3),  -->
<!--                  value = c(chain1, chain2, chain3), -->
<!--                  chain = c(rep("chain1", steps),  -->
<!--                            rep("chain2", steps),  -->
<!--                            rep("chain3", steps))) -->

<!-- #---------- time series -->
<!-- static_tsplot <- df %>% -->
<!--   mutate(posterior_mean = mean(value)) %>% -->
<!--   ggplot(aes(x = iter, y = value, group = chain, color = chain)) + -->
<!--   geom_line(size = 1, alpha = 0.5) +  -->
<!--   geom_hline(aes(yintercept = posterior_mean, linetype = "posterior mean")) +  -->
<!--   scale_linetype_manual(name = "", values = c(2,2)) +  -->
<!--   labs(color = "", x = "iterations", y = "survival") -->
<!-- static_tsplot   -->

<!-- # animate -->
<!-- animated_tsplot <- static_tsplot + -->
<!--   transition_reveal(along = iter,  -->
<!--                     range = as.integer(c(1, max(df$iter) + 50))) # trick to pause -->
<!-- animated_tsplot   -->

<!-- # save -->
<!-- a_gif <- animate(animated_tsplot, -->
<!--                  width = 6,  -->
<!--                  height = 3, -->
<!--                  res = 600, -->
<!--                  units = "in") -->

<!-- # get file in directory str(a_gif) -->
<!-- ``` -->
<!-- ```{r animlongchain, echo = FALSE, out.width="100%", fig.align='center', fig.cap = "Animated trace plot of survival with three chains starting at 0.2, 0.5 and 0.7 run for 1000 steps."} -->
<!-- knitr::include_graphics("images/traceplotMCMC.gif") -->
<!-- ``` -->

Once the stationary distribution is reached, you may regard the realisations of the Markov chain as a sample from the posterior distribution, and obtain numerical summaries. In the next section, we consider several important implementation issues. 

## Assessing convergence {#convergence-diag}

:::: {.blackbox data-latex=""}
When implementing MCMC, we need to determine how long it takes for our Markov chain to converge to the target distribution, and the number of iterations we need after achieving convergence to get reasonable Monte Carlo estimates of numerical summaries (posterior means and credible intervals).
::::

### Burn-in
  
In practice, we discard observations from the start of the Markov chain and just use observations from the chain once it has converged. The initial observations that we discard are usually referred to as the *burn-in*. 

The simplest method to determine the length of the burn-in period is to look at trace plots. Going back to our example, let's have a look to a trace plot of a chain that starts at value 0.99. 

```{r burnin}
# set up the scene
steps <- 1000
theta.post <- metropolis(steps = steps, inits = 0.99)
df <- data.frame(x = 1:steps, y = theta.post)
df %>%
  ggplot() +
  geom_line(aes(x = x, y = y), 
            size = 1.2, 
            color = wesanderson::wes_palettes$Zissou1[1]) + 
  labs(x = "iterations", y = "survival") + 
  theme_light(base_size = 14) + 
  annotate("rect", 
           xmin = 0, 
           xmax = 100, 
           ymin = 0.1, 
           ymax = 1, 
           alpha = .3) +
  scale_y_continuous(expand = c(0,0))
```

The chain starts at value 0.99 and rapidly stabilises, with values bouncing back and forth around 0.3 from the 100th iteration onwards. You may choose the shaded area as the burn-in, and discard the first 100th values.

We see from the trace plot below that we need at least 100 iterations to achieve convergence toward an average survival around 0.3. It is always better to be conservative when specifying the length of the burn-in period, and in this example, we would use 250 or even 500 iterations as a burn-in. The length of the burn-in period can be determined by performing preliminary MCMC short runs. 

Inspecting the trace plot for a single run of the Markov chain is useful. However, we usually run the Markov chain several times, starting from different over-dispersed points, to check that all runs achieve the same stationary distribution. This approach is formalised by using the Brooks-Gelman-Rubin (BGR) statistic $\hat{R}$ which measures the ratio of the total variability combining multiple chains (between-chain plus within-chain) to the within-chain variability. The BGR statistic asks whether there is a chain effect, and is very much alike the $F$ test in an analysis of variance. Values below 1.1 indicate likely convergence.

```{r, echo = FALSE, cache = TRUE}
simul.bgr <- function(steps, inits){
  
  nb.replicates <- length(inits)
  theta.post <- matrix(NA, nrow = nb.replicates, ncol = steps)
  for (i in 1:nb.replicates){
    theta.post[i,1:steps] <- metropolis(steps = steps, inits = inits[i])
  }
  
  df <- data.frame(x = rep(1:steps, nb.replicates), 
                   y = c(t(theta.post)), 
                   chain = paste0("chain ",gl(nb.replicates, steps))) %>%
    filter(x > round(steps/2)) # apply burnin (half number of iterations)

  # compute BGR (R-hat)
  num <- quantile(df$y, probs = c(20/100, 80/100))[2] - quantile(df$y, probs = c(20/100, 80/100))[1]
  den <- df %>%
    group_by(chain) %>%
    summarise(ci = quantile(y, probs = c(20/100, 80/100))) %>%
    mutate(diff = ci - lag(ci, default = ci[1])) %>%
    filter(diff != 0) %>%
    pull(diff) %>%
    mean()
  
  bgr <- round(num / den, 3)
  return(bgr)
}

set.seed(1234)
steps <- seq(100, 5000, 100)
bgr <- rep(NA, length(steps))
for (i in 1:length(steps)){
  bgr[i] <- simul.bgr(steps = steps[i], inits = c(0.2, 0.8))
}
df <- data.frame(iterations = steps, bgr = bgr)
```

Back to our example, we run two Markov chains with starting values 0.2 and 0.8 using 100 up to 5000 iterations, and calculate the BGR statistic using half the number of iterations as the length of the burn-in (code not shown): 

```{r bgr, echo=FALSE}
df %>%
  ggplot() + 
  geom_line(aes(x = iterations, y = bgr), size = 1.2) +
  labs(y = "BGR statistic")
```

We get a value of the BGR statistic near 1 by up to 2000 iterations, which suggests that with 2000 iterations as a burn-in, there is no evidence of a lack of convergence.

It is important to bear in mind that a value near 1 for the BGR statistic is only a necessary *but not sufficient* condition for convergence. In other words, this diagnostic cannot tell you for sure that the Markov chain has achieved convergence, only that it has not.

### Chain length
  
How long of a chain is needed to produce reliable parameter estimates? To answer this question, you need to keep in mind that successive steps in a Markov chain are not independent -- this is usually referred to as *autocorrelation*. Ideally, we would like to keep autocorrelation as low as possible. Here again, trace plots are useful to diagnose issues with autocorrelation. Let's get back to our survival example. The figure below shows trace plots for different values of the standard deviation (parameter *away*) of the normal proposal distribution we use to propose a candidate value (Section \@ref(metropolis-algorithm)): 

```{r, echo = TRUE}
# inspired from 
# https://bookdown.org/content/3686/markov-chain-monte-carlo.html

n_steps <- 10000

d <-
  tibble(away = c(0.1, 1, 10)) %>% 
  mutate(accepted_traj = map(away, 
                             metropolis, 
                             steps = n_steps, 
                             inits = 0.1)) %>% 
  unnest(accepted_traj)

d <-
  d %>% 
  mutate(proposal_sd = str_c("Proposal SD = ", away),
         iter        = rep(1:n_steps, times = 3))

trace <- d %>% 
  ggplot(aes(y = accepted_traj, x = iter)) +
  geom_path(size = 1/4, color = "steelblue") +
  geom_point(size = 1/2, alpha = 1/2, color = "steelblue") +
  scale_y_continuous("survival", 
                     breaks = 0:5 * 0.1, 
                     limits = c(0.15, 0.5)) +
  scale_x_continuous("iterations", 
                     breaks = seq(n_steps-n_steps*10/100,
                                  n_steps,
                                  by = 600), 
                     limits = c(n_steps-n_steps*10/100,n_steps)) +
  facet_wrap(~proposal_sd, ncol = 3) +
  theme_light(base_size = 14)

trace
```

Small and big moves in the left and right panels provide high correlations between successive observations of the Markov chain, whereas a standard deviation of 1 in the center panel allows efficient exploration of the parameter space. The movement around the parameter space is referred to as *mixing*. Mixing is bad when the chain makes small and big moves, and good otherwise. 

In addition to trace plots, autocorrelation function (ACF) plots are a convenient way of displaying the strength of autocorrelation in a given sample values. ACF plots provide the autocorrelation between successively sampled values separated by an increasing number of iterations, or *lag*. We obtain the autocorrelation function plots for different values of the standard deviation of the proposal distribution with the R `forecast::ggAcf()` function: 

```{r}
library(forecast)
mask <- d$proposal_sd=="Proposal SD = 0.1"
plot1 <- ggAcf(x = d$accepted_traj[mask]) + ggtitle("SD = 0.1")
mask <- d$proposal_sd=="Proposal SD = 1"
plot2 <- ggAcf(x = d$accepted_traj[mask]) + ggtitle("SD = 1")
mask <- d$proposal_sd=="Proposal SD = 10"
plot3 <- ggAcf(x = d$accepted_traj[mask]) + ggtitle("SD = 10")

library(patchwork)
(plot1 + plot2 + plot3)
```

In the left and right panels, autocorrelation is strong, decreases slowly with increasing lag and mixing is bad. In the center panel, autocorrelation is weak, decreases rapidly with increasing lag and mixing is good.

Autocorrelation is not necessarily a big issue. Strongly correlated observations just require large sample sizes and therefore longer simulations. But how many iterations exactly? The effective sample size (`n.eff`) measures chain length while taking into account chain autocorrelation. You should check the `n.eff` of every parameter of interest, and of any interesting parameter combinations. In general, we need $\text{n.eff} \geq 400$ independent steps to get reasonable Monte Carlo estimates of model parameters. In the animal survival example, `n.eff` can be calculated with the R `coda::effectiveSize()` function:
```{r neff, echo = TRUE}
mask <- d$proposal_sd=="Proposal SD = 0.1"
neff1 <- coda::effectiveSize(d$accepted_traj[mask])
mask <- d$proposal_sd=="Proposal SD = 1"
neff2 <- coda::effectiveSize(d$accepted_traj[mask])
mask <- d$proposal_sd=="Proposal SD = 10"
neff3 <- coda::effectiveSize(d$accepted_traj[mask])
df <- tibble("Proposal SD" = c(0.1, 1, 10),
             "n.eff" = round(c(neff1, neff2, neff3)))
df
```

As expected, `n.eff` is less than the number of MCMC iterations because of autocorrelation. Only when the standard deviation of the proposal distribution is 1 is the mixing good and we get a satisfying effective sample size. 

### What if you have issues of convergence?
  
When diagnosing MCMC convergence, you will (very) often run into troubles. In this section you will find some helpful tips I hope. 

When mixing is bad and effective sample size is small, you may just need to increase burn-in and/or sample more. Using more informative priors might also make Markov chains converge faster by helping your MCMC sampler (e.g. the Metropolis algorithm) navigating more efficiently the parameter space. In the same spirit, picking better initial values for starting the chain does not harm. For doing that, a strategy consists in using estimates from a simpler model for which your MCMC chains do converge. 

If convergence issues persist, often there is a problem with your model (also known as *the folk theorem of statistical computing* as stated by Andrew Gelman, see <https://statmodeling.stat.columbia.edu/2008/05/13/the_folk_theore/>). A bug in the code? A typo somewhere? A mistake in your maths? As often when coding is involved, the issue can be identified by removing complexities, and start with a simpler model until you find what the problem is. 

A general advice is to see your model as a data generating tool in the first place, simulate data from it using some realistic values for the parameters, and try to recover these parameter values by fitting the model to the simulated data. Simulating from a model will help you understanding how it works, what it does not do, and the data you need to get reasonable parameter estimates (e.g. Chapter \@ref(hmmcapturerecapture) and Section \@ref(indhet)). 

<!-- We will see other strategies to improve convergence in the next chapters. Cross reference relevant chapters. Option 1. Change your sampler. Option 2. Reparameterize (standardize covariates, plus non-centering: $\alpha \sim N(0,\sigma)$ becomes $\alpha = z \sigma$ with $z \sim N(0,1)$). -->

## Summary

+ With the Bayes' theorem, you update your beliefs (prior) with new data (likelihood) to get posterior beliefs (posterior): posterior $\propto$ likelihood $\times$ prior.

+ The idea of Markov chain Monte Carlo (MCMC) is to simulate values from a Markov chain which has a stationary distribution equal to the posterior distribution you're after. 

+ In practice, you run a Markov chain multiple times starting from over-dispersed initial values. 

+ You discard iterations in an initial burn-in phase and achieve convergence when all chains reach the same regime. 

+ From there, you run the chains long enough and proceed with calculating Monte Carlo estimates of numerical summaries (e.g. posterior means and credible intervals) for parameters.

## Suggested reading 

+ @mccarthy2007 and @KerySchaub2011 are excellent introductions to Bayesian statistics for ecologists. The forthcoming second edition of the latter will also include NIMBLE code. See also @keryAppliedStatisticalModelling2024.

+ For deeper insights, I recommend @gelmanhill2006 which analyse data using the frequentist and Bayesian approaches side-by-side. The book by @mcelreathbook is also an excellent read. The presentation of the Metropolis algorithm in Section \@ref(metropolis-algorithm) was inspired by @alberthu2019. If you'd like to know more about Monte Carlo methods, the book @robert2004montecarlo is a must [see also its R counterpart @robert2004montecarloinr]. See also @vehtariRankNormalizationFoldingLocalization2021 for a discussion on $\hat{R}$ and the effective sample size.

+ I also recommend @gelman2020workflow in which the authors offer a workflow for Bayesian analyses. They discuss model building, model comparison, model checking, model validation, model understanding and troubleshooting of computational problems.


<!--chapter:end:1-bayesmcmc.Rmd-->

```{r include=FALSE, cache=FALSE}
# packages
library(tidyverse)
theme_set(theme_light(base_size = 14))
library(nimble)
library(MCMCvis)
library(magick)
library(pdftools)
library(wesanderson)
library(RColorBrewer)
library(patchwork)
library(emo)
#library(nimbleEcology)
#library(basicMCMCplots)

# R options
options(width = 60)

# chunk options
knitr::opts_chunk$set(
  comment = "##",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE
  )
```
# NIMBLE tutorial {#intronimble}

## Introduction

In this second chapter, you will get familiar with NIMBLE, an R package that implements up-to-date MCMC algorithms for fitting complex models. NIMBLE spares you from coding the MCMC algorithms by hand, and requires only the specification of a likelihood and priors for model parameters. Should you wish to dive deeper into the mechanics, NIMBLE also got you covered and allows you to write samples, use custom functions, etc. We will illustrate NIMBLE's main features with a simple example, but the ideas hold for more complex problems.

## What is NIMBLE?

NIMBLE stands for **N**umerical **I**nference for statistical **M**odels using **B**ayesian and **L**ikelihood **E**stimation (Figure \@ref(fig:nimblelogo)). Briefly speaking, NIMBLE is an R package that implements for you MCMC algorithms to generate samples from the posterior distribution of model parameters. Freed from the burden of coding your own MCMC algorithms, you only have to specify a likelihood and priors to apply the Bayes theorem. To do so, NIMBLE makes this easy by using a syntax very similar to the R syntax, which should make your life easier. It is also a direct extension of the BUGS language is also used by other programs like WinBUGS, OpenBUGS, and JAGS. 

So why use NIMBLE you may ask? The short answer is that NIMBLE is capable of so much more than just running MCMC algorithms! First, you will work from within R, but in the background NIMBLE will translate your code in C++ for (in general) faster computation. Second, NIMBLE extends the BUGS language for writing new functions and distributions of your own, or borrow those written by others. Third, NIMBLE gives you full control of the MCMC samplers, and you may pick other algorithms than the defaults. Fourth, NIMBLE comes with a library of numerical methods other than MCMC algorithms, including sequential Monte Carlo (for particle filtering), Monte Carlo Expectation Maximization (for maximum likelihood), Hamiltonian Monte Carlo (like in program Stan), and Laplace approximation (like in program TMB). Last but not least, the development team is friendly and helpful, and based on users' feedbacks, NIMBLE folks work constantly at improving the package capabilities. The NIMBLE users google group is an open and inclusive space where everyone can receive help from the community: <https://groups.google.com/g/nimble-users>.

```{r nimblelogo, echo = FALSE, fig.align="center", out.width="50%", fig.cap = "Logo of the NIMBLE R package designed by Luke Larson."}
knitr::include_graphics("images/nimble-icon.png")
```

<!-- Why NIMBLE over Stan? i) The BUGS language is cool, ii) discrete latent states easier to deal with NIMBLE, no need to marginalise like with Stan, iii) also HMC is in NIMBLE. From Chloe: Stan users tell me that ii) is really not true, and based on an early misconception. Also, I see no reason to discuss why one would use nimble over STAN here. Open minds are the winners ;-). -->

## Getting started {#start-nimble}


:::: {.blackbox data-latex=""}
To run NIMBLE, you will need to:  
1. Build a model consisting of a likelihood and priors.   
2. Read in some data.   
3. Specify parameters you want to make inference about.   
4. Pick initial values for parameters to be estimated (for each chain).   
5. Provide MCMC details namely the number of chains, the length of the burn-in period and the number of iterations following burn-in.
::::


First things first, let's not forget to load the `nimble` package:
```{r}
library(nimble)
```

Note that before you can install `nimble` like any other R package, Windows users will need to install `Rtools`, and Mac users will need to install `Xcode`. More info and help trouble-shooting installation issues can be found here: <https://r-nimble.org/download>.

Now let's go back to our example on animal survival from the previous chapter. First step is to build our model by specifying the binomial likelihood and a uniform prior on survival probability `theta`. We use the `nimbleCode()` function and wrap code within curly brackets:
```{r}
model <- nimbleCode({
  # likelihood
  survived ~ dbinom(theta, released)
  # prior
  theta ~ dunif(0, 1)
  # derived quantity
  lifespan <- -1/log(theta)
})
```

You can check that the `model` R object contains your code:
```{r}
model
```

In the code above, `survived` and `released` are known, only `theta` needs to be estimated. The line `survived ~ dbinom(theta, released)` states that the number of successes or animals that have survived over winter, `survived`, is distributed as (that's the `~`) a binomial with `released` trials and probability of success or survival `theta`. Then the line `theta ~ dunif(0, 1)` assigns a uniform distribution between 0 and 1 as a prior to the survival probability. This is all you need, a likelihood and priors for model parameters, NIMBLE knows the Bayes theorem. The last line `lifespan <- - 1/log(theta)` calculates a quantity derived from `theta`, which is the expected lifespan assuming constant survival. If you'd like to know more about the calculation of life expectancy, check out @cook1967expectancy.

A few comments:   

+ The most common distributions are readily available in NIMBLE. Among others, we will use later in the book `dbeta`, `dmultinom` and `dnorm`. If you cannot find what you need in NIMBLE, you can write your own distributions as illustrated in Section \@ref(functions-in-nimble).

+ It does not matter in what order you write each line of code, NIMBLE uses what is called a declarative language for building models. In brief, you write code that tells NIMBLE what you want to achieve, and not how to get there. In contrast, an imperative language requires that you write what you want your program to do step by step.

+ You can think of models in NIMBLE as graphs as in Figure \@ref(fig:dag-survival). A graph is made of relations (or edges) that can be of two types. A stochastic relation is signaled by a `~` sign and defines a random variable in the model, such as `survived` or `theta`. A deterministic relation is signaled by a `<-` sign, like `lifespan`. Relations define nodes on the left - the children - in terms of other nodes on the right - the parents - and relations are directed arrows from parents to children. Such graphs are called directed acyclic graph or DAG.
```{r dag-survival, echo = FALSE, fig.cap = "Graph of the animal survival model. Survived is a stochastic node defined by its parents `released` and `theta`, while `lifespan` is a deterministic node the value of which is defined exactly by the value of its parent `theta`."}
mc <- nimbleModel(model, data = list(released = 57, survived = 19))
#mc$getVarNames()
#mc$getNodeNames()
#mc$getNodeNames(determOnly = TRUE)
#mc$getNodeNames(stochOnly = TRUE)
#mc$getNodeNames(dataOnly = TRUE)
#mc$getDependencies("theta")
mc$plotGraph()
```

Second step in our workflow is to read in some data. We use a list in which each component corresponds to a known quantity in the model:
```{r}
my.data <- list(released = 57, survived = 19)
```

You can proceed with data passed this way, but you should know a little more about how NIMBLE sees data. NIMBLE distinguishes data and constants. Constants are values that do not change, e.g. vectors of known index values or the indices used to define for loops. Data are values that you might want to change, basically anything that only appears on the left of a `~`. Declaring relevant values as constants is better for computational efficiency, but it is easy to forget, and fortunately NIMBLE will by itself distinguish data and constants. It will suggest you to move some data into constants to improve efficiency. I will not use the distinction between data and constants in this chapter, but in the next chapters it will become important. 

<!-- In passing say that full indexing is needed, you cannot let NIMBLE guess dimensions. -->
<!-- Ici on reprend le modèle simple du dessus, et on l'exprime un peu différemment pour illustrer qqs autres features de NIMBLE: i) loops, ii) distinction between constants and data. The binomial is a sum of independent Bernoulli outcomes with same probability. the Like flipping a coin for each individual and get a survivor with prob theta. Here survived is. Going back to our animal survival example, it means that the likelihood can be written as a Bernoulli random variable taking value 1 if animal survived, and 0 otherwise. **Voir dans annexe Hobbs**. E.g. `survived[1] ~ dbern(theta)` up to `survived[59] ~ dbern(theta)`. Likelihood contribution of individuals. Loops is the product. Iid. Instead of duplicating the same line of code `survived[i] ~ dbern(theta)` we use a loop. -->
<!-- ```{r} -->
<!-- model <- nimbleCode({ -->
<!--   # likelihood -->
<!--   for (i in 1:released){ -->
<!--     survived[i] ~ dbern(theta) -->
<!--   } -->
<!--   # prior -->
<!--   theta ~ dunif(0, 1) -->
<!-- }) -->
<!-- ``` -->

<!-- **If you try nimbleMCMC it won't work. This is because we ned to distinguish data from constants. Uncomment code.** -->

<!-- Distinguih constants and data. To Nimble, not all "data" is data... -->
<!-- ```{r} -->
<!-- my.constants <- list(released = 57) -->
<!-- my.data <- list(survived = 19) -->
<!-- ``` -->
<!-- ```{r, eval = FALSE} -->
<!-- mcmc.output <- nimbleMCMC(code = model, -->
<!--                           data = my.data, -->
<!--                           constants = my.constants, -->
<!--                           inits = initial.values, -->
<!--                           monitors = parameters.to.save, -->
<!--                           niter = n.iter, -->
<!--                           nburnin = n.burnin, -->
<!--                           nchains = n.chains) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- my.data <- list(survived = c(rep(1,19), rep(0,57-19))) -->
<!-- my.constants <- list(released = 57) -->
<!-- ``` -->

<!-- The rest is the same. Steps 3, 4 and 5. -->
<!-- ```{r} -->
<!-- parameters.to.save <- c("theta", "life_expectancy") -->
<!-- initial.values <- function() list(theta = runif(1,0,1)) -->
<!-- n.iter <- 5000 -->
<!-- n.burnin <- 1000 -->
<!-- n.chains <- 3 -->
<!-- ``` -->

<!-- Run model, add argument `constants = my.constants`. -->
<!-- ```{r} -->
<!-- mcmc.output <- nimbleMCMC(code = model, -->
<!--                           data = my.data, -->
<!--                           constants = my.constants, -->
<!--                           inits = initial.values, -->
<!--                           monitors = parameters.to.save, -->
<!--                           niter = n.iter, -->
<!--                           nburnin = n.burnin, -->
<!--                           nchains = n.chains) -->
<!-- ``` -->

Third step is to tell NIMBLE which nodes in your model you would like to keep track of, in other words the quantities you'd like to do inference about. In our model we want survival `theta` and `lifespan`:
```{r}
parameters.to.save <- c("theta", "lifespan")
```

In general you have many quantities in your model, including some of little interest that are not worth monitoring, and having full control on verbosity will prove handy.

Fourth step is to specify initial values for all model parameters. As a bare minimum, you need initial values for all nodes that only appear on the left side of a `~` in your code and are not given as data. To make sure that the MCMC algorithm explores the posterior distribution, we start different chains with different parameter values. You can specify initial values for each chain (here we specify for three chains) in a list and put them in yet another list:
```{r}
init1 <- list(theta = 0.1)
init2 <- list(theta = 0.5)
init3 <- list(theta = 0.9)
initial.values <- list(init1, init2, init3)
initial.values
```

Alternatively, you can write an R function that generates random initial values:
```{r}
initial.values <- function() list(theta = runif(1,0,1))
initial.values()
```

If you are using a function to generate random initial values, it's always a good idea to set the seed in your code before you draw the initial values. For example like this: 
```{r eval = FALSE}
my.seed <- 666
set.seed(my.seed)
```

Setting the seed makes your code reproducible, which really helps if you need to trouble-shoot it later. Initialization problems are not uncommon when working with NIMBLE, and being able to reproduce the same initial values again is very useful for solving them. 

<!-- For the same reason, it's also advisable to sample your initial values first, and pass them to the MCMC function (see below) as a list instead of calling the initial value generation function within the MCMC function. -->

Fifth and last step, you need to tell NIMBLE the number of chains to run, say `n.chain`, how long the burn-in period should be, say `n.burnin`, and the number of iterations following the burn-in period to be used for posterior inference:
```{r}
n.iter <- 5000
n.burnin <- 1000
n.chains <- 3
```

In NIMBLE, you specify the total number of iterations, say `n.iter`, so that the number of posterior samples per chain is `n.iter - n.burnin`. NIMBLE also allows discarding samples after burn-in, a procedure known as thinning. Thinning is fixed to 1 by default in NIMBLE so that all simulations are used to summarise posterior distributions. @link2012thinning offer a discussion of the pros and cons of thinning. 

We now have all the ingredients to run our model, that is to sample from the posterior distribution of model parameters using MCMC simulations. This is accomplished using function `nimbleMCMC()`: 
```{r, cache = F}
mcmc.output <- nimbleMCMC(code = model,
                          data = my.data,
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter,
                          nburnin = n.burnin,
                          nchains = n.chains)
```

NIMBLE goes through several steps that we will explain in Section \@ref(under-the-hood). Function `nimbleMCMC()` takes other arguments that you might find useful. For example, one is `setSeed`. Just like with sampling initial values above, setting the seed within the MCMC call allows you to run the same chains (again), thus making your analyses reproducible and problems easier to debug (see Section \@ref(tipreproducibility)). You can also get a summary of the outputs by specifying `summary = TRUE`. Conversely, if you would rather just get the MCMC samples back (in `coda mcmc` format) you can set `samplesAsCodaMCMC = TRUE`. Finally, you can suppress the progress bar if you find it too depressing when running long simulations with `progressBar = FALSE`. Check `?nimbleMCMC` for more details. 

Now let's inspect what we have in `mcmc.output`: 
```{r}
str(mcmc.output)
```

The R object `mcmc.output` is a list with three components, one for each MCMC chain. Let's have a look to `chain1` for example:
```{r}
dim(mcmc.output$chain1)
head(mcmc.output$chain1)
```

Each component of the list is a matrix. In rows, you have `r dim(mcmc.output$chain1)[1]` samples from the posterior distribution of `theta`, which corresponds to `n.iter - n.burnin` iterations. In columns, you have the quantities we monitor, `theta` and `lifespan`. From there, you can compute the posterior mean of `theta`:
```{r}
mean(mcmc.output$chain1[,'theta'])
```

You can also obtain the 95% credible interval for `theta`:
```{r}
quantile(mcmc.output$chain1[,'theta'], probs = c(2.5, 97.5)/100)
```

Let's visualise the posterior distribution of `theta` with a histogram: 
```{r}
mcmc.output$chain1[,"theta"] %>%
  as_tibble() %>%
  ggplot() +
  geom_histogram(aes(x = value), color = "white") +
  labs(x = "survival probability")
```

There are less painful ways of doing posterior inference. In this book, I will use the R package `MCMCvis` to summarise and visualize MCMC outputs, but there are other perfectly valid options out there like `ggmcmc`, `bayesplot` and `basicMCMCplots`.

<!-- Finally we want to look at our samples. NIMBLE returns samples as a simple matrix with named columns. There are numerous packages for processing MCMC output. If you want to use the coda package, you can convert a matrix to a coda mcmc object like this: -->
<!-- library(coda) -->
<!-- coda.samples <- as.mcmc(samples) -->
<!-- Alternatively, if you call nimbleMCMC with the argument samplesAsCodaMCMC = TRUE, the samples will be returned as a coda object. -->

Let's load the package `MCMCvis`:
```{r}
library(MCMCvis)
```

To get the most common numerical summaries, the function `MCMCsummary()` does the job:
```{r}
MCMCsummary(object = mcmc.output, round = 2)
```

You can use a caterpillar plot to visualise the posterior distributions of `theta` with `MCMCplot()`:
```{r}
MCMCplot(object = mcmc.output, 
         params = 'theta')
```

The point represents the posterior median, the thick line is the 50% credible interval and the thin line the 95% credible interval. 

Visualization of a MCMC chain itself, i.e. the values of posterior samples plotted against iteration number, is called a trace. The trace and posterior density of theta can be obtained with `MCMCtrace()`:
```{r}
MCMCtrace(object = mcmc.output,
          pdf = FALSE, # no export to PDF
          ind = TRUE, # separate density lines per chain
          params = "theta")
```
We use the trace and density plots for assessing convergence and get an idea of whether there may be any estimation issues (see Section \@ref(convergence-diag)).

You can also add the diagnostics of convergence we discussed in the previous chapter:
```{r}
MCMCtrace(object = mcmc.output,
          pdf = FALSE,
          ind = TRUE,
          Rhat = TRUE, # add Rhat
          n.eff = TRUE, # add eff sample size
          params = "theta")
```

We calculated lifespan directly in our model with `lifespan <- -1/log(theta)`. But you can also calculate this quantity from outside NIMBLE. This is a nice by-product of using MCMC simulations: You can obtain the posterior distribution of any quantity that is a function of your model parameters by applying this function to samples from the posterior distribution of these parameters. Especially when working with big models/data, it is recommended to keep any calculations that can be made "post-hoc" using the posterior samples outside of NIMBLE as this lessens memory load. In our example, all you need is samples from the posterior distribution of `theta`, which we pool between the three chains with:
```{r}
theta_samples <- c(mcmc.output$chain1[,'theta'], 
                   mcmc.output$chain2[,'theta'],
                   mcmc.output$chain3[,'theta'])
```

To get samples from the posterior distribution of lifespan, we apply the function to calculate lifespan to the samples from the posterior distribution of survival:
```{r}
lifespan <- -1/log(theta_samples)
```

As usual then, you can calculate the posterior mean and 95% credible interval:
```{r}
mean(lifespan)
quantile(lifespan, probs = c(2.5, 97.5)/100)
```

You can also visualise the posterior distribution of lifespan:
```{r}
lifespan %>%
  as_tibble() %>%
  ggplot() +
  geom_histogram(aes(x = value), color = "white") +
  labs(x = "lifespan")
```

Now you're good to go. For convenience I have summarized the steps above in the box below. The NIMBLE workflow provided with `nimbleMCMC()` allows you to build models and make inference. This is what you can achieve with other software like WinBUGS or JAGS. 


:::: {.blackbox data-latex=""}
**NIMBLE workflow:**
```{r, eval = FALSE}
# model building
model <- nimbleCode({
  # likelihood
  survived ~ dbinom(theta, released)
  # prior
  theta ~ dunif(0, 1)
  # derived quantity
  lifespan <- -1/log(theta)
})
# read in data
my.data <- list(released = 57, survived = 19)
# specify parameters to monitor
parameters.to.save <- c("theta", "lifespan")
# pick initial values
initial.values <- function() list(theta = runif(1,0,1))
# specify MCMC details
n.iter <- 5000
n.burnin <- 1000
n.chains <- 3
# run NIMBLE
mcmc.output <- nimbleMCMC(code = model,
                          data = my.data,
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter,
                          nburnin = n.burnin,
                          nchains = n.chains)
# calculate numerical summaries
MCMCsummary(object = mcmc.output, round = 2)
# visualize parameter posterior distribution
MCMCplot(object = mcmc.output, 
         params = 'theta')
# check convergence
MCMCtrace(object = mcmc.output,
          pdf = FALSE, # no export to PDF
          ind = TRUE, # separate density lines per chain
          params = "theta")
```
:::


But NIMBLE is more than just another MCMC engine. It provides a programming environment so that you have full control when building models and estimating parameters. NIMBLE allows you to write your own functions and distributions to build models, and to choose alternative MCMC samplers or code new ones. This flexibility often comes with faster convergence and often faster runtime. 

I have to be honest, learning these improvements over other software takes some reading and experimentation, and it might well be that you do not need to use any of these features. And it's fine. In the next sections, I cover some of this advanced material. You may skip these sections and go back to this material later if you need it.

## Programming {#functions-in-nimble}

In NIMBLE you can write and use your own functions, or use existing R or C/C++ functions. This allows you to customize models the way you want. 

### NIMBLE functions

NIMBLE provides `nimbleFunctions` for programming. A `nimbleFunction` is like an R function, plus it can be compiled for faster computation. Going back to our animal survival example, we can write a `nimbleFunction` to compute lifespan:
```{r}
computeLifespan <- nimbleFunction(
    run = function(theta = double(0)) { # type declarations
        ans <- -1/log(theta)
        return(ans)
        returnType(double(0))  # return type declaration
    } )
```

Within the nimbleFunction, the `run` section gives the function to be executed. It is written in the NIMBLE language. The `theta = double(0)` and `returnType(double(0))` arguments tell NIMBLE that the input and output are single numeric values (scalars). Alternatively, `double(1)` and `double(2)` are for vectors and matrices, while `logical()`, `integer()` and `character()` are for logical, integer and character values. 

You can use your `nimbleFunction` in R:
```{r}
computeLifespan(0.8)
```

You can compile it and use the C++ code for faster computation: 
```{r}
CcomputeLifespan <- compileNimble(computeLifespan)
CcomputeLifespan(0.8)
```

You can also use your `nimbleFunction` in a model:
```{r}
model <- nimbleCode({
  # likelihood
  survived ~ dbinom(theta, released)
  # prior
  theta ~ dunif(0, 1)
  # derived quantity
  lifespan <- computeLifespan(theta)
})
```

The rest of the workflow remains the same: 
```{r}
my.data <- list(survived = 19, released = 57)
parameters.to.save <- c("theta", "lifespan")
initial.values <- function() list(theta = runif(1,0,1))
n.iter <- 5000
n.burnin <- 1000
n.chains <- 3
mcmc.output <- nimbleMCMC(code = model,
                          data = my.data,
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter,
                          nburnin = n.burnin,
                          nchains = n.chains)
MCMCsummary(object = mcmc.output, round = 2)
```

With `nimbleFunctions`, you can mimic basic R syntax, do linear algebra (e.g. compute eigenvalues), operate on vectors and matrices (e.g. inverse a matrix), use logical operators (e.g. and/or) and flow control (e.g. if-else). There is also a long list of common and less common distributions that can be used with `nimbleFunctions`. 

To learn everything you need to know on writing `nimbleFunctions`, make sure to read chapter 11 of the NIMBLE manual at <https://r-nimble.org/manual/cha-RCfunctions.html>. 

### Calling R/C++ functions {#callrfninnimble}

If you're like me, and too lazy to write your own functions, you can rely on the scientific community and use existing C, C++ or R code. The trick is to write a `nimbleFunction` that wraps access to that code which can then be used by NIMBLE. As an example, imagine you'd like to use an R function `myfunction()`, either a function you wrote yourself, or a function available in your favorite R package:
```{r}
myfunction <- function(x) {
  -1/log(x)
}
```

Now wrap this function using `nimbleRcall()` or `nimbleExternalCall()` for a C or C++ function:
```{r}
Rmyfunction <- nimbleRcall(prototype = function(x = double(0)){}, 
                           Rfun = 'myfunction',
                           returnType = double(0))
```

In the call to `nimbleRcall()` above, the argument `prototype` specifies inputs (a single numeric value `double(0)`) of the R function `Rfun` that generates outputs `returnType` (a single numeric value `double(0)`).  

Now you can call your R function from a model (or any `nimbleFunctions`):
```{r}
model <- nimbleCode({
  # likelihood
  survived ~ dbinom(theta, released)
  # prior
  theta ~ dunif(0, 1)
  lifespan <- Rmyfunction(theta)
})
```

The rest of the workflow remains the same: 
```{r}
my.data <- list(survived = 19, released = 57)
parameters.to.save <- c("theta", "lifespan")
initial.values <- function() list(theta = runif(1,0,1))
n.iter <- 5000
n.burnin <- 1000
n.chains <- 3
mcmc.output <- nimbleMCMC(code = model,
                          data = my.data,
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter,
                          nburnin = n.burnin,
                          nchains = n.chains)
MCMCsummary(object = mcmc.output, round = 2)
```

Evaluating an R function from within NIMBLE slows down MCMC sampling, but if you can live with it, the cost is easily offset by the convenience of being able to use existing R functions. 

<!-- Another advantage of using `nimbleRcall()` (or `nimbleExternalCall()`) is that you can keep large objects out of your model, so that NIMBLE does not have to handle them in MCMC sampling. These objects should be constants and not change when you run NIMBLE. Letting R manipulating these objects will save you time, usually more than the time you lose by calling R from within NIMBLE. -->

### User-defined distributions

With `nimbleFunctions` you can provide user-defined distributions to NIMBLE. You need to write functions for density (`d`) and simulation (`r`) for your distribution. As an example, we write our own binomial distribution:
```{r}
# density
dmybinom <- nimbleFunction(
  run = function(x = double(0), 
                 size = double(0), 
                 prob = double(0), 
                 log = integer(0, default = 1)) {
    returnType(double(0))
    # compute binomial coefficient = size!/[x! (n-x)!] and take log
    lchoose <- lfactorial(size)-lfactorial(x)-lfactorial(size-x)
    # binomial density function = 
    # size! / [x! (n-x)!] * prob^x * (1-prob)^(size-x) and take log
    logProb <- lchoose + x * log(prob) + (size - x) * log(1 - prob)
    if(log) return(logProb)
    else return(exp(logProb)) 
  })
# simulation using the coin flip method (p. 524 in Devroye 1986)
# note: the n argument is required by NIMBLE 
# but is not used, default is 1
rmybinom <- nimbleFunction(
  run = function(n = integer(0, default = 1),
                 size = double(0),
                 prob = double(0)) {
      x <- 0
      y <- runif(n = size, min = 0, max = 1)
      for (j in 1:size){
        if (y[j] < prob){
          x <- x + 1
        }else{
          x <- x
        }
      }
    returnType(double(0))
    return(x)    
  })
```

You need to define the `nimbleFunctions` in R's global environment for them to be accessed: 
```{r}
assign('dmybinom', dmybinom, .GlobalEnv)
assign('rmybinom', rmybinom, .GlobalEnv)
```

You can try out your function and simulate a single random value (n = 1 by default) from a binomial distribution with size 5 and probability 0.1: 
```{r}
rmybinom(size = 5, prob = 0.1)
```

All set. You can run your workflow:
```{r}
model <- nimbleCode({
 # likelihood
 survived ~ dmybinom(prob = theta, size = released)
 # prior
 theta ~ dunif(0, 1)
})
my.data <- list(released = 57, survived = 19)
initial.values <- function() list(theta = runif(1,0,1))
n.iter <- 5000
n.burnin <- 1000
n.chains <- 3
mcmc.output <- nimbleMCMC(code = model,
                          data = my.data,
                          inits = initial.values,
                          niter = n.iter,
                          nburnin = n.burnin,
                          nchains = n.chains)
MCMCsummary(mcmc.output)
```

Having `nimbleFunctions` offers infinite possibilities to customize your models and algorithms. Besides what we covered already, you can write your own samplers. We will see an example in a minute, but I first need to tell you more about the NIMBLE workflow. 

## Under the hood {#under-the-hood}

So far, you have used `nimbleMCMC()` which runs the default MCMC workflow. This is perfecly fine for most applications. However, in some situations you need to customize the MCMC samplers to improve or speed up convergence. NIMBLE allows you to look under the hood by using a detailed workflow in several steps: `nimbleModel()`, `configureMCMC()`, `buildMCMC()`, `compileNimble()` and `runMCMC()`. Note that `nimbleMCMC()` does all of this at once.

We write the model code, read in data and pick initial values as before:
```{r}
model <- nimbleCode({
  # likelihood
  survived ~ dbinom(theta, released)
  # prior
  theta ~ dunif(0, 1)
  # derived quantity
  lifespan <- -1/log(theta)
})
my.data <- list(survived = 19, released = 57)
initial.values <- list(theta = 0.5)
```

First step is to create the model as an R object (uncompiled model) with `nimbleModel()`:
```{r}
survival <- nimbleModel(code = model,
                        data = my.data,
                        inits = initial.values)
```

You can look at its nodes:
```{r}
survival$getNodeNames()
```

You can look at the values stored at each node:
```{r}
survival$theta
survival$survived
survival$lifespan 
# this is -1/log(0.5)
```

We can also calculate the log-likelihood at the initial value for `theta`:
```{r}
survival$calculate()
# this is dbinom(x = 19, size = 57, prob = 0.5, log = TRUE)
```

The ability in NIMBLE to access the nodes of your model and to evaluate the model likelihood can help you in identifying bugs in your code. For example, if we provide a negative initial value for `theta`, `survival$calculate()` returns NA:
```{r}
survival <- nimbleModel(code = model,
                        data = my.data,
                        inits = list(theta = -0.5))
survival$calculate()
```

As another example, if we convey in the data the information that more animals survived than were released, we'll get an infinity value for the log-likelihood:
```{r}
my.data <- list(survived = 61, released = 57)
initial.values <- list(theta = 0.5)
survival <- nimbleModel(code = model,
                        data = my.data,
                        inits = initial.values)
survival$calculate()
```

As a check that the model is correctly initialized and that your code is without bugs, the call to `model$calculate()` should return a number and not NA or -Inf:
```{r}
my.data <- list(survived = 19, released = 57)
initial.values <- list(theta = 0.5)
survival <- nimbleModel(code = model,
                        data = my.data,
                        inits = initial.values)
survival$calculate()
```

You can obtain the graph of the model as in Figure \@ref(fig:dag-survival) with:
```{r}
survival$plotGraph()
```

Second we compile the model with `compileNimble()`:
```{r}
Csurvival <- compileNimble(survival)
```

With `compileNimble()`, the C++ code is generated, compiled and loaded back into R so that it can be used in R (compiled model):
```{r}
Csurvival$theta
```

Now you have two versions of the model, `survival` is in R and `Csurvival` in C++. Being able to separate the steps of model building and parameter estimation is a strength of NIMBLE. This gives you a lot of flexibility at both steps. For example, imagine you would like to fit your model with maximum likelihood, then you can do it by wrapping your model in an R function that gets the likelihood and maximise this function. Using the C version of the model, you can write:
```{r}
# function for negative log-likelihood to minimize
f <- function(par) {
    Csurvival[['theta']] <- par # assign par to theta 
    ll <- Csurvival$calculate() # update log-likelihood w/ par value
    return(-ll) # return negative log-likelihood
}
# evaluate function at 0.5 and 0.9
f(0.5)
f(0.9)
# minimize function
out <- optimize(f, interval = c(0,1))
round(out$minimum, 2)
```

By maximising the likelihood (or minimising the negative log-likelihood), you obtain the maximum likelihood estimate of animal survival, which is exactly 19 surviving animals over 57 released animals or `r round(19/57, 2)`.

Third we create a MCMC configuration for our model with `configureMCMC()`:
```{r}
survivalConf <- configureMCMC(survival)
```

This steps tells you the nodes that are monitored by default, and the MCMC samplers than have been assigned to them. Here `theta` is monitored, and samples from its posterior distribution are simulated with a random walk sampler similar to the Metropolis sampler we coded in the previous chapter in Section \@ref(metropolis-algorithm). 

To monitor `lifespan` in addition to `theta`, you write:
```{r}
survivalConf$addMonitors(c("lifespan"))
survivalConf
```

Third, we create a MCMC function with `buildMCMC()` and compile it with `compileNimble()`:
```{r}
survivalMCMC <- buildMCMC(survivalConf)
CsurvivalMCMC <- compileNimble(survivalMCMC, project = survival)
```

Note that models and `nimbleFunctions` need to be compiled before they can be used to specify a project.

Fourth, we run NIMBLE with `runMCMC()`:
```{r cache = F}
n.iter <- 5000
n.burnin <- 1000
samples <- runMCMC(mcmc = CsurvivalMCMC, 
                   niter = n.iter,
                   nburnin = n.burnin)
```

We run a single chain but `runMCMC()` allows you to use multiple chains as with `nimbleMCMC()`. 

You can look into `samples` which contains values simulated from the posterior distribution of the parameters we monitor:
```{r}
head(samples)
```

From here, you can obtain numerical summaries with `samplesSummary()` (or `MCMCvis::MCMCsummary()`):
```{r}
samplesSummary(samples)
```

I have summarized the steps above in the box below. 


:::: {.blackbox data-latex=""}
**Detailed NIMBLE workflow:**
```{r, eval = FALSE}
# model building
model <- nimbleCode({
  survived ~ dbinom(theta, released) # likelihood
  theta ~ dunif(0, 1) # prior
  lifespan <- -1/log(theta) # derived quantity
})
# read in data
my.data <- list(released = 57, survived = 19)
# pick initial values
initial.values <- function() list(theta = runif(1,0,1))
# create model as an R object (uncompiled model)
survival <- nimbleModel(code = model,
                        data = my.data,
                        inits = initial.values())
# compile model
Csurvival <- compileNimble(survival)
# create a MCMC configuration
survivalConf <- configureMCMC(survival)
# add lifespan to list of parameters to monitor
survivalConf$addMonitors(c("lifespan"))
# create a MCMC function and compile it
survivalMCMC <- buildMCMC(survivalConf)
CsurvivalMCMC <- compileNimble(survivalMCMC, project=survival)
# specify MCMC details
n.iter <- 5000; n.burnin <- 1000; n.chains <- 2
# run NIMBLE
samples <- runMCMC(mcmc = CsurvivalMCMC, 
                   niter = n.iter,
                   nburnin = n.burnin,
                   nchain = n.chains)
# calculate numerical summaries
MCMCsummary(object = samples, round = 2)
# visualize parameter posterior distribution
MCMCplot(object = samples, params = 'theta')
# check convergence
MCMCtrace(object = samples, params = "theta",
          pdf = FALSE, # no export to PDF
          ind = TRUE) # separate density lines per chain
```
:::


At first glance, using several steps instead of doing all these at once with `nimbleMCMC()` seems odds. Why is it useful? Mastering the whole sequence of steps allows you to play around with samplers, by changing the samplers NIMBLE picks by default, or even writing your own samplers.

## MCMC samplers

### Default samplers {#change-sampler}

What is the default sampler used by NIMBLE in our example? You can answer this question by inspecting the MCMC configuration obtained with `configureMCMC()`:
```{r}
#survivalConf <- configureMCMC(survival)
survivalConf$printSamplers()
```

Now that we have control on the MCMC configuration, let's mess it up. We start by removing the default sampler:
```{r}
survivalConf$removeSamplers(c('theta'))
survivalConf$printSamplers()
```

And we change it for a slice sampler:
```{r}
survivalConf$addSampler(target = c('theta'),
                        type = 'slice')
survivalConf$printSamplers()
```

Now you can resume the workflow:
```{r cache = F}
# create a new MCMC function and compile it:
survivalMCMC2 <- buildMCMC(survivalConf)
# to compile new functions into existing project, 
# we need to reset nimbleFunctions
CsurvivalMCMC2 <- compileNimble(survivalMCMC2, 
                                project = survival,
                                resetFunctions = TRUE) 
# run NIMBLE:
samples2 <- runMCMC(mcmc = CsurvivalMCMC2, 
                    niter = n.iter,
                    nburnin = n.burnin)
# obtain numerical summaries:
samplesSummary(samples2)
```

NIMBLE implements many samplers, and a list is available with `?samplers`. For example, high correlation in (regression) parameters can make independent samplers inefficient. In that situation, block sampling might help which consists in proposing candidate values from a multivariate distribution that acknowledges correlation between parameters. 

<!-- **Say something on how default samplers are chosen by NIMBLE?** -->

### User-defined samplers

Allowing you to code your own sampler is another topic on which NIMBLE thrives. As an example, we focus on the Metropolis algorithm of Section \@ref(metropolis-algorithm) which we coded in R. In this section, we make it a `nimbleFunction` so that we can use it within our model: 
```{r}
my_metropolis <- nimbleFunction(
  name = 'my_metropolis', # fancy name for our MCMC sampler
  contains = sampler_BASE,
  setup = function(model, mvSaved, target, control) {
    # i) get dependencies for 'target' in 'model'
    calcNodes <- model$getDependencies(target) 
    # ii) get sd of proposal distribution
    scale <- control$scale 
  },
  run = function() {
    # (1) log-lik at current value
    initialLP <- model$getLogProb(calcNodes) 
    # (2) current parameter value
    current <- model[[target]] 
    # (3) logit transform
    lcurrent <- log(current / (1 - current))
    # (4) propose candidate value
    lproposal <- lcurrent  + rnorm(1, mean = 0, scale) 
    # (5) back-transform
    proposal <- plogis(lproposal)
    # (6) plug candidate value in model 
    model[[target]] <<- proposal 
    # (7) log-lik at candidate value
    proposalLP <- model$calculate(calcNodes)
    # (8) compute lik ratio on log scale
    lMHR <- proposalLP - initialLP 
    # (9) spin continuous spinner and compare to ratio
    if(runif(1,0,1) < exp(lMHR)) { 
      # (10) if candidate value is accepted, update current value
      copy(from = model, to = mvSaved, nodes = calcNodes, 
           logProb = TRUE, row = 1)
    } else {
      ## (11) if candidate value is accepted, keep current value
      copy(from = mvSaved, to = model, nodes = calcNodes, 
           logProb = TRUE, row = 1)
    }
  },
  methods = list(
    reset = function() {}
  )
)
```

Compared to `nimbleFunctions` we wrote earlier, `my_metropolis()` contains a `setup` function which i) gets the dependencies of the parameter to update in the `run` function with Metropolis, the target node, that would be `theta` in our example and ii) extracts control parameters, that would be `scale` the standard deviation of the proposal distribution in our example. Then the `run` function implements the steps of the Metropolis algorithm: (1) get the log-likelihood function evaluated at the current value, (2) get the current value, (3) apply the logit transform to it, (4) propose a candidate value by perturbing the current value with some normal noise controled by the standard deviation `scale`, (5) back-transform the candidate value and (6) plug it in the model, (7) calculate the log-likelihood function at the candidate value, (8) compute the Metropolis ratio on the log scale, (9) compare output of a spinner and the Metropolis ratio to decide whether to (10) accept the candidate value and copy from the model to `mvSaved` or (11) reject it and keep the current value by copying from `mvSaved` to the model. Because this `nimbleFunction` is to be used as a MCMC sampler, several constraints need to be respected like having a `contains = sampler_BASE` statement or using the four arguments `model`, `mvSaved`, `target` and `control` in the `setup` function. Of course, NIMBLE implements a more advanced and efficient version of the Metropolis algorithm, you can look into it at <https://github.com/cran/nimble/blob/master/R/MCMC_samplers.R#L184>. 

Now that we have our user-defined MCMC algorithm, we can change the default sampler for our new sampler as in Section \@ref(change-sampler). We start from scratch:
```{r}
model <- nimbleCode({
  # likelihood
  survived ~ dbinom(theta, released)
  # prior
  theta ~ dunif(0, 1)
})
my.data <- list(survived = 19, released = 57)
initial.values <- function() list(theta = runif(1,0,1))
survival <- nimbleModel(code = model, 
                        data = my.data, 
                        inits = initial.values())
Csurvival <- compileNimble(survival)
survivalConf <- configureMCMC(survival)
```

We print the samplers used by default, remove the default sampler for `theta`, replace it with our `my_metropolis()` sampler with the standard deviation of the proposal distribution set to 0.1, and print again to make sure NIMBLE now uses our new sampler:
```{r}
survivalConf$printSamplers()
survivalConf$removeSamplers(c('theta'))
survivalConf$addSampler(target = 'theta', 
                        type = 'my_metropolis', 
                        control = list(scale = 0.1)) 
# scale is standard deviation of proposal distribution
survivalConf$printSamplers()
```

The rest of the workflow is unchanged:
```{r cache = F}
survivalMCMC <- buildMCMC(survivalConf)
CsurvivalMCMC <- compileNimble(survivalMCMC, 
                               project = survival)
samples <- runMCMC(mcmc = CsurvivalMCMC, 
                   niter = 5000, 
                   nburnin = 1000)
samplesSummary(samples)
```

You can re-run the analysis by setting the standard deviation of the proposal to different values, say 1 and 10, and compare the results to traceplots we obtained with our R implementation of the Metropolis algorithm in the previous chapter:
```{r traceown, echo = FALSE}
# standard deviation of proposal is 0.1
scale <- 0.1
Rmodel <- nimbleModel(code = model, data = my.data, inits = initial.values())
conf <- configureMCMC(Rmodel, monitors = c('theta'), print = FALSE)
conf$removeSamplers(c('theta'))
conf$addSampler(target = 'theta', type = 'my_metropolis', control = list(scale = scale))
Rmcmc <- buildMCMC(conf)
out <- compileNimble(list(model = Rmodel, mcmc = Rmcmc))
Cmcmc <- out$mcmc
samples_sd01 <- runMCMC(Cmcmc, niter = 10000, nburnin = 9000, progressBar = FALSE)
# standard deviation of proposal is 1
scale <- 1
Rmodel <- nimbleModel(code = model, data = my.data, inits = initial.values())
conf <- configureMCMC(Rmodel, monitors = c('theta'), print = FALSE)
conf$removeSamplers(c('theta'))
conf$addSampler(target = 'theta', type = 'my_metropolis', control = list(scale = scale))
Rmcmc <- buildMCMC(conf)
out <- compileNimble(list(model = Rmodel, mcmc = Rmcmc))
Cmcmc <- out$mcmc
samples_sd1 <- runMCMC(Cmcmc, niter = 10000, nburnin = 9000, progressBar = FALSE)
# standard deviation of proposal is 10
scale <- 10
Rmodel <- nimbleModel(code = model, data = my.data, inits = initial.values())
conf <- configureMCMC(Rmodel, monitors = c('theta'), print = FALSE)
conf$removeSamplers(c('theta'))
conf$addSampler(target = 'theta', type = 'my_metropolis', control = list(scale = scale))
Rmcmc <- buildMCMC(conf)
out <- compileNimble(list(model = Rmodel, mcmc = Rmcmc))
Cmcmc <- out$mcmc
samples_sd10 <- runMCMC(Cmcmc, niter = 10000, nburnin = 9000, progressBar = FALSE)
# trace plot for scenario with standard deviation 0.1
plot01 <- samples_sd01 %>%
  as_tibble() %>%
  ggplot() + 
  aes(x = 9001:10000, y = theta) +
  geom_line() + 
  labs(x = "iterations", title = "scale = 0.1")
# trace plot for scenario with standard deviation 1
plot1 <- samples_sd1 %>%
  as_tibble() %>%
  ggplot() + 
  aes(x = 9001:10000, y = theta) +
  geom_line() + 
  labs(x = "iterations", title = "scale = 1")
# trace plot for scenario with standard deviation 10
plot10 <- samples_sd10 %>%
  as_tibble() %>%
  ggplot() + 
  aes(x = 9001:10000, y = theta) +
  geom_line() + 
  labs(x = "iterations", title = "scale = 10")
# Assemble all three trace plots
library(patchwork)
plot01 + plot1 + plot10
```

## Tips and tricks

Before closing this chapter on NIMBLE, I thought it'd be useful to have a section gathering a few tips and tricks that would make your life easier. 

<!-- **These are my tips and tricks, NIMBLE users, I'd be happy to hear yours: [email me](mailto:olivier.gimenez@cefe.cnrs.fr), [edit the chapter](https://github.com/oliviergimenez/banana-book/edit/master/nimble.Rmd) or [file an issue](https://github.com/oliviergimenez/banana-book/issues) on GitHub.** -->

### Precision vs standard deviation

In other software like JAGS, the normal distribution is parameterized with mean `mu` and a parameter called precision, often denoted `tau`, the inverse of the variance you are used to. Say we use a normal prior on some parameter `epsilon` with `epsilon ~ dnorm(mu, tau)`. We'd like this prior to be vague, therefore `tau` should be small, say 0.01 so that the variance of the normal distribution is large, 1/0.01 = 100 here. This subtlety is the source of problems (and frustration) when you forget that the second parameter is precision and use `epsilon ~ dnorm(mu, 100)`, because then the variance is actually 1/100 = 0.01 and the prior is very informative, and peaked on `mu`. In NIMBLE you can use this parameterisation as well as the more natural parameterisation `epsilon ~ dnorm(mu, sd = 100)` which avoids confusion. 

### Indexing

NIMBLE does not guess the dimensions of objects. In other software like JAGS you can write `sum.x <- sum(x[])` to calculate the sum over all components of `x`. In NIMBLE you need to write `sum.x <- sum(x[1:n])` to sum the components of `x` from 1 up to n. Specifying dimensions can be annoying, but I find it useful as it forces me to think of what I am doing and to keep my code self-explaining. 

### Faster compilation

You might have noticed that compilation in NIMBLE takes time. When you have large models (with lots of nodes), compilation can take forever. You can set `calculate = FALSE` in `nimbleModel()` to disable the calculation of all deterministic nodes and log-likelihood. The downside of not doing the `calculate()`, is that you might not be able to identify issues that could help you save time in the long run. You can also use `useConjugacy = FALSE` in `configureMCMC()` to disable the search for conjugate samplers. With the animal survival example, you would do:
```{r cache = F}
model <- nimbleCode({
  # likelihood
  survived ~ dbinom(theta, released)
  # prior
  theta ~ dunif(0, 1)
})
my.data <- list(survived = 19, released = 57)
initial.values <- function() list(theta = runif(1,0,1))
# first tip is calculate = FALSE
survival <- nimbleModel(code = model, 
                        data = my.data, 
                        inits = initial.values(),
                        calculate = FALSE) 
Csurvival <- compileNimble(survival)
survivalConf <- configureMCMC(survival)
# second tip is useConjugacy = FALSE
survivalMCMC <- buildMCMC(survivalConf, useConjugacy = FALSE) 
CsurvivalMCMC <- compileNimble(survivalMCMC, 
                               project = survival)
samples <- runMCMC(mcmc = CsurvivalMCMC, 
                   niter = 5000, 
                   nburnin = 1000)
samplesSummary(samples)
```

### Updating MCMC chains

Sometimes it is useful to run your MCMC chains a little bit longer to improve convergence. Re-starting from the run in previous section, you can use:
```{r}
niter_ad <- 6000
CsurvivalMCMC$run(niter_ad, reset = FALSE)
```

Then you can extract the matrix of previous MCMC samples augmented with new ones and obtain numerical summaries:
```{r}
more_samples <- as.matrix(CsurvivalMCMC$mvSamples)
samplesSummary(more_samples)
```

You can check that `more_samples` contains `r length(more_samples)` samples, 4000 from the call to `runMCMC()` plus `r niter_ad` additional samples. Note that this only works if you are using the detailed NIMBLE workflow. It does not work with the `nimbleMCMC()` wrapper function.

### Reproducibility {#tipreproducibility}

```{r echo = FALSE}
model <- nimbleCode({
  # likelihood
  survived ~ dbinom(theta, released)
  # prior
  theta ~ dunif(0, 1)
})
my.data <- list(survived = 19, released = 57)
initial.values <- list(list(theta = 0.1),
                       list(theta = 0.5),
                       list(theta = 0.9))
```

If you want your results to be reproducible, you can control the state of R the random number generator with the `setSeed` argument in functions `nimbleMCMC()` and `runMCMC()`. Going back to the animal survival example, you can check that two calls to `nimbleMCMC()` give the same results when `setSeed` is set to the same value. Note that we need to specify a seed for each chain, hence a vector of three components here: 
```{r cache = F}
# first call to nimbleMCMC()
mcmc.output1 <- nimbleMCMC(code = model,
                           data = my.data,
                           inits = initial.values,
                           niter = 5000,
                           nburnin = 1000,
                           nchains = 3,
                           summary = TRUE,
                           setSeed = c(2024, 2025, 2026))
# second call to nimbleMCMC()
mcmc.output2 <- nimbleMCMC(code = model,
                           data = my.data,
                           inits = initial.values,
                           niter = 5000,
                           nburnin = 1000,
                           nchains = 3,
                           summary = TRUE,
                           setSeed = c(2024, 2025, 2026))
# outputs from both calls are the same
mcmc.output1$summary$all.chains
mcmc.output2$summary$all.chains
```

Note that to make your workflow reproducible, you need to set the seed not only within the `nimbleMCMC()` call, but also before setting your initial values if you are using a randomized function for that. 

### Parallelization

To speed up your analyses, you can run MCMC chains in parallel. This is what the package `jagsUI` accomplishes for JAGS users. Here, we use the `parallel` package for parallel computation:
```{r}
library(parallel)
```

First you create a cluster using the total amount of cores you have but one to make sure your computer can go on working:
```{r}
nbcores <- detectCores() - 1
my_cluster <- makeCluster(nbcores)
```

Then you wrap your workflow in a function to be run in parallel:
```{r}
workflow <- function(seed, data) {
  
  library(nimble)
  
  model <- nimbleCode({
    # likelihood
    survived ~ dbinom(theta, released)
    # prior
    theta ~ dunif(0, 1)
  })
  
  set.seed(123) # for reproducibility
  initial.values <- function() list(theta = runif(1,0,1))
  
  survival <- nimbleModel(code = model, 
                          data = data, 
                          inits = initial.values())
  Csurvival <- compileNimble(survival)
  survivalMCMC <- buildMCMC(Csurvival)
  CsurvivalMCMC <- compileNimble(survivalMCMC)
  
  samples <- runMCMC(mcmc = CsurvivalMCMC, 
                     niter = 5000, 
                     nburnin = 1000,
                     setSeed = seed)
  
  return(samples)
}
```

Now we run the code using `parLapply()`, which uses cluster nodes to execute our workflow:
```{r}
output <- parLapply(cl = my_cluster, 
                    X = c(2022, 666),
                    fun = workflow, 
                    data = list(survived = 19, released = 57))
```

In the call to `parLapply`, we specify `X = c(2022, 666)` to ensure reproducibility. We use two alues 2022 and 666 to set the seed in `workflow()`, which means we run two instances of our workflow, or two MCMC chains. Note that we also have a line `set.seed(123)` in the `workflow()` function to ensure reproducibility while drawing randomly initial values. 

It's good practice to close the cluster with `stopCluster()` so that processes do not continue to run in the background and slow down other processes:
```{r}
stopCluster(my_cluster)
```

By inspecting the results, you can see that the object `output` is a list with two components, one for each MCMC chain:
```{r}
str(output)
```

Eventually, you can obtain numerical summaries:
```{r}
MCMCsummary(output)
```

### Incomplete and incorrect initialization

When you run `nimbleMCMC()` or `nimbleModel()`, you may get warnings thrown at you by NIMBLE like 'This model is not fully initialized' or 'value is NA or NaN even after trying to calculate'. This is not necessarily an error, but it 'reflects missing values in model variables' (incomplete initialization). In this situation, NIMBLE will initialize nodes with NAs by drawing from priors, and it will work or not. When possible, I try to initialize all nodes (full initialization). The process can be a bit of a headache, but it helps understanding the model structure better. Going back to our animal survival example, let's purposedly forget to provide an initial value for `theta`:
```{r}
model <- nimbleCode({
  # likelihood
  survived ~ dbinom(theta, released)
  # prior
  theta ~ dunif(0, 1)
})
#initial.values <- list(theta = runif(1,0,1))
survival <- nimbleModel(code = model, 
                        data = list(survived = 19, released = 57))
```

To see which variables are not initialized, we use `initializeInfo()`:
```{r}
# survival$calculate() # gives NA
survival$initializeInfo()
```

Now that we know `theta` was not initialized, we can fix the issue and resume our workflow:
```{r cache = F}
survival$theta <- 0.5 # assign initial value to theta
survival$calculate() 

Csurvival <- compileNimble(survival)
survivalMCMC <- buildMCMC(Csurvival)
CsurvivalMCMC <- compileNimble(survivalMCMC)

samples <- runMCMC(mcmc = CsurvivalMCMC, 
                   niter = 5000, 
                   nburnin = 1000)

samplesSummary(samples)
```

When working with larger models, it can happen that NIMBLE's internal simulation produces initial values for different parameters (nodes) that are incompatible with each other and violate certain model assumptions. If we go ahead and run the MCMC on a model where this is the case, a range of different warning messages may appear to indicate the problem. At first, they may not seem very intuitive (e.g. "Log probability is -Inf", "Log probability is NaN", "Slice sampler reached the maximum number of contractions", etc.), but they are signals that you may want to double-check our initialization. 

### Vectorization

Vectorization is the process of replacing a loop by a vector so that instead of processing a single value at a time, you process a set of values at once. As an example, instead of writing:
```{r eval = FALSE}
for(i in 1:n){ 
  x[i] <- mu + epsilon[i] 
}
```

you would write:
```{r eval = FALSE}
x[1:n] <- mu + epsilon[1:n]
```

Vectorization can make your code more efficient by manipulating one vector node `x[1:n]` instead of `n` nodes `x[1]`, ..., `x[n]`. As an example, you may have a look to the vectorized flavor of the binomial distribution written by Pierre Dupont at <https://github.com/nimble-dev/nimbleSCR/blob/master/nimbleSCR/R/dbinom_vector.R>. Note that per now, vectorization only works for deterministic nodes (relationships with `<-`) but not stochastic ones (relationships with `~`).

<!-- Example suggestion: how about modellign the effect of an annual covariate on annual survival probability? -->

## Summary

+ NIMBLE is an R package that implements for you MCMC algorithms to generate samples from the posterior distribution of model parameters. You only have to specify a likelihood and priors using the BUGS language to apply the Bayes theorem.

+ NIMBLE is more than just another MCMC engine. It provides a programming environment so that you have full control when building models and estimating parameters. 

+ At the core of NIMBLE are `nimbleFunctions` which you can write and compile for faster computation. With `nimbleFunctions` you can mimic basic R syntax, work with vectors and matrices, use logical operators and flow control, and specify many distributions.

+ There are two workflows to run NIMBLE. In most situations, `nimbleMCMC()` will serve you well. When you need more control, you can adopt a detailed workflow with `nimbleModel()`, `configureMCMC()`, `buildMCMC()`, `compileNimble()` and `runMCMC()`.

+ By having full control of the workflow, you can change default MCMC samplers and even write your own samplers.

## Suggested reading

In this chapter, I have only scratched the surface of what NIMBLE is capable of. Below is a list of pointers that should help you going further with NIMBLE. 

- The NIMBLE folks make a lot of useful resources available through the official website [https://r-nimble.org](https://r-nimble.org). 

- The NIMBLE manual [https://r-nimble.org/manual/cha-welcome-nimble.html](https://r-nimble.org/manual/cha-welcome-nimble.html) reads like a book with clear explanations and relevant examples. 

- You can learn a lot by going through examples at [https://r-nimble.org/examples.html](https://r-nimble.org/examples.html) and training material from NIMBLE workshops at [https://github.com/nimble-training](https://github.com/nimble-training).

- You can keep the NIMBLE cheatsheet [https://r-nimble.org/NimbleCheatSheet.pdf](https://r-nimble.org/NimbleCheatSheet.pdf) near you to remind yourself of the workflow, how to write and use models, or which functions and distributions are available.

- If you have questions, feel free to get in touch with the community of NIMBLE users by emailing the discussion group [https://groups.google.com/forum/#!forum/nimble-users](https://groups.google.com/forum/#!forum/nimble-users). This is a great place to learn, and folks who take the time to answer questions are kind and provide constructive answers. When possible, make sure to provide a reproducible example illustrating your problem. 

- You can cite the following reference when using NIMBLE in a publication:

> de Valpine, P., D. Turek, C. J. Paciorek, C. Anderson-Bergman, D. Temple Lang, and R. Bodik (2017). Programming With Models: Writing Statistical Algorithms for General Model Structures With NIMBLE. *Journal of Computational and Graphical Statistics* **26** (2): 403–13.

- Last, the packages to process NIMBLE results are developed by people whose work should be acknowledged: see @youngflesh2018mcmcvis for `MCMCvis`, @turek2022basicmcmcplots for `basicMCMCplots`, @gabry2022bayesplot for `bayesplot` and @fernandez2016ggmcmc for `ggmcmc`.

<!--chapter:end:2-nimble.Rmd-->

```{r include=FALSE, cache=FALSE}
# packages
library(tidyverse)
theme_set(theme_light(base_size = 14))
library(nimble)
library(MCMCvis)
library(magick)
library(pdftools)
library(wesanderson)
library(RColorBrewer)
library(patchwork)
library(emo)
#library(nimbleEcology)
#library(basicMCMCplots)

# R options
options(width = 60)

# chunk options
knitr::opts_chunk$set(
  comment = "##",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE
  )
```
# Hidden Markov models {#hmmcapturerecapture}

## Introduction

In this third chapter, you will learn the basics on Markov models and how to fit them to longitudinal data using NIMBLE. In real life however, individuals may go undetected and their status be unknown. You will also learn how to manipulate the extension of Markov models to hidden states, so-called hidden Markov models. 

## Longitudinal data

Let's get back to our survival example, and denote $z_i$ the state of individual $i$ with $z_i = 1$ if alive and $z_i = 0$ if dead. We have a total of $z = \displaystyle{\sum_{i=1}^{n}{z_i}}$ survivors out of $n$ released animals with winter survival probability $\phi$. Our model so far is a combination of a binomial likelihood and a Beta prior with parameters 1 and 1, which is also a uniform distribution between 0 and 1. It can be written as:

\begin{align*}
   z &\sim \text{Binomial}(n, \phi) &\text{[likelihood]}
   \\
  \phi &\sim \text{Beta}(1, 1) &\text{[prior for }\phi \text{]} \\
\end{align*}

Because the binomial distribution is just a sum of independent Bernoulli outcomes, you can rewrite this model as:

\begin{align*}
   z_i &\sim \text{Bernoulli}(\phi), \; i = 1, \ldots, N &\text{[likelihood]}
   \\
  \phi &\sim \text{Beta}(1, 1) &\text{[prior for }\phi \text{]} \\
\end{align*}

It is like flipping a coin for each individual and get a survivor with probability $\phi$.

In this set up, we consider a single winter. But for many species, we need to collect data on the long term to get a representative estimate of survival. Therefore what if we had say $T = 5$ winters?

Let us denote $z_{i,t} = 1$ if individual $i$ alive at winter $t$, and $z_{i,t} = 2$ if dead. Then longitudinal data look like in the table below. Each row is an individual $i$, and columns are for winters $t$, or sampling occasions. Variable $z$ is indexed by both $i$ and $t$, and takes value 1 if individual $i$ is alive in winter $t$, and 2 otherwise.

```{r echo = FALSE}
# 1 = alive, 2 = dead
nind <- 57
nocc <- 5
phi <- 0.8 # survival probability
delta <- c(1,0) # (Pr(alive at t = 1), Pr(dead at t = 1))
Gamma <- matrix(NA, 2, 2) # transition matrix
Gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
Gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
Gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
Gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
z <- matrix(NA, nrow = nind, ncol = nocc)
set.seed(2022)
for (i in 1:nind){
  z[i,1] <- nimble::rcat(n = 1, prob = delta) # 1 for sure
  for (t in 2:nocc){
    z[i,t] <- nimble::rcat(n = 1, prob = Gamma[z[i,t-1],1:2]) 
  }
}
colnames(z) <- paste0("winter ", 1:nocc)
z %>%
  as_tibble() %>%
  add_column(id = 1:nind, .before = "winter 1") #%>%
#  kableExtra::kable() %>%
#  kableExtra::scroll_box(width = "100%", height = "400px")
#  kableExtra::kable_styling(font_size = 8,
#                            latex_options = "scale_down")
```

## A Markov model for longitudinal data

Let's think of a model for these data. The objective remains the same, estimating survival. To build this model, we'll make assumptions, go through its components and write down its likelihood. Note that we have already encountered Markov models in Section \@ref(markovmodelmcmc).

### Assumptions

First, we assume that the state of an animal in a given winter, alive or dead, is only dependent on its state the winter before. In other words, the future depends only on the present, not the past. This is a Markov process.

Second, if an animal is alive in a given winter, the probability it survives to the next winter is $\phi$. The probability it dies is $1 - \phi$.

Third, if an animal is dead a winter, it remains dead, unless you believe in zombies.

Our Markov process can be represented this way:

```{r, engine = 'tikz', echo = FALSE}
\usetikzlibrary{arrows, fit, positioning, automata}
\begin{tikzpicture}[node distance = 2cm]
\tikzset{state/.style = {circle, draw, minimum size = 30pt, scale = 3, line width=1pt}}
\node [state,fill=lightgray!75] (6) [] {$z_{i,3}$};
\node [state,fill=lightgray!75] (5) [left = 20mm of 6] {$z_{i,2}$};
\node [state,fill=lightgray!75] (4) [left = 20mm of 5] {$z_{i,1}$};
\node [state,fill=lightgray!75] (7) [right = 20mm of 6] {$z_{i,4}$};
\node [state,fill=lightgray!75] (8) [right = 20mm of 7] {$z_{i,5}$};
\draw[->,black, line width=0.25mm,-latex] (4) to (5);
\draw[->,black, line width=0.25mm,-latex] (5) to (6);
\draw[->,black, line width=0.25mm,-latex] (6) to (7);
\draw[->,black, line width=0.25mm,-latex] (7) to (8);
\end{tikzpicture}
```

An example of this Markov process is, for example:

```{r, engine = 'tikz', echo = FALSE}
\usetikzlibrary{arrows, fit, positioning, automata}
\begin{tikzpicture}[node distance = 2cm]
\tikzset{state/.style = {circle, draw, minimum size = 30pt, scale = 3, line width=1pt}}
\node [state,fill=lightgray!75] (6) [] {$1$};
\node [state,fill=lightgray!75] (5) [left = 20mm of 6] {$1$};
\node [state,fill=lightgray!75] (4) [left = 20mm of 5] {$1$};
\node [state,fill=lightgray!75] (7) [right = 20mm of 6] {$2$};
\node [state,fill=lightgray!75] (8) [right = 20mm of 7] {$2$};
\draw[->,black, line width=0.25mm,-latex] (4) -- node[above=3mm, align=center] {\huge $\phi$} (5);
\draw[->,black, line width=0.25mm,-latex] (5) -- node[above=3mm, align=center] {\huge $\phi$} (6);
\draw[->,black, line width=0.25mm,-latex] (6) -- node[above=3mm, align=center] {\huge $1 - \phi$} (7);
\draw[->,black, line width=0.25mm,-latex] (7) -- node[above=3mm, align=center] {\huge 1} (8);
\end{tikzpicture}
```

Here the animal remains alive over the first two time intervals $(z_{i,1} = z_{i,2} = z_{i,3} = 1)$ with probability $\phi$ until it dies over the fourth time interval $(z_{i,4} = 2)$ with probability $1-\phi$ then remains dead from then onwards $(z_{i,5} = 2)$ with probability 1. 

### Transition matrix

You might have figured it out already (if not, not a problem), the core of our Markov process is made of transition probabilities between states alive and dead. For example, the probability of transitioning from state alive at $t-1$ to state alive at $t$ is $\Pr(z_{i,t} = 1 | z_{i,t-1} = 1) = \gamma_{1,1}$. It is the survival probability $\phi$. The probability of dying over the interval $(t-1, t)$ is $\Pr(z_{i,t} = 2 | z_{i,t-1} = 1) = \gamma_{1,2} = 1 - \phi$. Now if an animal is dead at $t-1$, then $\Pr(z_t = 1 | z_{t-1} = 2) = 0$ and $\Pr(z_{i,t} = 2 | z_{i,t-1} = 2) = 1$. 

We can gather these probabilities of transition between states from one occasion to the next in a matrix, say $\Gamma$, which we will call the transition matrix:

\begin{align*}
\Gamma =
\left(\begin{array}{cc}
\gamma_{1,1} & \gamma_{1,2}\\
\gamma_{2,1} & \gamma_{2,2}
\end{array}\right) =
\left(\begin{array}{cc}
\phi & 1 - \phi\\
0 & 1
\end{array}\right)
\end{align*}

To try and remember that the states at $t-1$ are in rows, and the states at $t$ are in columns, I will often write:

$$\begin{matrix}
& \\
\Gamma =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    z_t=1 & z_t=2 \\[0.3em] \hdashline
\phi & 1-\phi \\
0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \end{matrix} } \right )
    \begin{matrix}
    z_{t-1}=1 \; \mbox{(alive)} \\ z_{t-1}=2 \; \mbox{(dead)}
    \end{matrix}
\end{matrix}$$



Take the time you need to navigate through this matrix, and get familiar with it. For example, you may start alive at $t$ (first row) then end up dead at $t+1$ (first column) with probability $1-\phi$.

### Initial states

A Markov process has to start somewhere. We need the probabilities of initial states, i.e. the states of an individual at $t = 1$. We will gather the probability of being in each state (alive or 1 and dead or 2) in the first winter in a vector. We will use $\delta = \left(\Pr(z_{i,1} = 1), \Pr(z_{i,1} = 2)\right)$. For simplicity, we will assume that all individuals are marked and released in the first winter, hence alive when first captured, which means that they are all in state alive or 1 for sure. Therefore we have $\delta = \left(1, 0\right)$.

### Likelihood

Now that we have built a Markov model, we need its likelihood to apply the Bayes theorem. The likelihood is the probability of the data, given the model. Here the data are the $z$, therefore we need $\Pr(z) = \Pr(z_1, z_2, \ldots, z_{T-2}, z_{T-1}, z_T)$.

We're gonna work backward, starting from the last sampling occasion. Using conditional probabilities, the likelihood can be written as the product of the probability of $z_T$ i.e. you're alive or not on the last occasion given your past history, that is the states at previous occasions, times the probability of your past history:

\begin{align*}
\Pr(z) &= \Pr(z_T, z_{T-1}, z_{T-2}, \ldots, z_1) \color{white}{\Pr(z_{T-1}, z_{T-2},\ldots, z_1) \Pr(z_{T-2}, \ldots, z_1)}\\
                &= \color{blue}{\Pr(z_T | z_{T-1}, z_{T-2},\ldots, z_1) \Pr(z_{T-1}, z_{T-2},\ldots, z_1)} \\
\end{align*}

Then because we have a Markov model, we're memory less, that is the probabilty of next state, here $z_T$, depends only on the current state, that is $z_{T-1}$, and not the previous states:

\begin{align*}
\Pr(z) &= \Pr(z_T, z_{T-1}, z_{T-2}, \ldots, z_1) \color{white}{\Pr(z_{T-1}, z_{T-2},\ldots, z_1) \Pr(z_{T-2}, \ldots, z_1)}\\
                &= \Pr(z_T | z_{T-1}, z_{T-2},\ldots, z_1) \Pr(z_{T-1}, z_{T-2},\ldots, z_1) \\
                &= \color{blue}{\Pr(z_T | z_{T-1})} \Pr(z_{T-1}, z_{T-2},\ldots, z_1) \\
\end{align*}

You can apply the same reasoning to $T-1$. First use conditional probabilities: 

\begin{align*}
\Pr(z) &= \Pr(z_T, z_{T-1}, z_{T-2}, \ldots, z_1) \color{white}{\Pr(z_{T-1}, z_{T-2},\ldots, z_1) \Pr(z_{T-2}, \ldots, z_1)}\\
                &= \Pr(z_T | z_{T-1}, z_{T-2},\ldots, z_1) \Pr(z_{T-1}, z_{T-2},\ldots, z_1) \\
                &= \Pr(z_T | z_{T-1}) \Pr(z_{T-1}, z_{T-2},\ldots, z_1) \\
                &= \Pr(z_T | z_{T-1}) \color{blue}{\Pr(z_{T-1} | z_{T-2}, \ldots, z_1) \Pr(z_{T-2}, \ldots, z_1)}\\
\end{align*}

Then apply the Markovian property:

\begin{align*}
\Pr(z) &= \Pr(z_T, z_{T-1}, z_{T-2}, \ldots, z_1) \color{white}{\Pr(z_{T-1}, z_{T-2},\ldots, z_1) \Pr(z_{T-2}, \ldots, z_1)}\\
                &= \Pr(z_T | z_{T-1}, z_{T-2},\ldots, z_1) \Pr(z_{T-1}, z_{T-2},\ldots, z_1) \\
                &= \Pr(z_T | z_{T-1}) \Pr(z_{T-1}, z_{T-2},\ldots, z_1) \\
                &= \Pr(z_T | z_{T-1}) \Pr(z_{T-1} | z_{T-2}, \ldots, z_1) \Pr(z_{T-2}, \ldots, z_1)\\
                &= \Pr(z_T | z_{T-1}) \color{blue}{\Pr(z_{T-1} | z_{T-2})} \Pr(z_{T-2}, \ldots, z_1)\\
\end{align*}

And so on up to $z_2$. You end up with this expression for the likelihood:

\begin{align*}
\Pr(z) &= \Pr(z_T, z_{T-1}, z_{T-2}, \ldots, z_1) \color{white}{\Pr(z_{T-1}, z_{T-2},\ldots, z_1) \Pr(z_{T-2}, \ldots, z_1)}\\
                &= \Pr(z_T | z_{T-1}, z_{T-2},\ldots, z_1) \Pr(z_{T-1}, z_{T-2},\ldots, z_1) \\
                &= \Pr(z_T | z_{T-1}) \Pr(z_{T-1}, z_{T-2},\ldots, z_1) \\
                &= \Pr(z_T | z_{T-1}) \Pr(z_{T-1} | z_{T-2}, \ldots, z_1) \Pr(z_{T-2}, \ldots, z_1)\\
                &= \Pr(z_T | z_{T-1}) \Pr(z_{T-1} | z_{T-2}) \Pr(z_{T-2}, \ldots, z_1)\\
                &= \ldots \\
                &= \color{blue}{\Pr(z_T | z_{T-1}) \Pr(z_{T-1} | z_{T-2}) \ldots \Pr(z_{2} | z_{1}) \Pr(z_{1})}\\
\end{align*}

This is a product of conditional probabilities of states given previous states, and the probability of initial states $\Pr(z_1)$. Using a more compact notation for the product of conditional probabilities, we get:

\begin{align*}
\Pr(z) &= \Pr(z_T, z_{T-1}, z_{T-2}, \ldots, z_1) \color{white}{\Pr(z_{T-1}, z_{T-2},\ldots, z_1) \Pr(z_{T-2}, \ldots, z_1)}\\
                &= \Pr(z_T | z_{T-1}, z_{T-2},\ldots, z_1) \Pr(z_{T-1}, z_{T-2},\ldots, z_1) \\
                &= \Pr(z_T | z_{T-1}) \Pr(z_{T-1}, z_{T-2},\ldots, z_1) \\
                &= \Pr(z_T | z_{T-1}) \Pr(z_{T-1} | z_{T-2}, \ldots, z_1) \Pr(z_{T-2}, \ldots, z_1)\\
                &= \Pr(z_T | z_{T-1}) \Pr(z_{T-1} | z_{T-2}) \Pr(z_{T-2}, \ldots, z_1)\\
                &= \ldots \\
                &= \Pr(z_T | z_{T-1}) \Pr(z_{T-1} | z_{T-2}) \ldots \Pr(z_{2} | z_{1}) \Pr(z_{1})\\
                &= \color{blue}{\Pr(z_{1}) \prod_{t=2}^T{\Pr(z_{t} | z_{t-1})}}\\
\end{align*}

In the product, you can recognize the transition parameters $\gamma$ we defined above, so that the likelihood of a Markov model can be written as:

\begin{align*}
\Pr(z) &= \Pr(z_T, z_{T-1}, z_{T-2}, \ldots, z_1) \color{white}{\Pr(z_{T-1}, z_{T-2},\ldots, z_1) \Pr(z_{T-2}, \ldots, z_1)}\\
                &= \Pr(z_{1}) \prod_{t=2}^T{\gamma_{z_{t-1},z_{t}}}\\
\end{align*}


<!-- ## Matrix formulation of the likelihood -->

<!-- \begin{align*} -->
<!-- \Pr(\mathbf{z}) &= \Pr(z_T, z_{T-1}, z_{T-2}, \ldots, z_1) \color{white}{\Pr(z_{T-1}, z_{T-2},\ldots, z_1) \Pr(z_{T-2}, \ldots, z_1)}\\ -->
<!--                 &= \Pr(z_{1}) \prod_{t=2}^T{\gamma_{z_{t-1},z_{t}}}\\ -->
<!--                 &= \mathbf{\delta} \; \mathbf{\Gamma} \cdots \mathbf{\Gamma} -->
<!-- \end{align*} -->

### Example

I realise these calculations are a bit difficult to follow. Let's take an example to fix ideas. Let's assume an animal is alive, alive at time 2 then dies at time 3. We have $z = (1, 1, 2)$. What is the contribution of this animal to the likelihood? Let's apply the formula we just derived:

\begin{align*}
\Pr(z = (1, 1, 2)) &= \Pr(z_1 = 1) \; \gamma_{z_{1} = 1, z_{2} = 1} \; \gamma_{z_{2} = 1, z_{3} = 2}\\
                            &= 1 \; \phi \; (1 - \phi).
\end{align*}

The probability of having the sequence alive, alive and dead is the probability of being alive first, then to stay alive, eventually to die. The probability of being alive at first occasion being 1, we have that the contribution of this individual to the likelihood is $\phi (1 - \phi)$.

## Bayesian formulation

Before implementing this model in NIMBLE, we provide a Bayesian formulation of our model. We first note that the likelihood is a product of conditional probabilities of binary events (alive or dead). Usually binary events are associated with the Bernoulli distribution. Here however,  we will use its extension to several outcomes (from a coin with two sides to a dice with more than two faces) known as the categorical distribution. The categorical distribution is a multinomial distribution with a single draw. To get a better idea of how the categorical distribution works, let's simulate from it with the `rcat()` function. Consider for example a random value drawn from a categorical distribution with probability 0.1, 0.3 and 0.6. Think of a dice with three faces, face 1 has probability 0.1 of occurring, face 2 probability 0.3 and face 3 has probability 0.6, the sum of these probabilities being 1. We expect to get a 3 more often than a 2 and rarely a 1: 
```{r}
rcat(n = 1, prob = c(0.1, 0.3, 0.6))
```

Alternatively, you can use the `sample()` function and `sample(x = 1:3, size = 1, replace = FALSE, prob = c(0.1, 0.3, 0.6))`. Here is another example in which we sample 20 times in a categorical distribution with probabilities 0.1, 0.1, 0.4, 0.2 and 0.2, hence a dice with 5 faces:
```{r}
rcat(n = 20, prob = c(0.1, 0.1, 0.4, 0.2, 0.2))
```

In this chapter, you will familiarise yourself with the categorical distribution in binary situations, which should make the transition to more states than just alive and dead smoother in the next chapters. 

Initial state is a categorical random variable with probability $\delta$. That is you have a dice with two faces, or a coin, and you have some probability to be alive, and one minus that probability to be dead. Of course, it you want your Markov chain to start, you'd better say it's alive so that $\delta$ is just $(1,0)$:

\begin{align*}
   z_1 &\sim \text{Categorical}(\delta) &\text{[likelihood, }t = 1 \text{]}\\
\end{align*}

Now the main part is the dynamic of the states. The state $z_t$ at $t$ depends only on the known state $z_{t-1}$ at $t-1$, and is a categorical random variable which probabilities are given by row $z_{t-1}$ of the transition matrix $\Gamma = \gamma_{z_{t-1},z_{t}}$:

\begin{align*}
   z_1 &\sim \text{Categorical}(\delta) &\text{[likelihood, }t = 1 \text{]}\\
   z_t | z_{t-1} &\sim \text{Categorical}(\gamma_{z_{t-1},z_{t}}) &\text{[likelihood, }t > 1 \text{]}\\
\end{align*}

For example, if individual $i$ is alive over $(t-1,t)$ i.e. $z_{t-1} = 1$, we need the first row in $\Gamma$, 

\begin{align*}
\Gamma =
\left(\begin{array}{cc}
\color{blue}{\phi} & \color{blue}{1 - \phi}\\
0 & 1
\end{array}\right)
\end{align*}

that is $\color{blue}{\gamma_{z_{t-1} = 1,z_{t}} = (\phi, 1-\phi)}$ and $z_t | z_{t-1} = 1 \sim \text{Categorical}((\phi, 1-\phi))$. 

Otherwise, if individual $i$ dies over $(t-1,t)$ i.e. $z_{t-1} = 2$, we need the second row in $\Gamma$:

\begin{align*}
\Gamma =
\left(\begin{array}{cc}
\phi & 1 - \phi\\
\color{blue}{0} & \color{blue}{1}
\end{array}\right)
\end{align*}

that is $\color{blue}{\gamma_{z_{t-1} = 2,z_{t}} = (0, 1)}$ and $z_t | z_{t-1} = 2 \sim \text{Categorical}((0, 1))$ (if the individual is dead, it remains dead with probability 1). 

We also need a prior on survival. Without surprise, we will use a uniform distribution between 0 and 1, which is also a Beta distribution with parameters 1 and 1. Overall our model is: 

\begin{align*}
   z_1 &\sim \text{Categorical}(\delta) &\text{[likelihood, }t = 1 \text{]}\\
   z_t | z_{t-1} &\sim \text{Categorical}(\gamma_{z_{t-1},z_{t}}) &\text{[likelihood, }t > 1 \text{]}\\
  \phi &\sim \text{Beta}(1, 1) &\text{[prior for }\phi \text{]} \\
\end{align*}


## NIMBLE implementation

How to implement in NIMBLE the Markov model we just built? We need to put in place a few bricks before running our model. Let's start with the prior on survival, the vector of initial state probabilities and the transition matrix:
```{r eval = FALSE}
markov.survival <- nimbleCode({
  phi ~ dunif(0, 1) # prior
  delta[1] <- 1          # Pr(alive t = 1) = 1
  delta[2] <- 0          # Pr(dead t = 1) = 0
  gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
  gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
  gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
  gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
...
```

Alternatively, you can define vectors and matrices in NIMBLE like you would do it in R. You can write:
```{r eval = FALSE}
markov.survival <- nimbleCode({
  # prior
  phi ~ dunif(0, 1) 
  # vector of initial state probabilities
  delta[1:2] <- c(1, 0) 
  # transition matrix
  gamma[1:2,1:2] <- matrix( c(phi, 0, 1 - phi, 1), nrow = 2) 
...
```

Now there are two important dimensions to our model, along which we need to repeat tasks, namely individual and time. As for time, we describe the successive events of survival using the categorical distribution `dcat()`, say for individual $i$:
```{r eval = FALSE}
z[i,1] ~ dcat(delta[1:2])           # t = 1
z[i,2] ~ dcat(gamma[z[i,1], 1:2])   # t = 2
z[i,3] ~ dcat(gamma[z[i,2], 1:2])   # t = 3
...
z[i,T] ~ dcat(gamma[z[i,T-1], 1:2]) # t = T
```

There is a more efficient way to write this piece of code by using a for loop, that is a sequence of instructions that we repeat. Here, we condense the previous code into:
```{r eval = FALSE}
z[i,1] ~ dcat(delta[1:2])             # t = 1
for (t in 2:T){ # loop over time t
  z[i,t] ~ dcat(gamma[z[i,t-1], 1:2]) # t = 2,...,T
}
```

Now we just need to do the same for all individuals. We use another loop:
```{r eval = FALSE}
for (i in 1:N){ # loop over individual i
  z[i,1] ~ dcat(delta[1:2]) # t = 1
  for (j in 2:T){ # loop over time t
    z[i,j] ~ dcat(gamma[z[i,j-1], 1:2]) # t = 2,...,T
  } # t
} # i
```

Puting everything together, the NIMBLE code for our Markov model is:
```{r}
markov.survival <- nimbleCode({
  phi ~ dunif(0, 1) # prior
  delta[1] <- 1          # Pr(alive t = 1) = 1
  delta[2] <- 0          # Pr(dead t = 1) = 0
  gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
  gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
  gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
  gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
  # likelihood
  for (i in 1:N){ # loop over individual i
    z[i,1] ~ dcat(delta[1:2]) # t = 1
    for (j in 2:T){ # loop over time t
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2]) # t = 2,...,T
    } # t
  } # i
})
```

Note that in this example, $\delta$ is used as a placeholder for more complex models we will build in chapters to come. Here, you could simply write `z[i,1] <- 1`.

Note also that we could replace `dcat()` by `dbern()` everywhere in the code because we have binary events alive/dead. Would it make any difference? Although `dcat()` uses less efficient samplers than `dbern()`, `dcat()` is convenient for model building to accommodate more than two outcomes, a feature that will become handy in the next chapters. 

Now we're ready to resume our NIMBLE workflow. First we read in data. The code I used to simulate the $z$ with survival $\phi = 0.8$ is as follows: 
```{r echo = TRUE, eval = TRUE}
# 1 = alive, 2 = dead
nind <- 57
nocc <- 5
phi <- 0.8 # survival probability
delta <- c(1,0) # (Pr(alive at t = 1), Pr(dead at t = 1))
Gamma <- matrix(NA, 2, 2) # transition matrix
Gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
Gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
Gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
Gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
z <- matrix(NA, nrow = nind, ncol = nocc)
set.seed(2022)
for (i in 1:nind){
  z[i,1] <- rcat(n = 1, prob = delta) # 1 for sure
  for (t in 2:nocc){
    z[i,t] <- rcat(n = 1, prob = Gamma[z[i,t-1],1:2]) 
  }
}
head(z) 
```

Note the resemblance with the model NIMBLE code above. Because we have loops and indices that do not change, we use constants as explained in Section \@ref(start-nimble):
```{r}
my.data <- list(z = z)
my.constants <- list(N = 57, T = 5)
```

We also specify initial values for survival with a function:
```{r}
initial.values <- function() list(phi = runif(1,0,1))
initial.values()
```

There is a single parameter to monitor:
```{r}
parameters.to.save <- c("phi")
parameters.to.save
```

We run 2 chains with 5000 iterations including 1000 iterations as burnin:
```{r}
n.iter <- 5000
n.burnin <- 1000
n.chains <- 2
```

Let's run NIMBLE:
```{r, eval=FALSE}
mcmc.output <- nimbleMCMC(code = markov.survival,
                          constants = my.constants,
                          data = my.data,
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter,
                          nburnin = n.burnin,
                          nchains = n.chains)
```

```{r, message=FALSE, echo = FALSE, cache = F}
mcmc.output <- nimbleMCMC(code = markov.survival,
                          constants = my.constants,
                          data = my.data,
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter,
                          nburnin = n.burnin,
                          nchains = n.chains,
                          progressBar = FALSE)
```

Let's calculate the usual posterior numerical summaries for survival:
```{r}
MCMCsummary(mcmc.output, round = 2)
```

Posterior mean and median are close to $0.8$. This is fortunate since the data was simulated with (actual) survival $\phi = 0.8$. 

## Hidden Markov models

### Capture-recapture data {#capturerecapturedata}


:::: {.blackbox data-latex=""}
Unfortunately, the data with alive and dead states is the data we wish we had. In real life, animals cannot be monitored exhaustively, like humans in a medical trial. This is why we use capture-recapture protocols, in which animals are captured, individually marked, and released alive. Then, these animals may be detected again, or go undetected. Whenever animals go undetected, it might be that they were alive but missed, or because they were dead and therefore could not be detected. This issue is usually referred to as that of imperfect detection. As a consequence of imperfect detection, the Markov process for survival is only partially observed: You know an animal is alive when you detect it, but when an animal goes undetected, whether it is alive or dead is unknown to you. This is where hidden Markov models (HMMs) come in.
::::

Let's get back to the data we had in the previous section. The truth is in $z$ which contains the fate of all individuals with $z = 1$ for alive, and $z = 2$ for dead:

```{r echo = FALSE}
colnames(z) <- paste0("winter ", 1:nocc)
z %>%
  as_tibble() %>%
  add_column(id = 1:nind, .before = "winter 1")
```

Unfortunately, we have only partial access to $z$. What we do observe is $y$ the detections and non-detections. How are $z$ and $y$ connected?

The easiest connection is with dead animals which go undetected for sure. Therefore when an animal is dead i.e. $z = 2$, it cannot be detected, therefore $y = 0$:

```{r echo = FALSE}
z %>%
  as_tibble() %>%
  replace(. == 2, 0) %>%
  add_column(id = 1:nind, .before = "winter 1")
```

Now alive animals may be detected or not. If an animal is alive $z = 1$, it is detected $y = 1$ with probability $p$ or not $y = 0$ with probability $1-p$. In our example, first detection coincides with first winter for all individuals. 

```{r echo = FALSE}
set.seed(2022)
nocc <- 5
nind <- 57
p <- 0.6
phi <- 0.8
delta <- c(1,0)
Gamma <- matrix(NA, 2, 2)
Omega <- matrix(NA, 2, 2)
Gamma[1,1] <- phi # Pr(alive t -> alive t+1)
Gamma[1,2] <- 1 - phi # Pr(alive t -> dead t+1)
Gamma[2,1] <- 0 # Pr(dead t -> alive t+1)
Gamma[2,2] <- 1 # Pr(dead t -> dead t+1)
Omega[1,1] <- 1 - p # Pr(alive t -> non-detected t)
Omega[1,2] <- p # Pr(alive t -> detected t)
Omega[2,1] <- 1 # Pr(dead t -> non-detected t)
Omega[2,2] <- 0 # Pr(dead t -> detected t)
z <- matrix(NA, nrow = nind, ncol = nocc)
y <- z
y[,1] <- 2 # all animals detected in first winter
for (i in 1:nind){
 z[i,1] <- nimble::rcat(n = 1, prob = delta) # 1 for sure
 for (t in 2:nocc){
 z[i,t] <- nimble::rcat(n = 1, prob = Gamma[z[i,t-1],1:2]) 
 y[i,t] <- nimble::rcat(n = 1, prob = Omega[z[i,t],1:2]) 
 }
}
y <- y - 1 # non-detection = 0, detection = 1
colnames(y) <- paste0("winter ", 1:nocc)
nobs <- sum(apply(y,1,sum) != 0)
y <- y[apply(y,1,sum) !=0, ] # remove rows w/ non-detections only
y %>%
 as_tibble() %>%
 add_column(id = 1:nobs, .before = "winter 1")
```

Compare with the previous $z$ table. Some 1's for alive have become 0's for non-detection, other 1's for alive have remained 1's for detection. This $y$ table is what we observe in real life. I hope I have convinced you that to make the connection between observations, the $y$, and true states, the $z$,  we need to describe how observations are made (or emitted in the HMM terminology) from the states.

### Observation matrix

The novelty in HMMs is the link between observations and states. This link is made through observation probabilities. For example, the probability of detecting an animal $i$ at $t$ given it is alive at $t$ is $\Pr(y_{i,t}=2|z_{i,t}=1)=\omega_{1,2}$. It is the detection probability $p$. If individual $i$ is dead at $t$, then it is missed for sure, and  $\Pr(y_{i,t}=1|z_{i,t}=2)=\omega_{2,1}=1$. 

We can gather these observation probabilities into an observation matrix $\Omega$. In rows we have the states alive $z = 1$ and dead $z = 2$, while in columns we have the observations non-detected $y = 1$ and detected $y = 2$ (previously coded 0 and 1 respectively):

\begin{align*}
\Omega =
\left(\begin{array}{cc}
\omega_{1,1} & \omega_{1,2}\\
\omega_{2,1} & \omega_{2,2}
\end{array}\right) =
\left(\begin{array}{cc}
1 - p & p\\
1 & 0
\end{array}\right)
\end{align*}

In survival models we will use throughout this book, we condition the fate of individuals on first detection, which boils down to set the corresponding detection probability to 1. 

The observation matrix is:

$$\begin{matrix}
& \\
\Omega =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    y_t=1 \mbox{ (non-detected)} & y_t=2 \mbox{ (detected)} \\[0.3em] \hdashline
1 - p & p\\
1 & 0\\
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& & \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \end{matrix} } \right )
    \begin{matrix}
    z_{t}=1 \; \mbox{(alive)}\\ z_{t}=2 \; \mbox{(dead)}
    \end{matrix}
\end{matrix}$$

### Hidden Markov model

Our hidden Markov model can be represented this way:

```{r, engine = 'tikz', echo = FALSE}
\usetikzlibrary{arrows, fit, positioning, automata}
\begin{tikzpicture}[node distance = 2cm]
\tikzset{state/.style = {circle, draw, minimum size = 30pt, scale = 3, line width=1pt}}
\node [state,fill=lightgray!75] (6) [] {$z_{3}$};
\node [state,fill=lightgray!75] (5) [left = 20mm of 6] {$z_{2}$};
\node [state,fill=lightgray!75] (4) [left = 20mm of 5] {$z_{1} = 1$};
\node [state,fill=lightgray!75] (7) [right = 20mm of 6] {$z_{4}$};
\node [state,fill=lightgray!75] (8) [right = 20mm of 7] {$z_{5}$};
\node [state,fill=white] (16) [above = 20mm of 6] {$y_{3}$};
\node [state,fill=white] (15) [above = 20mm of 5] {$y_{2}$};
\node [state,fill=white] (14) [above = 20mm of 4] {$y_{1} = 2$};
\node [state,fill=white] (17) [above = 20mm of 7] {$y_{4}$};
\node [state,fill=white] (18) [above = 20mm of 8] {$y_{5}$};
\draw[->,black, line width=0.25mm,-latex] (4) to (5);
\draw[->,black, line width=0.25mm,-latex] (5) to (6);
\draw[->,black, line width=0.25mm,-latex] (6) to (7);
\draw[->,black, line width=0.25mm,-latex] (7) to (8);
\draw[->,black, line width=0.25mm,-latex] (4) to (14);
\draw[->,black, line width=0.25mm,-latex] (5) to (15);
\draw[->,black, line width=0.25mm,-latex] (6) to (16);
\draw[->,black, line width=0.25mm,-latex] (7) to (17);
\draw[->,black, line width=0.25mm,-latex] (8) to (18);
\end{tikzpicture}
```

States $z$ are in gray. Observations $y$ are in white. All individuals are first captured in the first winter $t = 1$, and are therefore all alive $z_1 = 1$ and detected $y_1 = 2$. 


:::: {.blackbox data-latex=""}
A hidden Markov model is just two time series running in parallel. One for the states with the Markovian property, and the other of for the observations generated from the states. HMM are a special case of state-space models in which latent states are discrete.
::::


Have a look to the example below, in which an individual is detected at first sampling occasion, detected again, then missed for the rest of the study. While on occasion $t=3$ that individual was alive $z_3=1$ and went undetected $y_3=1$, on occasions $t=4$ and $t=5$ it went undetected $y_4=y_5=1$ because it was dead $z_4=z_5=2$. Because we condition on first detection, the link between state and observation at $t=1$ is deterministic and $p = 1$. 

```{r, engine = 'tikz', echo = FALSE}
\usetikzlibrary{arrows, fit, positioning, automata}
\begin{tikzpicture}[node distance = 2cm]
\tikzset{state/.style = {circle, draw, minimum size = 30pt, scale = 3, line width=1pt}}
\node [state,fill=lightgray!75] (6) [] {$1$};
\node [state,fill=lightgray!75] (5) [left = 20mm of 6] {$1$};
\node [state,fill=lightgray!75] (4) [left = 20mm of 5] {$1$};
\node [state,fill=lightgray!75] (7) [right = 20mm of 6] {$2$};
\node [state,fill=lightgray!75] (8) [right = 20mm of 7] {$2$};
\node [state,fill=white] (16) [above = 20mm of 6] {$1$};
\node [state,fill=white] (15) [above = 20mm of 5] {$2$};
\node [state,fill=white] (14) [above = 20mm of 4] {$2$};
\node [state,fill=white] (17) [above = 20mm of 7] {$1$};
\node [state,fill=white] (18) [above = 20mm of 8] {$1$};
\draw[->,black, line width=0.25mm,-latex] (4) -- node[above=3mm, align=center] {\huge $\phi$} (5);
\draw[->,black, line width=0.25mm,-latex] (5) -- node[above=3mm, align=center] {\huge $\phi$} (6);
\draw[->,black, line width=0.25mm,-latex] (6) -- node[above=3mm, align=center] {\huge $1 - \phi$} (7);
\draw[->,black, line width=0.25mm,-latex] (7) -- node[above=3mm, align=center] {\huge $1$} (8);
\draw[->,black, line width=0.25mm,-latex] (4) -- node[left=3mm, align=center] {\huge $1$} (14);
\draw[->,black, line width=0.25mm,-latex] (5) -- node[left=3mm, align=center] {\huge $p$} (15);
\draw[->,black, line width=0.25mm,-latex] (6) -- node[left=3mm, align=center] {\huge $1 - p$} (16);
\draw[->,black, line width=0.25mm,-latex] (7) -- node[left=3mm, align=center] {\huge $1$} (17);
\draw[->,black, line width=0.25mm,-latex] (8) -- node[left=3mm, align=center] {\huge $1$} (18);
\end{tikzpicture}
```

### Likelihood {#likelihoodhmm}

In the Bayesian framework, we usually work with the so-called complete likelihood, that is the probability of the observed data $y$ and the latent states $z$ given the parameters of our model, here the survival and detection probabilities $\phi$ and $p$. The complete likelihood for individual $i$ is:

\begin{align*}
\Pr({y}_i, {z}_i) &= \Pr(y_{i,1}, y_{i,2}, \ldots, y_{i,T}, z_{i,1}, z_{i,2}, \ldots, z_{i,T})\\
\end{align*}

Using the definition of a conditional probability, we have:

\begin{align*}
\Pr({y}_i, {z}_i) &= \Pr(y_{i,1}, y_{i,2}, \ldots, y_{i,T}, z_{i,1}, z_{i,2}, \ldots, z_{i,T})\\
                  &= \color{blue}{\Pr(y_{i,1}, y_{i,2}, \ldots, y_{i,T} | z_{i,1}, z_{i,2}, \ldots, z_{i,T}) \Pr(z_{i,1}, z_{i,2}, \ldots, z_{i,T})}\\
\end{align*}

Then by using the independence of the $y$ conditional on the $z$, and the likelihood of a Markov chain, we get that:

\begin{align*}
\Pr({y}_i, {z}_i) &= \Pr(y_{i,1}, y_{i,2}, \ldots, y_{i,T}, z_{i,1}, z_{i,2}, \ldots, z_{i,T})\\
                  &= \Pr(y_{i,1}, y_{i,2}, \ldots, y_{i,T} | z_{i,1}, z_{i,2}, \ldots, z_{i,T}) \Pr(z_{i,1}, z_{i,2}, \ldots, z_{i,T})\\
                &= \color{blue}{\left(\prod_{t=1}^T{\Pr{(y_{i,t} | z_{i,t})}}\right) \left(\Pr(z_{i,1}) \prod_{t=2}^T{\Pr{(z_{i,t} | z_{i,t-1})}}\right)}\\
\end{align*}

Finally, by recognizing the observation and transition probabilities, we have that the complete likelihood for individual $i$ is:

\begin{align*}
\Pr({y}_i, {z}_i) &= \Pr(y_{i,1}, y_{i,2}, \ldots, y_{i,T}, z_{i,1}, z_{i,2}, \ldots, z_{i,T})\\
                  &= \Pr(y_{i,1}, y_{i,2}, \ldots, y_{i,T} | z_{i,1}, z_{i,2}, \ldots, z_{i,T}) \Pr(z_{i,1}, z_{i,2}, \ldots, z_{i,T})\\
                &= \color{blue}{\left(\prod_{t=1}^T{\omega_{z_{i,t}, y_{i,t}}}\right) \left(\Pr(z_{i,1}) \prod_{t=2}^T{\gamma_{z_{i,t-1},z_{i,t}}}\right)}\\
\end{align*}


To obtain the complete likelihood of the whole dataset, we need to multiply this individual likelihood for each animal $\displaystyle{\prod_{i=1}^N{\Pr({y}_i,{z}_i)}}$. When several individuals have the same contribution, calculating their individual contribution only once can greatly reduce the computational burden, as illustrated in Section \@ref(pooled-likelihood).

The Bayesian approach with MCMC methods allows treating the latent states $z_{i,t}$ as if they were parameters, and to be estimated as such. However, the likelihood is rather complex with a large number of latent states $z_{i,t}$, which comes with computational costs and slow mixing. There are situations where the latent states are the focus of ecological inference and need to be estimated (see Suggested reading below). However, if not needed, you might want to get rid of the latent states and rely on the so-called marginal likelihood. By doing so, you can avoid sampling the latent states, focus on the ecological parameters, and often speeds up computations and improves mixing as shown in Section \@ref(marginalization). Actually, you can even estimate the latent states afterwards, as illustrated in Section \@ref(decoding).

<!-- It has a matrix formulation: -->
<!-- \begin{align*} -->
<!-- \Pr(\mathbf{y}) &= \mathbf{\delta} \; \mathbf{\Omega} \; \mathbf{\Gamma} \cdots \mathbf{\Omega} \; \mathbf{\Gamma} \; \mathbf{\Omega} \; \mathbb{1} -->
<!-- \end{align*} -->

<!-- ### Example -->

<!-- Let assume an animal is detected, then missed. We have $\mathbf{y} = (2, 1)$. What is the contribution of this animal to the likelihood? -->

<!-- \begin{align*} -->
<!-- \Pr(\mathbf{y} = (2, 1)) &= \sum_{z_1 = 1}^2 \; \sum_{z_2 = 1}^2 w_{z_1, y_1 = 2} w_{z_2, y_2 = 1} \Pr(z_1) \gamma_{z_1, z_2} \color{white}{\Pr(z_{T-1}, z_{T-2},\ldots, z_1, z_1, z_1, z_1)}\\ -->
<!-- \end{align*} -->

<!-- Let assume an animal is detected, then missed. We have $\mathbf{y} = (2, 1)$. What is the contribution of this animal to the likelihood? -->

<!-- \begin{align*} -->
<!-- \Pr(\mathbf{y} = (2, 1)) &= \sum_{z_1 = 1}^2 \; \sum_{z_2 = 1}^2 w_{z_1, y_1 = 2} w_{z_2, y_2 = 1} \Pr(z_1) \gamma_{z_1, z_2} \color{white}{\Pr(z_{T-1}, z_{T-2},\ldots, z_1, z_1, z_1, z_1)}\\ -->
<!-- &= \sum_{z_1 = 1}^2 \left( w_{z_1, y_1 = 2} w_{z_2 = 1, y_2 = 1} \Pr(z_1) \gamma_{z_1, z_2 = 1} + w_{z_1, y_1 = 2} w_{z_2 = 2, y_2 = 1} \Pr(z_1) \gamma_{z_1, z_2 = 2} \right) \\ -->
<!-- \end{align*} -->

<!-- Let assume an animal is detected, then missed. We have $\mathbf{y} = (2, 1)$. What is the contribution of this animal to the likelihood? -->

<!-- \begin{align*} -->
<!-- \Pr(\mathbf{y} = (2, 1)) &= \sum_{z_1 = 1}^2 \; \sum_{z_2 = 1}^2 w_{z_1, y_1 = 2} w_{z_2, y_2 = 1} \Pr(z_1) \gamma_{z_1, z_2} \color{white}{\Pr(z_{T-1}, z_{T-2},\ldots, z_1, z_1, z_1, z_1)}\\ -->
<!-- &= \sum_{z_1 = 1}^2 \left( w_{z_1, y_1 = 2} w_{z_2 = 1, y_2 = 1} \Pr(z_1) \gamma_{z_1, z_2 = 1} + w_{z_1, y_1 = 2} w_{z_2 = 2, y_2 = 1} \Pr(z_1) \gamma_{z_1, z_2 = 2} \right) \\ -->
<!-- &= w_{z_1 = 1, y_1 = 2} w_{z_2 = 1, y_2 = 1}\delta_1 \gamma_{z_1 = 1, z_2 = 1} + w_{z_1 = 1, y_1 = 2} w_{z_2 = 2, y_2 = 1} \delta_1 \gamma_{z_1 = 1, z_2 = 2} -->
<!-- \end{align*} -->

<!-- Note: $\Pr(z_1 = 1) = \delta_1 = 1$ and $\Pr(z_1 = 2) = 0$. -->

<!-- Let assume an animal is detected, then missed. We have $\mathbf{y} = (2, 1)$. What is the contribution of this animal to the likelihood? -->

<!-- \begin{align*} -->
<!-- \Pr(\mathbf{y} = (2, 1)) &= \sum_{z_1 = 1}^2 \; \sum_{z_2 = 1}^2 w_{z_1, y_1 = 2} w_{z_2, y_2 = 1} \Pr(z_1) \gamma_{z_1, z_2} \color{white}{\Pr(z_{T-1}, z_{T-2},\ldots, z_1, z_1, z_1, z_1)}\\ -->
<!-- &= \sum_{z_1 = 1}^2 \left( w_{z_1, y_1 = 2} w_{z_2 = 1, y_2 = 1} \Pr(z_1) \gamma_{z_1, z_2 = 1} + w_{z_1, y_1 = 2} w_{z_2 = 2, y_2 = 1} \Pr(z_1) \gamma_{z_1, z_2 = 2} \right) \\ -->
<!-- &= w_{z_1 = 1, y_1 = 2} w_{z_2 = 1, y_2 = 1} \delta_1 \gamma_{z_1 = 1, z_2 = 1} + w_{z_1 = 1, y_1 = 2} w_{z_2 = 2, y_2 = 1} \delta_1 \gamma_{z_1 = 1, z_2 = 2}\\ -->
<!-- &= (1 - p) \phi + (1-\phi) -->
<!-- \end{align*} -->

<!-- Note: $w_{z_1 = 1, y_1 = 2} = \Pr(y_1 = 2 | z_1 = 1) = 1$ because we condition on first capture. -->

## Fitting HMM with NIMBLE {#fittinghmmnimble}

If we denote *first* the time of first detection, then our model so far is written as follows:

\begin{align*}
   z_{\text{first}} &\sim \text{Categorical}(1, \delta) &\text{[likelihood]}\\
   z_t | z_{t-1} &\sim \text{Categorical}(1, \gamma_{z_{t-1},z_{t}}) &\text{[likelihood, t>first]}\\
   y_t | z_{t} &\sim \text{Categorical}(1, \omega_{z_{t}}) &\text{[likelihood, t>first]}\\
  \phi &\sim \text{Beta}(1, 1) &\text{[prior for }\phi \text{]} \\
  p &\sim \text{Beta}(1, 1) &\text{[prior for }p \text{]} \\
\end{align*}

It has an observation layer for the $y$'s, conditional on the $z$'s. We also consider uniform priors for the detection and survival probabilities. How to implement this model in NIMBLE?

```{r, echo=FALSE}
hmm.survival <- nimbleCode({
  phi ~ dunif(0, 1) # prior survival
  p ~ dunif(0, 1) # prior detection
  # likelihood
  gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
  gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
  gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
  gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
  delta[1] <- 1          # Pr(alive t = 1) = 1
  delta[2] <- 0          # Pr(dead t = 1) = 0
  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)
  omega[1,2] <- p        # Pr(alive t -> detected t)
  omega[2,1] <- 1        # Pr(dead t -> non-detected t)
  omega[2,2] <- 0        # Pr(dead t -> detected t)
  for (i in 1:N){
    z[i,1] ~ dcat(delta[1:2])
    for (j in 2:T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
```

We start with priors for survival and detection probabilities:
```{r eval=FALSE}
hmm.survival <- nimbleCode({
  phi ~ dunif(0, 1) # prior survival
  p ~ dunif(0, 1) # prior detection
...
```

Then we define initial states, transition and observation matrices:
```{r eval=FALSE}
...
  # parameters
  delta[1] <- 1          # Pr(alive t = first) = 1
  delta[2] <- 0          # Pr(dead t = first) = 0
  gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
  gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
  gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
  gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)
  omega[1,2] <- p        # Pr(alive t -> detected t)
  omega[2,1] <- 1        # Pr(dead t -> non-detected t)
  omega[2,2] <- 0        # Pr(dead t -> detected t)
...
```

Then the likelihood:
```{r eval=FALSE}
...
    # likelihood
    for (i in 1:N){
    z[i,1] ~ dcat(delta[1:2])
    for (j in 2:T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
```

The loop over time for each individual `for (j in 2:T){}` starts after the first time individuals are detected (this is time 2 for all of them here), because we work conditional on the first detection. 

Overall, the code looks like:
```{r eval = FALSE}
hmm.survival <- nimbleCode({
  phi ~ dunif(0, 1) # prior survival
  p ~ dunif(0, 1) # prior detection
  # likelihood
  delta[1] <- 1          # Pr(alive t = first) = 1
  delta[2] <- 0          # Pr(dead t = first) = 0
  gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
  gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
  gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
  gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)
  omega[1,2] <- p        # Pr(alive t -> detected t)
  omega[2,1] <- 1        # Pr(dead t -> non-detected t)
  omega[2,2] <- 0        # Pr(dead t -> detected t)
  for (i in 1:N){
    z[i,1] ~ dcat(delta[1:2])
    for (j in 2:T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
```

Now we specify the constants:
```{r}
my.constants <- list(N = nrow(y), T = 5)
my.constants
```

The data are made of 0's for non-detections and 1's for detections. To simulate the $y$, here is the code I used: 
```{r eval = FALSE}
set.seed(2022) # for reproducibility
nocc <- 5 # nb of winters or sampling occasions
nind <- 57 # nb of animals
p <- 0.6 # detection prob
phi <- 0.8 # survival prob
# Vector of initial states probabilities
delta <- c(1,0) # all individuals are alive in first winter
# Transition matrix
Gamma <- matrix(NA, 2, 2)
Gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
Gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
Gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
Gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
# Observation matrix 
Omega <- matrix(NA, 2, 2)
Omega[1,1] <- 1 - p      # Pr(alive t -> non-detected t)
Omega[1,2] <- p          # Pr(alive t -> detected t)
Omega[2,1] <- 1          # Pr(dead t -> non-detected t)
Omega[2,2] <- 0          # Pr(dead t -> detected t)
# Matrix of states
z <- matrix(NA, nrow = nind, ncol = nocc)
y <- z
y[,1] <- 2 # all individuals are detected in first winter, 
           # as we condition on first detection
for (i in 1:nind){
  z[i,1] <- rcat(n = 1, prob = delta) # 1 for sure
  for (t in 2:nocc){
    # state at t given state at t-1
    z[i,t] <- rcat(n = 1, prob = Gamma[z[i,t-1],1:2]) 
    # observation at t given state at t
    y[i,t] <- rcat(n = 1, prob = Omega[z[i,t],1:2]) 
  }
}
y
y <- y - 1 # non-detection = 0, detection = 1
```

To use the categorical distribution, we need to code 1's and 2's. We simply add 1 to get the correct format, that is $y = 1$ for non-detection and $y = 2$ for detection: 
```{r}
my.data <- list(y = y + 1)
```

<!-- **Using 1 and 2 would make my life easier... The 0/1 coding is a convention; Using the 1/2 coding would make clear that non-detections are actual data (while the use of 0s for non-detections is sometimes confusing). Also, it might help to replace states 1 and 2 by A and D for dead and alive. Even if not mathematically convenient, I guess it would help the understanding. Do it, do it. We want non-detection first, so always 1's.** -->

Now let's write a function for the initial values:
```{r}
zinits <- y + 1 # non-detection -> alive
zinits[zinits == 2] <- 1 # dead -> alive
initial.values <- function() list(phi = runif(1,0,1),
                                  p = runif(1,0,1),
                                  z = zinits)
```

As initial values for the latent states, we assumed that whenever an individual was non-detected, it was alive, with with `zinits <- y + 1`, and we make sure dead individuals are alive with `zinits[zinits == 2] <- 1`.

We specify the parameters we'd like to monitor:
```{r}
parameters.to.save <- c("phi", "p")
parameters.to.save
```

We provide MCMC details:
```{r}
n.iter <- 5000
n.burnin <- 1000
n.chains <- 2
```

At last, we're ready to run NIMBLE:
```{r, message=FALSE, eval = FALSE}
start_time <- Sys.time()
mcmc.output <- nimbleMCMC(code = hmm.survival,
                          constants = my.constants,
                          data = my.data,
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter,
                          nburnin = n.burnin,
                          nchains = n.chains)
end_time <- Sys.time()
end_time - start_time
```

```{r, message=FALSE, echo = FALSE}
start_time <- Sys.time()
mcmc.output <- nimbleMCMC(code = hmm.survival,
                          constants = my.constants,
                          data = my.data,
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter,
                          nburnin = n.burnin,
                          nchains = n.chains,
                          progressBar = FALSE)
end_time <- Sys.time()
end_time - start_time
```

We can have a look to numerical summaries:
```{r}
MCMCsummary(mcmc.output, round = 2)
```

The estimates for survival and detection are close to true survival $\phi = 0.8$ and detection $p = 0.6$ with which we simulated the data.

## Marginalization {#marginalization}

In some situations, you will not be interested in inferring the hidden states $z_{i,t}$, so why bother estimating them? The good news is that you can get rid of the states, so that the marginal likelihood is a function of survival and detection probabilities $\phi$ and $p$ only.  

### Brute-force approach

Using the formula of total probability, you get the marginal likelihood by summing over all possible states in the complete likelihood:

\begin{align*}
\Pr({y}_i) &= \Pr(y_{i,1}, y_{i,2}, \ldots, y_{i,T})\\
                &= \sum_{{z}_i} \Pr({y}_i, {z}_i)\\
                &= \sum_{z_{i,1}} \cdots \sum_{z_{i,T}} \Pr(y_{i,1}, y_{i,2}, \ldots, y_{i,T}, z_{i,1}, z_{i,2}, \ldots, z_{i,T})\\
\end{align*}

Going through the same steps as for deriving the complete likelihood, we obtain the marginal likelihood:

\begin{align*}
\Pr({y}_i) &= \sum_{z_{i,1}} \cdots \sum_{z_{i,T}} \left(\prod_{t=1}^T{\omega_{z_{i,t}, y_{i,t}}}\right) \left(\Pr(z_{i,1}) \prod_{t=2}^T{\gamma_{z_{i,t-1},z_{i,t}}}\right)\\
\end{align*}


Let's go through an example. Let's imagine we have $T = 3$ winters, and we'd like to write the likelihood for an individual having the encounter history detected, detected then non-detected. Remember that non-detected is coded 1 and detected is coded 2, while alive is coded 1 and dead is coded 2. We need to calculate $\Pr(y_1 = 2, y_2 = 2, y_3 = 1)$ which, according to the formula above, is given by:

\begin{align*}
\begin{split}
\Pr(y_1 = 2, y_2 = 2, y_3 = 1) &= \sum_{i=1}^{2} \sum_{j=1}^{2} \sum_{k=1}^{2} \Pr(y_1 = 2 | z_1 = i) \\
& \qquad \Pr(y_2 = 2 | z_2 = j) \Pr(y_3 = 1 | z_3 = k) \\ 
& \qquad \Pr(z_1=i) \Pr(z_2 = j | z_1 = i) \\
& \qquad \Pr(z_3 = k | z_2 = j)
\end{split}
\end{align*}

Expliciting all the sums in $\Pr(y_1 = 2, y_2 = 2, y_3 = 1)$, we get the long and ugly expression:

\begin{align*}
\begin{split}
\Pr(y_1 = 2, y_2 = 2, y_3 = 1) &= \\
& \Pr(y_1 = 2 | z_1 = 1) \Pr(y_2 = 2 | z_2 = 1) \Pr(y_3 = 1 | z_3 = 1) \times \\ 
& \qquad \Pr(z_1 = 1) \Pr(z_2 = 1 | z_1 = 1) \Pr(z_3 = 1 | z_2 = 1) +\\
&  \Pr(y_1 = 2 | z_1 = 2) \Pr(y_2 = 2 | z_2 = 1) \Pr(y_3 = 1 | z_3 = 1) \times\\ 
& \qquad \Pr(z_1 = 2) \Pr(z_2 = 1 | z_1 = 2) \Pr(z_3 = 1 | z_2 = 1) +\\
&  \Pr(y_1 = 2 | z_1 = 1) \Pr(y_2 = 2 | z_2 = 2) \Pr(y_3 = 1 | z_3 = 1) \times\\ 
& \qquad \Pr(z_1 = 1) \Pr(z_2 = 2 | z_1 = 1) \Pr(z_3 = 1 | z_2 = 2) +\\
&  \Pr(y_1 = 2 | z_1 = 2) \Pr(y_2 = 2 | z_2 = 2) \Pr(y_3 = 1 | z_3 = 1) \times\\ 
& \qquad \Pr(z_1 = 2) \Pr(z_2 = 2 | z_1 = 2) \Pr(z_3 = 1 | z_2 = 2) +\\
&  \Pr(y_1 = 2 | z_1 = 1) \Pr(y_2 = 2 | z_2 = 1) \Pr(y_3 = 1 | z_3 = 2) \times\\ 
& \qquad \Pr(z_1 = 1) \Pr(z_2 = 1 | z_1 = 1) \Pr(z_3 = 2 | z_2 = 1) +\\
&  \Pr(y_1 = 2 | z_1 = 2) \Pr(y_2 = 2 | z_2 = 1) \Pr(y_3 = 1 | z_3 = 2) \times\\ 
& \qquad \Pr(z_1 = 2) \Pr(z_2 = 1 | z_1 = 2) \Pr(z_3 = 2 | z_2 = 1) +\\
&  \Pr(y_1 = 2 | z_1 = 1) \Pr(y_2 = 2 | z_2 = 2) \Pr(y_3 = 1 | z_3 = 2) \times\\ 
& \qquad \Pr(z_1 = 1) \Pr(z_2 = 2 | z_1 = 1) \Pr(z_3 = 2 | z_2 = 2) +\\
&  \Pr(y_1 = 2 | z_1 = 2) \Pr(y_2 = 2 | z_2 = 2) \Pr(y_3 = 1 | z_3 = 2) \times\\ 
& \qquad \Pr(z_1 = 2) \Pr(z_2 = 2 | z_1 = 2) \Pr(z_3 = 2 | z_2 = 2)\\
\end{split}
\end{align*}

You can simplify this expression by noticing that i) all individuals are alive for sure when marked and released in first winter, or $\Pr(z_1=2) = 0$ and ii) dead individuals are non-detected for sure, or $\Pr(y_t = 2|z_t = 2) = 0$, which lead to:

\begin{align*}
\begin{split}
\Pr(y_1 = 2, y_2 = 2, y_3 = 1) &= \\
& \Pr(y_1 = 2 | z_1 = 1) \Pr(y_2 = 2 | z_2 = 1) \Pr(y_3 = 1 | z_3 = 1) \times \\ 
& \qquad \Pr(z_1 = 1) \Pr(z_2 = 1 | z_1 = 1) \Pr(z_3 = 1 | z_2 = 1) +\\
&  \Pr(y_1 = 2 | z_1 = 1) \Pr(y_2 = 2 | z_2 = 1) \Pr(y_3 = 1 | z_3 = 2) \times\\ 
& \qquad \Pr(z_1 = 1) \Pr(z_2 = 1 | z_1 = 1) \Pr(z_3 = 2 | z_2 = 1)\\
\end{split}
\end{align*}

Because all individuals are captured in first winter, or $\Pr(y_1 = 2 | z_1 = 1) = 1$, we get:

\begin{align*}
\Pr(y_1 = 2, y_2 = 2, y_3 = 1) =  1 (1-p) \times 1 \phi \phi + 1 p 1 \times 1 \phi (1-\phi)
\end{align*}

You end up with $\Pr(y_1 = 2, y_2 = 2, y_3 = 1) = \phi p (1 - p\phi)$. 

The latent states are no longer involved in the likelihood for this individual. However, even on a rather simple example, the marginal likelihood is quite complex to evaluate because it involves many operations. If $T$ is the length of our encounter histories and $N$ is the number of hidden states (two for alive and dead, but we will deal with more states in some chapters to come), then we need to calculate the sum of $N^T$ terms (the sums in the formula above), each of which has two products of $T$ factors (the products in the formula above), hence $2TN^T$ calculations in total. You can check that in the simple example above, we have $T^N = 2^3 = 8$ terms that are summed, each of which is a product of $2T = 2 \times 3 = 6$ terms. This means that the number of operations increases exponentially as the number of states increases. In most cases, this complexity precludes using this method to get rid of the states. Fortunately, we have another algorithm in the HMM toolbox that is useful to calculate the marginal likelihood efficiently.

### Forward algorithm {#forward-algorithm}

In the brute-force approach, some products are computed several times to calculate the marginal likelihood. What if we could store these products and use them later while computing the probability of the observation sequence? This is precisely what the forward algorithm does. 

We introduce $\alpha_t(j)$ the probability for the latent state $z$ of being in state $j$ at $t$  after seeing the first $j$ observations $y_1, \ldots, y_t$, that is $\alpha_t(j) = \Pr(y_1, \ldots, y_t, z_t = j)$. 

Using the law of total probability, we can write the marginal likelihood as a function of $\alpha_T(j)$, namely we have $\Pr({y}) = \displaystyle{\sum_{j=1}^N\Pr(y_1, \ldots, y_t, z_t = j)} = \displaystyle{\sum_{j=1}^N\alpha_T(j)}$. 

How to calculate the the $\alpha_T(j)$s? This is where the magic of the forward algorithm happens. We use a recurrence relationship that saves us many computations.

The recurrence states that:

\begin{align*}
\alpha_t(j) &= \sum_{i=1}^N \alpha_{t-1}(i) \gamma_{i,j} \omega_{j,y_t}
\end{align*}

How to obtain this recurrence? First, using the law of total probability with $z_{t-1}$, we have that:
\begin{align*}
\alpha_t(j) &= \sum_{i=1}^N \Pr(y_1, \ldots, y_t, z_{t-1} = i, z_t = j)\\
\end{align*}

Second, using conditional probabilities, we get:
\begin{align*}
\alpha_t(j) &= \sum_{i=1}^N \Pr(y_t | z_{t-1} = i, z_t = j, y_1, \ldots, y_t) \Pr(z_{t-1} = i, z_t = j, y_1, \ldots, y_t)
\end{align*}

Third, using conditional probabilities again, on the second term of the product, we get:
\begin{align*}
\alpha_t(j) &= \sum_{i=1}^N \Pr(y_t | z_{t-1} = i, z_t = j, y_1, \ldots, y_t) \times \\ & \Pr(z_t = j | z_{t-1} = i, y_1, \ldots, y_t) \Pr(z_{t-1} = i, y_1, \ldots, y_t)
\end{align*}

which, using conditional independence, simplifies into:

\begin{align*}
\alpha_t(j) &= \sum_{i=1}^N \Pr(y_t | z_t = j) \Pr(z_t = j | z_{t-1} = i) \Pr(z_{t-1} = i, y_1, \ldots, y_t)
\end{align*}

Recognizing that $\Pr(y_{t}|z_{t}=j)=\omega_{j,y_t}$, $\Pr(z_{t} = j | z_{t-1} = i) = \gamma_{i,j}$ and $\Pr(z_{t-1} = i, y_1, \ldots, y_t) = \alpha_{t-1}(i)$, we obtain the recurrence. 

In practice, the forward algorithm works as follows. First you initialize the procedure by calculating for the states $j=1,\ldots,N$ the quantities $\alpha_1(j) = Pr(z_1 = j) \omega_{j,y_1}$. Then you compute for the states $j=1,\ldots,N$ the relationship $\alpha_t(j) = \displaystyle{\sum_{i=1}^N \alpha_{t-1}(i) \gamma_{i,j} \omega_{j,y_t}}$ for $t = 2, \ldots, T$. Finally, you compute the marginal likelihood as $\Pr({y}) = \displaystyle{\sum_{j=1}^N\alpha_T(j)}$. At each time $t$, we need to calculate $N$ values of $\alpha_t(j)$, and each $\alpha_t(j)$ is a sum of $N$ products of $\alpha_{t-1}$, $\gamma_{i,j}$ and $\omega_{j,y_t}$, hence $TN^2$ computations in total, which is much less than the $2TN^T$ calculations in the brute-force approach.

Going back to our example, we wish to calculate $\Pr(y_1 = 2, y_2 = 2, y_3 = 1)$. First we initialize and compute $\alpha_1(1)$ and $\alpha_1(2)$. We have:

\begin{align*}
\alpha_1(1) = \Pr(z_1=1) \omega_{1,y_1=2} = 1
\end{align*}

because all animals are alive and captured in first winter. We also have:

\begin{align*}
\alpha_1(2) = \Pr(z_1=2) \omega_{2,y_1=2} = 0
\end{align*}

Then we compute $\alpha_2(1)$ and $\alpha_2(2)$.  We have:

\begin{align*}
\alpha_2(1) &= \sum_{i=1}^2 \alpha_1(i) \gamma_{i,1} \omega_{1,y_2=2}\\
            &= \gamma_{1,1} \omega_{1,y_2=2}\\
            &= \phi p
\end{align*}

because $\alpha_1(2) = 0$. Also, we have:

\begin{align*}
\alpha_2(2) &= \sum_{i=1}^2 \alpha_1(i) \gamma_{i,2} \omega_{2,y_2=2}\\
            &= \gamma_{1,2} \omega_{2,y_2=2}\\
            &= (1-\phi) 0
\end{align*}

Finally we compute $\alpha_3(1)$ and $\alpha_3(2)$.  We have:

\begin{align*}
\alpha_3(1) &= \sum_{i=1}^2 \alpha_2(i) \gamma_{i,1} \omega_{1,y_3=1}\\
            &= \alpha_2(1) \gamma_{1,1} \omega_{1,y_3=1}\\
            &= \phi p \phi (1-p)
\end{align*}

and:

\begin{align*}
\alpha_3(2) &= \sum_{i=1}^2 \alpha_2(i) \gamma_{i,2} \omega_{2,y_3=1}\\
            &= \alpha_2(1) \gamma_{1,2} \omega_{2,y_3=1}\\
            &= \phi p (1-\phi) 1
\end{align*}

Eventually, we compute $\Pr(y_1=2,y_2=2,y_3=1)$:

\begin{align*}
\Pr(y_1=2,y_2=2,y_3=1) &= \alpha_3(1) + \alpha_3(2)\\
            &= \phi p (\phi) (1-p) + \phi p (1-\phi)\\
            &= \phi p (1-\phi p)
\end{align*}

You can check that we did in total $3 \times 2^2 = 12$ operations.  

### NIMBLE implementation {#nimblemarginalization}

#### Do it yourself {#diymarginalisation}

In NIMBLE, we use functions to implement the forward algorithm. The only differences with the theory above is that i) we work on the log scale for numerical stability and ii) we use a matrix formulation of the recurrence. 

First we write the density function:
```{r}
dHMMhomemade <- nimbleFunction(
  run = function(x = double(1), 
                 probInit = double(1), # vector of initial states
                 probObs = double(2), # observation matrix
                 probTrans = double(2), # transition matrix
                 len = double(0, default = 0), # nb sampling occ
                 log = integer(0, default = 0)) {
    alpha <- probInit[1:2] # * probObs[1:2,x[1]] == 1 due to 
                           # conditioning on first detection
    for (t in 2:len) {
    alpha[1:2]<-(alpha[1:2]%*%probTrans[1:2,1:2])*probObs[1:2,x[t]]
    }
    logL <- log(sum(alpha[1:2]))
    returnType(double(0))
    if (log) return(logL)
    return(exp(logL))
  }
)
```

In passing, this is the function you would maximize in a frequentist approach (see Section \@ref(under-the-hood)). Then we write a function to simulate values from a HMM:
```{r}
rHMMhomemade <- nimbleFunction(
  run = function(n = integer(),
                 probInit = double(1),
                 probObs = double(2),
                 probTrans = double(2),
                 len = double(0, default = 0)) {
    returnType(double(1))
    z <- numeric(len)
    # all individuals alive at t = 0
    z[1] <- rcat(n = 1, prob = probInit[1:2]) 
    y <- z
    y[1] <- 2 # all individuals are detected at t = 0
    for (t in 2:len){
      # state at t given state at t-1
      z[t] <- rcat(n = 1, prob = probTrans[z[t-1],1:2]) 
      # observation at t given state at t
      y[t] <- rcat(n = 1, prob = probObs[z[t],1:2]) 
    }
    return(y)
  })
```

We assign these functions to the global R environment:
```{r}
assign('dHMMhomemade', dHMMhomemade, .GlobalEnv)
assign('rHMMhomemade', rHMMhomemade, .GlobalEnv)
```

```{r, eval = FALSE, echo = FALSE}
dHMMhomemade(x = c(2,2,1,1,1),
     probInit = delta,
     probObs = Gamma,
     probTrans = Omega,
     len = 5)
rHMMhomemade(probInit = delta,
     probObs = Gamma,
     probTrans = Omega,
     len = 5)

# build model, providing data and initial values
dat <- c(2,2,1,1,1)
phi <- 0.8
p <- 0.6

# NIMBLE code
nc <- nimbleCode({
  phi ~ dunif(0, 1) # prior survival
  p ~ dunif(0, 1) # prior detection
  # likelihood
  delta[1] <- 1          # Pr(alive t = 1) = 1
  delta[2] <- 0          # Pr(dead t = 1) = 0
  gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
  gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
  gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
  gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)
  omega[1,2] <- p        # Pr(alive t -> detected t)
  omega[2,1] <- 1        # Pr(dead t -> non-detected t)
  omega[2,2] <- 0        # Pr(dead t -> detected t)
  for (i in 1:N){
    y[i,1:T] ~ dHMMhomemade(probInit = delta[1:2], 
                    probObs = omega[1:2,1:2], # observation matrix
                    probTrans = gamma[1:2,1:2], # transition matrix
                    len = T) # nb of sampling occasions
  }
})
# NIMBLE model
model <- nimbleModel(code = nc, 
                     data = list(y = t(as.matrix(dat))),
                     inits = list(phi = 0.8, p = 0.6))

# Calculate log probability of data from the model
model$calculate()
```

Now we resume our workflow: 
```{r}
# code
hmm.survival <- nimbleCode({
  phi ~ dunif(0, 1) # prior survival
  p ~ dunif(0, 1) # prior detection
  # likelihood
  delta[1] <- 1          # Pr(alive t = 1) = 1
  delta[2] <- 0          # Pr(dead t = 1) = 0
  gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
  gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
  gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
  gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)
  omega[1,2] <- p        # Pr(alive t -> detected t)
  omega[2,1] <- 1        # Pr(dead t -> non-detected t)
  omega[2,2] <- 0        # Pr(dead t -> detected t)
  for (i in 1:N){
    y[i,1:T] ~ dHMMhomemade(probInit = delta[1:2], 
                            probObs = omega[1:2,1:2], # observation
                            probTrans = gamma[1:2,1:2], # transition
                            len = T) # nb of sampling occasions
  }
})
# constants
my.constants <- list(N = nrow(y), T = 5)
# data
my.data <- list(y = y + 1)
# initial values - no need to specify values for z anymore
initial.values <- function() list(phi = runif(1,0,1),
                                  p = runif(1,0,1))
# parameters to save
parameters.to.save <- c("phi", "p")
# MCMC details
n.iter <- 5000
n.burnin <- 1000
n.chains <- 2
```

And run NIMBLE:
```{r cache = F}
start_time <- Sys.time()
mcmc.output <- nimbleMCMC(code = hmm.survival,
                          constants = my.constants,
                          data = my.data,
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter,
                          nburnin = n.burnin,
                          nchains = n.chains)
end_time <- Sys.time()
end_time - start_time
```

The numerical summaries are similar to those we obtained with the complete likelihood, and effective samples sizes are larger denoting better mixing:
```{r}
MCMCsummary(mcmc.output, round = 2)
```

#### Do it with `nimbleEcology` {#nimbleecologyintro}

Writing NIMBLE functions is not easy. Fortunately, the NIMBLE folks got you covered. They developed the package `nimbleEcology` that implements some of the most popular ecological models with latent states. 

We will use the function `dHMMo` which provides the distribution of a hidden Markov model with time-independent transition matrix and time-dependent observation matrix. Why time-dependent observation matrix? Because we need to tell NIMBLE that detection at first encounter is 1. 

We load the package:
```{r}
library(nimbleEcology)
```

The NIMBLE code is:

```{r}
hmm.survival <- nimbleCode({
  phi ~ dunif(0, 1) # prior survival
  p ~ dunif(0, 1) # prior detection
  # likelihood
  delta[1] <- 1          # Pr(alive t = 1) = 1
  delta[2] <- 0          # Pr(dead t = 1) = 0
  gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
  gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
  gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
  gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
  omega[1,1,1] <- 0        # Pr(alive first -> non-detected first)
  omega[1,2,1] <- 1        # Pr(alive first -> detected first)
  omega[2,1,1] <- 1        # Pr(dead first -> non-detected first)
  omega[2,2,1] <- 0        # Pr(dead first -> detected first)
  for (t in 2:5){
    omega[1,1,t] <- 1 - p    # Pr(alive t -> non-detected t)
    omega[1,2,t] <- p        # Pr(alive t -> detected t)
    omega[2,1,t] <- 1        # Pr(dead t -> non-detected t)
    omega[2,2,t] <- 0        # Pr(dead t -> detected t)
  }
  for (i in 1:N){
    y[i,1:5] ~ dHMMo(init = delta[1:2], # initial state probs
                     probObs = omega[1:2,1:2,1:5], # obs matrix
                     probTrans = gamma[1:2,1:2], # trans matrix
                     len = 5, # nb of sampling occasions
                     checkRowSums = 0) # skip validity checks
  }
})
```

You may see that we no longer have the states in the code as we use the marginalized likelihood. The `dHMMo` takes several arguments, including `init` the vector of initial state probabilities, `probObs` the observation matrix, `probTrans` the transition matrix and `len` the number of sampling occasions. 

Next steps are similar to the workflow we used before. The only difference is that we do not need to specify initial values for the latent states: 

```{r}
# constants
my.constants <- list(N = nrow(y))
# data
my.data <- list(y = y + 1)
# initial values - no need to specify values for z anymore
initial.values <- function() list(phi = runif(1,0,1),
                                  p = runif(1,0,1))
# parameters to save
parameters.to.save <- c("phi", "p")
# MCMC details
n.iter <- 5000
n.burnin <- 1000
n.chains <- 2
```

Now we run NIMBLE:

```{r}
start_time <- Sys.time()
mcmc.output <- nimbleMCMC(code = hmm.survival,
                          constants = my.constants,
                          data = my.data,
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter,
                          nburnin = n.burnin,
                          nchains = n.chains)
end_time <- Sys.time()
end_time - start_time
```

Now we display the numerical summaries of the posterior distributions: 
```{r}
MCMCsummary(mcmc.output, round = 2)
```

The results are similar what we obtained previously with our home-made marginalized likelihood (Section \@ref(diymarginalisation)), or with the full likelihood (\@ref(fittinghmmnimble)).

## Pooled encounter histories {#pooled-likelihood}

We can go one step further to make convergence even faster. As mentionned earlier in Section \@ref(likelihoodhmm), the likelihood of an HMM fitted to capture-recapture data often involves individuals that share the same encounter histories. Instead of repeating the same calculations several times, the likelihood contribution that is shared by say $x$ individuals is raised to the power $x$ in the likelihood of the whole dataset, hence making the same operations only once. This idea is used in routine in capture-recapture software. For Bayesian software, however, to my knowledge this trick has only been implemented in NIMBLE [@TurekEtAl2016]. I am grateful to Chloé Nater for pointing this out to me.

In this section, we amend the NIMBLE functions we wrote for marginalizing latent states in Section \@ref(marginalization) to express the likelihood using pooled encounter histories. We use a vector `size` that contains the number of individuals with the same encounter history. 

The density function is the function `dHMMhomemade` to which we add a `size` argument, and raise the individual likelihood to the power `size`, or multiply by `size` as we work on the log scale `log(sum(alpha[1:2])) * size`:
```{r}
dHMMpooled <- nimbleFunction(
  run = function(x = double(1), 
                 probInit = double(1),
                 probObs = double(2),
                 probTrans = double(2),
                 len = double(0),
                 size = double(0),
                 log = integer(0, default = 0)) {
    alpha <- probInit[1:2]
    for (t in 2:len) {
    alpha[1:2]<-(alpha[1:2]%*%probTrans[1:2,1:2])*probObs[1:2,x[t]]
    }
    logL <- log(sum(alpha[1:2])) * size
    returnType(double(0))
    if (log) return(logL)
    return(exp(logL))
  }
)
```

The `rHMMhomemade` function is renamed `rHMMpooled` for compatibility but remains unchanged:
```{r}
rHMMpooled <- nimbleFunction(
  run = function(n = integer(),
                 probInit = double(1),
                 probObs = double(2),
                 probTrans = double(2),
                 len = double(0),
                 size = double(0)) {
    returnType(double(1))
    z <- numeric(len)
    # all individuals alive at t = 0
    z[1] <- rcat(n = 1, prob = probInit[1:2]) 
    y <- z
    y[1] <- 2 # all individuals are detected at t = 0
    for (t in 2:len){
      # state at t given state at t-1
      z[t] <- rcat(n = 1, prob = probTrans[z[t-1],1:2]) 
      # observation at t given state at t
      y[t] <- rcat(n = 1, prob = probObs[z[t],1:2]) 
    }
    return(y)
  })
```

We assign these two function to the global R environment so that we can use them:
```{r}
assign('dHMMpooled', dHMMpooled, .GlobalEnv)
assign('rHMMpooled', rHMMpooled, .GlobalEnv)
```

You can now plug your pooled HMM density function in your NIMBLE code:
```{r}
hmm.survival <- nimbleCode({
  phi ~ dunif(0, 1) # prior survival
  p ~ dunif(0, 1) # prior detection
  # likelihood
  delta[1] <- 1          # Pr(alive t = 1) = 1
  delta[2] <- 0          # Pr(dead t = 1) = 0
  gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
  gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
  gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
  gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)
  omega[1,2] <- p        # Pr(alive t -> detected t)
  omega[2,1] <- 1        # Pr(dead t -> non-detected t)
  omega[2,2] <- 0        # Pr(dead t -> detected t)
  for (i in 1:N){
    y[i,1:T] ~ dHMMpooled(probInit = delta[1:2], 
                          probObs = omega[1:2,1:2], # obs matrix
                          probTrans = gamma[1:2,1:2], # trans matrix
                          len = T, # nb of sampling occasions
                          size = size[i]) # number of individuals 
                                          # with encounter history i
  }
})
```

Before running NIMBLE, we need to actually pool individuals with the same encounter history together:
```{r}
y_pooled <- y %>% 
  as_tibble() %>% 
  group_by_all() %>% # group
  summarise(size = n()) %>% # count
  relocate(size) %>% # put size in front
  arrange(-size) %>% # sort along size
  as.matrix()
y_pooled
```

For example, we have `r y_pooled[1,1]` individuals with encounter history (`r y_pooled[1,2:6]`).

Now you can resume the NIMBLE workflow:
```{r}
my.constants <- list(N = nrow(y_pooled), 
                     T = 5, 
                     size = y_pooled[,'size'])
my.data <- list(y = y_pooled[,-1] + 1) # delete size from dataset
initial.values <- function() list(phi = runif(1,0,1),
                                  p = runif(1,0,1))
parameters.to.save <- c("phi", "p")
n.iter <- 5000
n.burnin <- 1000
n.chains <- 2
start_time <- Sys.time()
mcmc.output <- nimbleMCMC(code = hmm.survival,
                          constants = my.constants,
                          data = my.data,
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter,
                          nburnin = n.burnin,
                          nchains = n.chains)
end_time <- Sys.time()
end_time - start_time
MCMCsummary(mcmc.output, round = 2)
```

The results are the same as those obtained previously. The gain in computation times will be bigger for more complex models. 

The pooled likelihood is not yet implemented in `nimbleEcology`, but you can hack the code for the function `dHMMo` <https://github.com/nimble-dev/nimbleEcology/blob/master/R/dHMM.R> to implement it yourself by adding a `size` argument. 

<!-- ```{r} -->
<!-- library(nimble) -->
<!-- library(MCMCvis) -->
<!-- library(tidyverse) -->

<!-- dHMMopooled <- nimbleFunction( -->
<!--   run = function(x = double(1),    ## Observed capture (state) history -->
<!--                  init = double(1),## -->
<!--                  probObs = double(3), -->
<!--                  probTrans = double(2), -->
<!--                  len = double(0, default = 0),## length of x (needed as a separate param for rDHMM) -->
<!--                  size = double(0), -->
<!--                  checkRowSums = double(0, default = 1), -->
<!--                  log = integer(0, default = 0)) { -->
<!--     if (length(x) != len) stop("In dHMMo: Argument len must be length of x or 0.") -->
<!--     if (dim(probObs)[1] != dim(probTrans)[1]) stop("In dHMMo: In dHMM: Length of dimension 1 in probObs must equal length of dimension 1 in probTrans.") -->
<!--     if (dim(probTrans)[1] != dim(probTrans)[2]) stop("In dHMMo: probTrans must be a square matrix.") -->
<!--     if (dim(probObs)[3] != len) { -->
<!--       if (dim(probObs)[3] == 1) stop("In dHMMo: Time dimension of probObs must match length of data. Did you mean dHMM?") -->
<!--       stop("In dHMMo: Length of time dimension of probObs must match length of data.") -->
<!--     } -->
<!--     if (abs(sum(init) - 1) > 1e-6) stop("In dHMMo: Initial probabilities must sum to 1.") -->

<!--     if (checkRowSums) { -->
<!--       transCheckPasses <- TRUE -->
<!--       for (i in 1:dim(probTrans)[1]) { -->
<!--         thisCheckSum <- sum(probTrans[i,]) -->
<!--         if (abs(thisCheckSum - 1) > 1e-6) { -->
<!--           ## Compilation doesn't support more than a simple string for stop() -->
<!--           ## so we provide more detail using a print(). -->
<!--           print("In dHMMo: Problem with sum(probTrans[i,]) with i = ", i, ". The sum should be 1 but is ", thisCheckSum) -->
<!--           transCheckPasses <- FALSE -->
<!--         } -->
<!--       } -->
<!--       obsCheckPasses <- TRUE -->
<!--       for (i in 1:dim(probObs)[1]) { -->
<!--         for (k in 1:dim(probObs)[3]) { -->
<!--           thisCheckSum <- sum(probObs[i,,k]) -->
<!--           if (abs(thisCheckSum - 1) > 1e-6) { -->
<!--             print("In dHMMo: Problem with sum(probObs[i,,k]) with i = ", i, " k = " , k, ". The sum should be 1 but is ", thisCheckSum) -->
<!--             obsCheckPasses <- FALSE -->
<!--           } -->
<!--         } -->
<!--       } -->
<!--       if(!(transCheckPasses | obsCheckPasses)) -->
<!--         stop("In dHMMo: probTrans and probObs were not specified correctly.  Probabilities in each row (second dimension) must sum to 1.") -->
<!--       if(!transCheckPasses) -->
<!--         stop("In dHMMo: probTrans was not specified correctly.  Probabilities in each row (second dimension) must sum to 1.") -->
<!--       if(!obsCheckPasses) -->
<!--         stop("In dHMMo: probObs was not specified correctly. Probabilities in each row must sum to 1.") -->
<!--     } -->
<!--     pi <- init # State probabilities at time t=1 -->
<!--     logL <- 0 -->
<!--     nObsClasses <- dim(probObs)[2] -->
<!--     for (t in 1:len) { -->
<!--       if (x[t] > nObsClasses | x[t] < 1) stop("In dHMMo: Invalid value of x[t].") -->
<!--       Zpi <- probObs[,x[t],t] * pi # Vector of P(state) * P(observation class x[t] | state) -->
<!--       sumZpi <- sum(Zpi)    # Total P(observed as class x[t]) -->
<!--       logL <- logL + log(sumZpi) * size  # Accumulate log probabilities through timeÍ -->
<!--       if (t != len) pi <- ((Zpi %*% probTrans) / sumZpi)[1, ] # State probabilities at t+1 -->
<!--     } -->
<!--     returnType(double()) -->
<!--     if (log) return(logL) -->
<!--     return(exp(logL)) -->
<!--   } -->
<!-- ) -->

<!-- rHMMopooled <- nimbleFunction( -->
<!--   run = function(n = integer(),    ## Observed capture (state) history -->
<!--                  init = double(1), -->
<!--                  probObs = double(3), -->
<!--                  probTrans = double(2), -->
<!--                  len = double(0, default = 0), -->
<!--                  size = double(0), -->
<!--                  checkRowSums = double(0, default = 1)) { -->
<!--   returnType(double(1)) -->
<!--   if (dim(probObs)[1] != dim(probTrans)[1]) stop("In rHMMo: Number of cols in probObs must equal number of cols in probTrans.") -->
<!--   if (dim(probTrans)[1] != dim(probTrans)[2]) stop("In rHMMo: probTrans must be a square matrix.") -->
<!--   if (dim(probObs)[3] != len) { -->
<!--     if (dim(probObs)[3] == 1) stop("In rHMMo: Time dimension of probObs must match length of data. Did you mean rHMM?") -->
<!--     stop("In rHMMo: Length of time dimension of probObs must match length of data.") -->
<!--   } -->
<!--   if (abs(sum(init) - 1) > 1e-6) stop("In rHMMo: Initial probabilities must sum to 1.") -->

<!--   if (checkRowSums) { -->
<!--     transCheckPasses <- TRUE -->
<!--     for (i in 1:dim(probTrans)[1]) { -->
<!--       thisCheckSum <- sum(probTrans[i,]) -->
<!--       if (abs(thisCheckSum - 1) > 1e-6) { -->
<!--         ## Compilation doesn't support more than a simple string for stop() -->
<!--         ## so we provide more detail using a print(). -->
<!--         print("In rHMMo: Problem with sum(probTrans[i,]) with i = ", i, ". The sum should be 1 but is ", thisCheckSum) -->
<!--         transCheckPasses <- FALSE -->
<!--       } -->
<!--     } -->
<!--     obsCheckPasses <- TRUE -->
<!--     for (i in 1:dim(probObs)[1]) { -->
<!--       for (k in 1:dim(probObs)[3]) { -->
<!--         thisCheckSum <- sum(probObs[i,,k]) -->
<!--         if (abs(thisCheckSum - 1) > 1e-6) { -->
<!--           print("In rHMMo: Problem with sum(probObs[i,,k]) with i = ", i, " k = ", k, ". The sum should be 1 but is ", thisCheckSum) -->
<!--           obsCheckPasses <- FALSE -->
<!--         } -->
<!--       } -->
<!--     } -->
<!--     if(!(transCheckPasses | obsCheckPasses)) -->
<!--       stop("In rHMMo: probTrans and probObs were not specified correctly.  Probabilities in each row (second dimension) must sum to 1.") -->
<!--     if(!transCheckPasses) -->
<!--       stop("In rHMMo: probTrans was not specified correctly.  Probabilities in each row (second dimension) must sum to 1.") -->
<!--     if(!obsCheckPasses) -->
<!--       stop("In rHMMo: probObs was not specified correctly. Probabilities in each row must sum to 1.") -->
<!--   } -->

<!--   ans <- numeric(len) -->

<!--   probInit <- init -->
<!--   trueInit <- 0 -->

<!--   r <- runif(1, 0, 1) -->
<!--   j <- 1 -->
<!--   while (r > sum(probInit[1:j])) j <- j + 1 -->
<!--   trueInit <- j -->

<!--   trueState <- trueInit -->
<!--   for (i in 1:len) { -->
<!--     # Transition to a new true state -->
<!--     r <- runif(1, 0, 1) -->
<!--     j <- 1 -->
<!--     while (r > sum(probTrans[trueState, 1:j])) j <- j + 1 -->
<!--     trueState <- j -->

<!--     # Detect based on the true state -->
<!--     r <- runif(1, 0, 1) -->
<!--     j <- 1 -->
<!--     while (r > sum(probObs[trueState, 1:j, i])) j <- j + 1 -->
<!--     ans[i] <- j -->

<!--   } -->

<!--   return(ans) -->
<!-- }) -->

<!-- assign('dHMMopooled', dHMMopooled, .GlobalEnv) -->
<!-- assign('rHMMopooled', rHMMopooled, .GlobalEnv) -->

<!-- # code -->
<!-- hmm.survival <- nimbleCode({ -->
<!--   phi ~ dunif(0, 1) # prior survival -->
<!--   p ~ dunif(0, 1) # prior detection -->
<!--   # likelihood -->
<!--   delta[1] <- 1          # Pr(alive t = 1) = 1 -->
<!--   delta[2] <- 0          # Pr(dead t = 1) = 0 -->
<!--   gamma[1,1] <- phi      # Pr(alive t -> alive t+1) -->
<!--   gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1) -->
<!--   gamma[2,1] <- 0        # Pr(dead t -> alive t+1) -->
<!--   gamma[2,2] <- 1        # Pr(dead t -> dead t+1) -->
<!--   omega[1,1,1] <- 0        # Pr(alive first -> non-detected first) -->
<!--   omega[1,2,1] <- 1        # Pr(alive first -> detected first) -->
<!--   omega[2,1,1] <- 1        # Pr(dead first -> non-detected first) -->
<!--   omega[2,2,1] <- 0        # Pr(dead first -> detected first) -->
<!--   for (t in 2:5){ -->
<!--     omega[1,1,t] <- 1 - p    # Pr(alive t -> non-detected t) -->
<!--     omega[1,2,t] <- p        # Pr(alive t -> detected t) -->
<!--     omega[2,1,t] <- 1        # Pr(dead t -> non-detected t) -->
<!--     omega[2,2,t] <- 0        # Pr(dead t -> detected t) -->
<!--   } -->
<!--   for (i in 1:N){ -->
<!--     y[i,1:5] ~ dHMMopooled(init = delta[1:2], # vector of initial state probabilities -->
<!--                            probObs = omega[1:2,1:2,1:5], # observation matrix -->
<!--                            probTrans = gamma[1:2,1:2], # transition matrix -->
<!--                            len = 5, # nb of sampling occasions -->
<!--                            checkRowSums = 0, # skip validity checks -->
<!--                            size = size[i]) # number of individuals with encounter history i -->

<!--   } -->
<!-- }) -->

<!-- y_pooled <- y %>%  -->
<!--   as_tibble() %>%  -->
<!--   group_by_all() %>% # group -->
<!--   summarise(size = n()) %>% # count -->
<!--   relocate(size) %>% # put size in front -->
<!--   arrange(-size) %>% # sort along size -->
<!--   as.matrix() -->
<!-- y_pooled -->

<!-- my.constants <- list(N = nrow(y_pooled), T = 5, size = y_pooled[,'size']) -->
<!-- my.data <- list(y = y_pooled[,-1] + 1) # delete size from dataset -->
<!-- initial.values <- function() list(phi = runif(1,0,1), -->
<!--                                   p = runif(1,0,1)) -->
<!-- parameters.to.save <- c("phi", "p") -->
<!-- n.iter <- 5000 -->
<!-- n.burnin <- 1000 -->
<!-- n.chains <- 2 -->

<!-- start_time <- Sys.time() -->
<!-- mcmc.output <- nimbleMCMC(code = hmm.survival, -->
<!--                           constants = my.constants, -->
<!--                           data = my.data, -->
<!--                           inits = initial.values, -->
<!--                           monitors = parameters.to.save, -->
<!--                           niter = n.iter, -->
<!--                           nburnin = n.burnin, -->
<!--                           nchains = n.chains) -->
<!-- end_time <- Sys.time() -->
<!-- end_time - start_time -->

<!-- MCMCsummary(mcmc.output, round = 2) -->
<!-- ``` -->


## Decoding after marginalization {#decoding}

If you need to infer the latent states, and you cannot afford the computation times of the complete likelihood of Section \@ref(likelihoodhmm), you can still use the marginal likelihood with the forward algorithm of Section \@ref(forward-algorithm). You will need an extra step to decode the latent states with the Viterbi algorithm. The Viterbi algorithm allows you to compute the sequence of states that is most likely to have generated the sequence of observations.

### Theory {#viterbi-theory}

```{r echo = FALSE}
set.seed(2022) # for reproducibility
nocc <- 5 # nb of winters or sampling occasions
nind <- 57 # nb of animals
p <- 0.6 # detection prob
phi <- 0.8 # survival prob
# Vector of initial states probabilities
delta <- c(1,0) # all individuals are alive in first winter
# Transition matrix
Gamma <- matrix(NA, 2, 2)
Gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
Gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
Gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
Gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
# Observation matrix 
Omega <- matrix(NA, 2, 2)
Omega[1,1] <- 1 - p      # Pr(alive t -> non-detected t)
Omega[1,2] <- p          # Pr(alive t -> detected t)
Omega[2,1] <- 1          # Pr(dead t -> non-detected t)
Omega[2,2] <- 0          # Pr(dead t -> detected t)
# Matrix of states
z <- matrix(NA, nrow = nind, ncol = nocc)
y <- z
y[,1] <- 2 # all individuals are detected in first winter
for (i in 1:nind){
  z[i,1] <- rcat(n = 1, prob = delta) # 1 for sure
  for (t in 2:nocc){
    # state at t given state at t-1
    z[i,t] <- rcat(n = 1, prob = Gamma[z[i,t-1],1:2]) 
    # observation at t given state at t
    y[i,t] <- rcat(n = 1, prob = Omega[z[i,t],1:2]) 
  }
}
y <- y - 1
```

In our simulated dataset, animal #15 has the encounter history (`r y[15,] + 1`) which was generated from the sequence of states (`r z[15,]`) with survival probability $\phi = 0.8$ and detection probability $p = 0.6$. 

Imagine you do not know the truth. What is the chance that animal #15 was alive throughout the study when observing the encounter history detected in first winter, then missed in each subsequent winter? The chance of being alive in the first winter and detected when alive is 1. The chance of being alive in the second winter and non-detected is $0.8 \times (1-0.6) = 0.32$. The same goes for third, fourth and fifth winters. In total, the probability of being alive throughout the study for an animal with encounter history (`r y[15,] + 1`) is $1 \times 0.32 \times 0.32 \times 0.32 \times 0.32 = 0.01048576$.

Now what is the chance that animal #15 was alive, then dead for the rest of the study, when observing the encounter history (`r y[15,] + 1`)? And the chance of being alive in first and second winters, then dead after when observing the same encounter history? And so on. You need to enumerate all possible sequences of states and compute the probability for each of them, and choose the most probable sequence, that is with maximum probability. In our example, we would need to compute $2^5 = 32$ of these probabilities, and $N^T$ in general. Needless to say, these calculations quickly become cumbersome, if not impossible, as the number of states and/or the number of sampling occasions increases. 

This is where the Viterbi algorithm comes in. The idea is to decompose this overall complex problem in a sequence of smallers problems that are easier to solve. If dynamic programming rings a bell, the Viterbi algorithm should look familiar to you. The Viterbi algorithm is based on the fact that the optimal path to each winter and each state can be deduced from the optimal path to the previous winter and each state.  

For first winter, the probability of being alive and detected is 1, while the probability of being dead and detected is 0. Now what is the probability of being alive in the second winter and non-detected? If the animal was alive in the first winter, it remains alive and is missed with probability $1 \times \phi (1-p) = 0.32$. If it was dead in the first winter, then this probability is 0. The maximum probability is 0.32 obviously so the most probable scenario to being alive in the second winter is being alive in the first winter. What about being dead in the second winter? If the animal was alive in first winter, then the probability is $1 \times (1-\phi) \times 1 = 0.2$. If dead, then this probability is $0 \times 0 \times (1-p) = 0$. The maximum probability is 0.2 obviously so the most probable scenario to being dead in the second winter is being alive in the first winter. Doing these calculations for third, fourth and fifth winters, we get the probabilities:

|  winter         |     1    |         2           |             3           |             4               |               5                 |
|:---------------:|:--------:|:-------------------:|:-----------------------:|:---------------------------:|:-------------------------------:|
| **state alive** |     1    | 0.32 = max(0, 0.32) | 0.2304 = max(0, 0.2304) | 0.110592 = max(0, 0.110592) | 0.053084416 = max(0, 0.05308416 |
|  **state dead** |     0    |  1 = max(1, 0.2)    |    1 = max(0.096, 1)    |     1 = max(0.04608, 1)     |      1 = max(0.0221184, 1)      |
| **obs.** | det. |        missed       |          missed         |            missed           |              missed             |


Finally, to get (or decode) the optimal path, you work backwards and trace back the previous value that yielded the maximum probability. The most probable state in the last winter is dead (1 > 0.05308416), dead again in the fourth winter (1 > 0.110592), dead in the third winter (1 > 0.2304), alive in the second winter (1 > 0.48) and alive in the firt winter (1 > 0). According to the Viterbi algorithm, the sequence of states that most likelily generated the sequence of observations (`r y[15,] + 1`) is alive then dead, dead, dead and dead or (1 2 2 2 2). This differs slightly from the actual sequence of states (`r z[15,]`) in that the state in second winter is decoded dead while animal #15 only dies in third winter.

In contrast to the brute force approach, calculations are not duplicated but stored and used again like in the forward algorithm. Briefly speaking, the Viterbi algorithm works like the forward algorithm where sums are replaced by calculating maximums. 

In practice, the Viterbi algorithm works as illustrated in Figure \@ref(fig:treillis-viterbi). First you initialize the procedure by calculating at $t=1$ for all states $j=1,\ldots,N$ the values $\nu_1(j) = Pr(z_1 = j) \omega_{j,y_1}$. Then you compute for all states $j=1,\ldots,N$ the values $\nu_t(j) = \displaystyle{\max_{i=1,\ldots,N} \nu_{t-1}(i) \gamma_{i,j} \omega_{j,y_t}}$ for $t = 2, \ldots, T$. Here at each time $t$ we determine the probability of the best path ending at each of the states $j=1,\ldots,N$. Finally, you compute the probability of the best global path $\displaystyle{\max_{j=1,\ldots,N}\nu_T(j)}$.

```{r treillis-viterbi, echo = FALSE, fig.align="center", out.width="100%", fig.cap = "Graphical representation of the Viterbi algorithm with $\\phi = 0.8$ and $p = 0.6$. States are alive $z = 1$ or dead $z = 2$ and observations are non-detected $y = 1$ or detected $y = 2$. To be done properly w/ tikz."}
knitr::include_graphics("images/treillis-viterbi.png")
```

### Implementation

Let's write a R function to implement the Viterbi algorithm. As parameters, our function will take the transition and observation matrices, the vector of initial state probabilities and the observed sequence of detections and non-detections for which you aim to compute the sequence of states from which it was most likely generated:
```{r}
# getViterbi() returns sequence of states that most 
# likely generated sequence of observations
# adapted from https://github.com/vbehnam/viterbi
getViterbi <- function(Omega, Gamma, delta, y) {
# Omega: transition matrix
# Gamma: observation matrix
# delta: vector of initial state probabilities
# y: observed sequence of detections and non-detections
  
# get number of states and sampling occasions
N <- nrow(Gamma)
T <- length(y)
  
# nu is the corresponding likelihood
nu <- matrix(0, nrow = N, ncol = T)
# zz contains the most likely states up until this point
zz <- matrix(0, nrow = N, ncol = T)
firstObs <- y[1]
  
# fill in first columns of both matrices
#nu[,1] <- initial * emission[,firstObs]
#zz[,1] <- 0
nu[,1] <- c(1,0) # initial = (1, 0) * emission[,firstObs] = (1, 0)
zz[,1] <- 1 # alive at first occasion

for (i in 2:T) {
    for (j in 1:N) {
      obs <- y[i]
      # initialize to -1, then overwritten by 
      # for loop coz all possible values are >= 0
      nu[j,i] <- -1
      # loop to find max and argmax for k
      for (k in 1:N) {
        value <- nu[k,i-1] * Gamma[k,j] * Omega[j,obs]
        if (value > nu[j,i]) {
          # maximizing for k
          nu[j,i] <- value
          # argmaximizing for k
          zz[j,i] <- k
        }
      }
    }
  }
  # mlp = most likely path
  mlp <- numeric(T)
  # argmax for stateSeq[,T]
  am <- which.max(nu[,T])
  mlp[T] <- zz[am,T]
  
  # backtrace using backpointers
  for (i in T:2) {
    zm <- which.max(nu[,i])
    mlp[i-1] <- zz[zm,i]
  }
  return(mlp)
}
```

Note that instead of writing your own R function, you could use a built-in function from an existing R package to implement the Viterbi algorithm (for example, the `viterbi()` function from the `HMM` and `depmixS4` packages), and call it from NIMBLE as we have seen in Section \@ref(callrfninnimble). The difficulty is that HMM for capture-recapture data have specific features that make standard functions not adapted and requires coding your own Viterbi function. In particular, we have to deal with detection at first encounter, which is not estimated but is always one because an individual has to be captured to be marked and released for the first time. Also, our transition and observation matrices are not always homogeneous and may depend on time. 

```{r echo = FALSE, eval = FALSE}
library(HMM)
# build HMM
hmm <- initHMM(States = c("alive","dead"),
              Symbols = c("nondet","det"), 
              startProbs = delta,
              transProbs = Gamma,
              emissionProbs = Omega)
hmm
# sequence of observations
observations <- c("det","nondet","nondet","nondet", "nondet")
# calculate Viterbi path
viterbi <- viterbi(hmm, observations)
viterbi
```

Let's test our `getViterbi()` function with our previous example. Remember animal #15 has the encounter history (`r y[15,] + 1`) which was generated from the sequence of states (`r z[15,]`). Applying our function to that animal encounter history, we get:
```{r}
delta # Vector of initial states probabilities
Gamma # Transition matrix
Omega # Observation matrix
getViterbi(Omega = Omega, 
           Gamma = Gamma, 
           delta = delta, 
           y = y[15,] + 1)
```

The Viterbi algorithm does pretty well at recovering the latent states, despite incorrectly decoding a death in the second winter while individual #15 only dies in the third winter. We obtained the same results by implementing the Viterbi algorithm by hand in Section \@ref(viterbi-theory). 

Now that we have a function that implements the Viterbi algorithm, we can use it with our MCMC outputs. You have two options, either you apply Viterbi to each MCMC iteration then you compute the posterior median or mode path for each individual, or you compute the posterior mean or median of the transition and observation matrices then you apply Viterbi to each individual encounter history. 

For both options, we will need the values from the posterior distributions of survival and detection probabilities:
```{r}
phi <- c(mcmc.output$chain1[,'phi'], mcmc.output$chain2[,'phi'])
p <- c(mcmc.output$chain1[,'p'], mcmc.output$chain2[,'p'])
```

### Compute first, average after {#compute-average}

First option is to apply Viterbi to each MCMC sample, then to compute median of the MCMC Viterbi paths for each observed sequence:
```{r}
niter <- length(p)
T <- 5
res <- matrix(NA, nrow = nrow(y), ncol = T)
for (i in 1:nrow(y)){
  res_mcmc <- matrix(NA, nrow = niter, ncol = T)
  for (j in 1:niter){
    # Initial states
    delta <- c(1, 0)
    # Transition matrix
    transition <- matrix(NA, 2, 2)
    transition[1,1] <- phi[j]      # Pr(alive t -> alive t+1)
    transition[1,2] <- 1 - phi[j]  # Pr(alive t -> dead t+1)
    transition[2,1] <- 0        # Pr(dead t -> alive t+1)
    transition[2,2] <- 1        # Pr(dead t -> dead t+1)
    # Observation matrix 
    emission <- matrix(NA, 2, 2)
    emission[1,1] <- 1 - p[j]      # Pr(alive t -> non-detected t)
    emission[1,2] <- p[j]          # Pr(alive t -> detected t)
    emission[2,1] <- 1          # Pr(dead t -> non-detected t)
    emission[2,2] <- 0          # Pr(dead t -> detected t)
    res_mcmc[j,1:T] <- getViterbi(Omega = emission, 
                                  Gamma = transition, 
                                  delta = delta, 
                                  y = y[i,] + 1)
  }
  res[i, 1:length(y[1,])] <- apply(res_mcmc, 2, median)
}
```

You can compare the Viterbi decoding to the actual states $z$:
```{r viterbiaveragecompute, echo = FALSE, fig.cap = "Comparison of the actual sequences of states to the sequences of states decoded with Viterbi and the *average first, compute after* method."}
df <- expand.grid(X = 1:nrow(z), Y = 1:ncol(z))
df$Z <- as_factor(c(z - res))
myPallette <- RColorBrewer::brewer.pal(name = "RdBu", n = 4)
if (params$bw) {
  df %>% 
    ggplot() + 
    aes(x = X, y = Y, fill = Z) + 
    geom_tile() +
    scale_fill_manual(values = c("0" = "grey30", 
                                 "1" = "grey80", 
                                 "-1" = "black"),
                      labels = c("0" = "Decoding is correct", 
                                 "1" = "Dead is decoded alive", 
                                 "-1" = "Alive is decoded dead"))+
    labs(x = "individuals", y = "winters", fill = NULL) +
    theme_light()
} else {
  df %>% 
    ggplot() + 
    aes(x = X, y = Y, fill = Z) + 
    geom_tile() +
    scale_fill_manual(values = c("0" = "#9597f0", 
                                 "1" = "#d4b4f6", 
                                 "-1" = "#ff688c"),
                      labels = c("0" = "Decoding is correct", 
                                 "1" = "Dead is decoded alive", 
                                 "-1" = "Alive is decoded dead"))+
    labs(x = "individuals", y = "winters", fill = NULL) +
    theme_light()
}
```

Decoding is correct except that the alive actual state is often decoded as the dead state by the Viterbi algorithm. Note that here we compute the Viterbi paths after we run NIMBLE. You could turn the R function `getViterbi()` into a NIMBLE function and plug it in your model code to apply Viterbi. This would not make any difference except perhaps to increase MCMC computation times. 

### Average first, compute after

Second option is to compute the posterior mean of the observation and transition matrices, then to apply Viterbi:
  
```{r}
# Initial states
delta <- c(1, 0)
# Transition matrix
transition <- matrix(NA, 2, 2)
transition[1,1] <- mean(phi)      # Pr(alive t -> alive t+1)
transition[1,2] <- 1 - mean(phi)  # Pr(alive t -> dead t+1)
transition[2,1] <- 0              # Pr(dead t -> alive t+1)
transition[2,2] <- 1              # Pr(dead t -> dead t+1)
# Observation matrix 
emission <- matrix(NA, 2, 2)
emission[1,1] <- 1 - mean(p)      # Pr(alive t -> non-detected t)
emission[1,2] <- mean(p)          # Pr(alive t -> detected t)
emission[2,1] <- 1                # Pr(dead t -> non-detected t)
emission[2,2] <- 0                # Pr(dead t -> detected t)
res <- matrix(NA, nrow = nrow(y), ncol = T)
for (i in 1:nrow(y)){
  res[i, 1:length(y[1,]) ] <- getViterbi(Omega = emission, 
                                         Gamma = transition, 
                                         delta = delta, 
                                         y = y[i,] + 1)
}
```

Again, you can compare the result of the Viterbi decoding to the actual states we simulated and used to generate the observations:
```{r viterbicomputeaverage, echo = FALSE, fig.cap = "Comparison of the actual sequences of states to the sequences of states decoded with Viterbi and the *compute first, average after* approach."}
df <- expand.grid(X = 1:nrow(z), Y = 1:ncol(z))
df$Z <- as_factor(c(z - res))
myPallette <- RColorBrewer::brewer.pal(name = "RdBu", n = 4)
if (params$bw) {
  df %>% 
    ggplot() + 
    aes(x = X, y = Y, fill = Z) + 
    geom_tile() +
    scale_fill_manual(values = c("0" = "grey30", 
                                 "1" = "grey80", 
                                 "-1" = "black"),
                      labels = c("0" = "Decoding is correct", 
                                 "1" = "Dead is decoded alive", 
                                 "-1" = "Alive is decoded dead"))+
    labs(x = "individuals", y = "winters", fill = NULL) +
    theme_light()
} else {
  df %>% 
    ggplot() + 
    aes(x = X, y = Y, fill = Z) + 
    geom_tile() +
    scale_fill_manual(values = c("0" = "#9597f0", 
                                 "1" = "#d4b4f6", 
                                 "-1" = "#ff688c"),
                      labels = c("0" = "Decoding is correct", 
                                 "1" = "Dead is decoded alive", 
                                 "-1" = "Alive is decoded dead"))+
    labs(x = "individuals", y = "winters", fill = NULL) +
    theme_light()
}
```

The results are very similar to those we obtained in Section \@ref(compute-average), and Figure \@ref(fig:viterbicomputeaverage) is indisguishable from Figure \@ref(fig:viterbiaveragecompute).

## Summary

+ A HMM is a model that consists of two parts: i) an unobserved sequence of discrete random variables - the states - satisfying the Markovian property (future states depends on current states only and not on past states) and ii) an observed sequence of discrete random variables - the observations - depending only on the current state.

+ The Bayesian approach together with MCMC simulations allow estimating survival and detection probabilities as well as individual latent states alive or dead with the complete likelihood. If you can afford the computation times, then using the complete likelihood is the easiest path for model fitting.  

+ If you do not need to infer the latent states, you can use the marginal likelihood via the forward algorithm. By avoiding to sample the latent states, you usually get better mixing and faster convergence. 

+ If you do need to infer the latent states, and you cannot afford the computation times of the complete likelihood, then you can go for the marginal likelihood in conjunction with the Viterbi algorithm to decode the latent states.

+ If the computational burden is still an issue, and you have individuals that share the same encounter history, you can use a pooled likelihood to speed up the marginal likelihood evaluation and MCMC convergence. 

## Suggested reading

+ A landmark paper on HMM is @Rabiner1989. 

+ Check out @JurafskySpeechAL for a nice introduction to HMM and @ZucchiniEtAl2016 for an excellent book that covers theory and applications. 

+ The paper by @mcclintock_uncovering_2020 reviews the applications of HMM in ecology. 

+ The package `nimbleEcology` is developed by @goldstein2019nimbleecology; see @ponisio2020customizing for its application to occupancy and N--mixture models.

<!--chapter:end:3-hmm.Rmd-->

```{r include=FALSE, cache=FALSE}
# packages
library(tidyverse)
theme_set(theme_light(base_size = 14))
library(nimble)
library(MCMCvis)
library(magick)
library(pdftools)
library(wesanderson)
library(RColorBrewer)
library(patchwork)
library(emo)
#library(nimbleEcology)
#library(basicMCMCplots)

# R options
options(width = 60)

# chunk options
knitr::opts_chunk$set(
  comment = "##",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE
  )
```
# (PART) Transitions {-}

# Introduction {-}

This second part `Transitions` will teach you all about capture-recapture models for open populations, with reproducible R code to ease the learning process. The code and data are available at <https://github.com/oliviergimenez/banana-book/tree/master/appendix>. 

<!--chapter:end:introductionparttwo.Rmd-->

```{r include=FALSE, cache=FALSE}
# packages
library(tidyverse)
theme_set(theme_light(base_size = 14))
library(nimble)
library(MCMCvis)
library(magick)
library(pdftools)
library(wesanderson)
library(RColorBrewer)
library(patchwork)
library(emo)
#library(nimbleEcology)
#library(basicMCMCplots)

# R options
options(width = 60)

# chunk options
knitr::opts_chunk$set(
  comment = "##",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE
  )
```
# Alive and dead {#survival}

## Introduction

In this fourth chapter, you will learn about the Cormack-Jolly-Seber model that allows estimating survival based on capture-recapture data. You will also see how to deal with covariates to try and explain temporal and/or individual variation in survival. This chapter will also be the opportunity to introduce tools to compare models and assess their quality of fit to data. 

## The Cormack-Jolly-Seber (CJS) model

In Chapter \@ref(hmmcapturerecapture), we introduced a capture-recapture model with constant survival and detection probabilities which we formulated as a HMM and fitted to data in NIMBLE. Historically, however, it was a slightly more complicated model that was first proposed -- the so-called Cormack-Jolly-Seber (CJS) model -- in which survival and recapture probabilities are time-varying. This feature of the CJS model is useful to account for variation due to environmental conditions in survival or to sampling effort in detection. Schematically the CJS model can be represented this way:

```{r, engine = 'tikz', echo = FALSE}
\usetikzlibrary{arrows, fit, positioning, automata}
\begin{tikzpicture}[node distance = 2cm]
\tikzset{state/.style = {circle, draw, minimum size = 30pt, scale = 3, line width=1pt}}
\node [state,fill=lightgray!75] (6) [] {$1$};
\node [state,fill=lightgray!75] (5) [left = 20mm of 6] {$1$};
\node [state,fill=lightgray!75] (4) [left = 20mm of 5] {$1$};
\node [state,fill=lightgray!75] (3) [left = 20mm of 4] {$1$};
\node [state,fill=lightgray!75] (7) [right = 20mm of 6] {$2$};
\node [state,fill=lightgray!75] (8) [right = 20mm of 7] {$2$};
\node [state,fill=lightgray!75] (9) [right = 20mm of 8] {$\cdots$};
\node [state,fill=white] (16) [above = 20mm of 6] {$1$};
\node [state,fill=white] (15) [above = 20mm of 5] {$2$};
\node [state,fill=white] (14) [above = 20mm of 4] {$1$};
\node [state,fill=white] (17) [above = 20mm of 7] {$1$};
\node [state,fill=white] (18) [above = 20mm of 8] {$1$};
\draw[->,black, line width=0.25mm,-latex] (3) -- node[above=3mm, align=center] {\huge $\phi_1$} (4);
\draw[->,black, line width=0.25mm,-latex] (4) -- node[above=3mm, align=center] {\huge $\phi_2$} (5);
\draw[->,black, line width=0.25mm,-latex] (5) -- node[above=3mm, align=center] {\huge $\phi_3$} (6);
\draw[->,black, line width=0.25mm,-latex] (6) -- node[above=3mm, align=center] {\huge $1-\phi_4$} (7);
\draw[->,black, line width=0.25mm,-latex] (7) -- node[above=3mm, align=center] {\huge $1$} (8);
\draw[->,black, line width=0.25mm,-latex] (8) -- node[above=3mm, align=center] {\huge $1$} (9);
\draw[->,black, line width=0.25mm,-latex] (4) -- node[left=3mm, align=center] {\huge $1-p_2$} (14);
\draw[->,black, line width=0.25mm,-latex] (5) -- node[left=3mm, align=center] {\huge $p_3$} (15);
\draw[->,black, line width=0.25mm,-latex] (6) -- node[left=3mm, align=center] {\huge $1-p_4$} (16);
\draw[->,black, line width=0.25mm,-latex] (7) -- node[left=3mm, align=center] {\huge $1$} (17);
\draw[->,black, line width=0.25mm,-latex] (8) -- node[left=3mm, align=center] {\huge $1$} (18);
\end{tikzpicture}
```

Note that the states (in gray) and the observations (in white) do not change. We still have $z = 1$ for alive, $z = 2$ for dead, $y = 1$ for non-detected, and $y = 2$ for detected. 

Parameters are now indexed by time. The survival probability is defined as the probability of staying alive (or "ah, ha, ha, ha, stayin' alive" like the Bee Gees would say) over the interval between $t$ and $t+1$, that is $\phi_t = \Pr(z_{t+1} = 1 | z_t = 1)$. The detection probability is defined as the probability of being observed at $t$ given you're alive at $t$, that is $p_t = \Pr(y_{t} = 1 | z_t = 1)$. It is important to bear in mind for later (see Section \@ref(covariates)) that survival operates over an interval while detection occurs at a specific time.

The CJS model is named after the three statisticians -- Richard Cormack, George Jolly and George Seber -- who each published independently a paper introducing more or less the same approach, a year apart ! In fact, Richard Cormack and George Jolly were working in the same corridor in Scotland back in the 1960's. They would meet every day at coffee and would play some game together, but never mention work and were not aware of each other's work.

## Capture-recapture data {#crdataeg}

Before we turn to fitting the CJS model to actual data, let's talk about capture-recapture for a minute. We said in Section \@ref(capturerecapturedata) that animals are individually marked. This can be accomplished in two ways, either with artificial marks like rings for birds or ear tags for mammals, or (non-invasive) natural marks like coat patterns or feces DNA sequencing (Figure \@ref(fig:marking)).

```{r marking, echo = FALSE, fig.cap = "Animal individual marking. Top-left: rings (credit: Emannuelle Cam and Jean-Yves Monat); Top-right: ear-tags (credit: Kelly Powell); Bottom left: coat patterns (credit: Fridolin Zimmermann); Bottom right: ADN feces (credit: Alexander Kopatz)", fig.show = "hold", out.width="100%"}
knitr::include_graphics("images/marking.png")
```

Throughout this chapter, we will use data on the White-throated Dipper (*Cinclus cinclus*; dipper hereafter) kindly provided by Gilbert Marzolin (Figure \@ref(fig:pixdipper)). In total, 294 dippers with known sex and wing length were captured and recaptured between 1981 and 1987 during the March-June period. Birds were at least 1 year old when initially banded. 

```{r pixdipper, echo=FALSE, out.width="100%", fig.cap="White-throated Dipper (Cinclus cinclus). Credit: Gilbert Marzolin.", fig.align='center'}
knitr::include_graphics("images/Marzo_BaguesMance.jpg")
```

The data look like: 

```{r echo = TRUE, eval = FALSE}
dipper <- read_csv("dipper.csv")
dipper
```

```{r echo = FALSE}
dipper <- read_csv("dat/dipper.csv")
dipper
```

The first seven columns are years in which Gilbert went on the field and captured the birds. A 0 stands for a non-detection, and a 1 for a detection. The eighth column informs on the sex of the bird, with F for female and M for male. The last column gives a measure wing length the first time a bird was captured. 

## Fitting the CJS model to the dipper data with NIMBLE

To write the NIMBLE code corresponding to the CJS model, we only need to make a few adjustments to the NIMBLE code for the model with constant parameters from Section \@ref(fittinghmmnimble). The main modification concerns the observation and transition matrices which we need to make time-varying. These matrices therefore become arrays and inherit a third dimension for time, besides that for rows and columns. Also we need priors for all time-varying survival `phi[t] ~ dunif(0, 1)` and detection `p[t] ~ dunif(0, 1)` probabilities. We write:

```{r eval=FALSE}
...
# parameters
  delta[1] <- 1                 # Pr(alive t = 1) = 1
  delta[2] <- 0                 # Pr(dead t = 1) = 0
  for (t in 1:(T-1)){
    phi[t] ~ dunif(0, 1)        # prior survival
    gamma[1,1,t] <- phi[t]      # Pr(alive t -> alive t+1)
    gamma[1,2,t] <- 1 - phi[t]  # Pr(alive t -> dead t+1)
    gamma[2,1,t] <- 0           # Pr(dead t -> alive t+1)
    gamma[2,2,t] <- 1           # Pr(dead t -> dead t+1)
    p[t] ~ dunif(0, 1)          # prior detection
    omega[1,1,t] <- 1 - p[t]    # Pr(alive t -> non-detected t)
    omega[1,2,t] <- p[t]        # Pr(alive t -> detected t)
    omega[2,1,t] <- 1           # Pr(dead t -> non-detected t)
    omega[2,2,t] <- 0           # Pr(dead t -> detected t)
  }
...
```

The likelihood does not change, except that the time-varying observation and transition matrices need to be used appropriately. Also, because we now deal with several cohorts of animals first captured, marked and released each year (in contrast with a single cohort as in Chapter \@ref(hmmcapturerecapture)), we need to start the loop over time from the first capture for each individual. Therefore, we write: 

```{r eval=FALSE}
...
# likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1])
    }
  }
...
```

At first capture, all individuals are alive `z[i,first[i]] ~ dcat(delta[1:2])` and detection is 1, then after first capture `for (j in (first[i]+1):T)` we apply the transition and observation matrices. 
Overall, the code looks like:
```{r}
hmm.phitpt <- nimbleCode({
  # parameters
  delta[1] <- 1                 # Pr(alive t = 1) = 1
  delta[2] <- 0                 # Pr(dead t = 1) = 0
  for (t in 1:(T-1)){
    phi[t] ~ dunif(0, 1)        # prior survival
    gamma[1,1,t] <- phi[t]      # Pr(alive t -> alive t+1)
    gamma[1,2,t] <- 1 - phi[t]  # Pr(alive t -> dead t+1)
    gamma[2,1,t] <- 0           # Pr(dead t -> alive t+1)
    gamma[2,2,t] <- 1           # Pr(dead t -> dead t+1)
    p[t] ~ dunif(0, 1)          # prior detection
    omega[1,1,t] <- 1 - p[t]    # Pr(alive t -> non-detected t)
    omega[1,2,t] <- p[t]        # Pr(alive t -> detected t)
    omega[2,1,t] <- 1           # Pr(dead t -> non-detected t)
    omega[2,2,t] <- 0           # Pr(dead t -> detected t)
  }
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1])
    }
  }
})
```

We extract the detections and non-detections from the data:
```{r}
y <- dipper %>%
  select(year_1981:year_1987) %>%
  as.matrix()
```

We get the occasion of first capture for all individuals, by finding the position of detections in the encounter history (`which(x !=0)`), and keeping the first one:
```{r}
first <- apply(y, 1, function(x) min(which(x !=0)))
```

Now we specify the constants:
```{r}
my.constants <- list(N = nrow(y),   # number of animals
                     T = ncol(y),   # number of sampling occasions
                     first = first) # first capture for all animales
```

We then put the data in a list. We add 1 to the data to code non-detections as 1's detections as 2's (see Section \@ref(fittinghmmnimble)). 
```{r}
my.data <- list(y = y + 1)
```

Let's write a function for the initial values. For the latent states, we go the easy way, and say that all individuals are alive through the study period:
```{r}
zinits <- y + 1 # non-detection -> alive
zinits[zinits == 2] <- 1 # dead -> alive
initial.values <- function() list(phi = runif(my.constants$T-1,0,1),
                                  p = runif(my.constants$T-1,0,1),
                                  z = zinits)
```

We specify the parameters we would like to monitor, survival and detection probabilities here:
```{r}
parameters.to.save <- c("phi", "p")
```

We provide MCMC details:
```{r}
n.iter <- 5000
n.burnin <- 1000
n.chains <- 2
```

And we run NIMBLE:
```{r, message=FALSE, eval = FALSE}
mcmc.phitpt <- nimbleMCMC(code = hmm.phitpt,
                          constants = my.constants,
                          data = my.data,
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter,
                          nburnin = n.burnin,
                          nchains = n.chains)
```

We may have a look to the numerical summaries: 
```{r echo = FALSE}
load(here::here("dat","dipper.RData"))
```
```{r}
MCMCsummary(mcmc.phitpt, params = c("phi","p"), round = 2)
```

There is not so much time variation in the detection probability which is estimated high around 0.90. Note that `p[1]` corresponds to the detection probability in 1982 that is $p_2$, `p[2]` to detection in 1983 therefore $p_3$, and so on. The dippers seem to have experienced a decrease in survival in years 1982-1983 (`phi[2]`) and 1983-1984 (`phi[4]`). We will get back to that in Section \@ref(covariates). 

You may have noticed the small effective sample size for the last survival (`phi[6]`) and detection (`p[6]`) probabilities. Let's have a look to mixing for parameter `phi[6]` for example:
```{r}
priors <- runif(3000, 0, 1)
MCMCtrace(object = mcmc.phitpt,
          ISB = FALSE,
          exact = TRUE, 
          params = c("phi[6]"),
          pdf = FALSE, 
          priors = priors)
```

Clearly mixing (left panel in the plot above) is bad and there is a big overlap between the prior and the posterior for this parameter (right panel) suggesting that its prior was not well updated with the data. What is going on? If you could inspect the likelihood of the CJS model, you would realize that these two parameters $\phi_6$ and $p_7$ appear only as the product $\phi_6 p_7$ and cannot be estimated separately. In other words, one of these parameters is redundant, and you'd need an extra sampling occasion to be able to disentangle them. This is not a big issue as long as you're aware of it and you do not attempt to ecologically interpret these parameters. 

## CJS model derivatives {#cjsderivatives}

Besides the model we considered with constant parameters (see Chapter \@ref(hmmcapturerecapture)) and the CJS model with time-varying parameters, you might want to fit in-between or models with time variation on either detection or survival. 

But I realize that we did not actually fit the model with constant parameters from Chapter \@ref(hmmcapturerecapture). Let's do it. You should be familiar with the process by now: 

```{r}
# NIMBLE code 
hmm.phip <- nimbleCode({
  phi ~ dunif(0, 1)      # prior survival
  p ~ dunif(0, 1)        # prior detection
  # likelihood
  gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
  gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
  gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
  gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
  delta[1] <- 1          # Pr(alive t = 1) = 1
  delta[2] <- 0          # Pr(dead t = 1) = 0
  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)
  omega[1,2] <- p        # Pr(alive t -> detected t)
  omega[2,1] <- 1        # Pr(dead t -> non-detected t)
  omega[2,2] <- 0        # Pr(dead t -> detected t)
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
# occasions of first capture
first <- apply(y, 1, function(x) min(which(x !=0)))
# constants
my.constants <- list(N = nrow(y), 
                     T = ncol(y), 
                     first = first)
# data
my.data <- list(y = y + 1)
# initial values
zinits <- y + 1 # non-detection -> alive
zinits[zinits == 2] <- 1 # dead -> alive
initial.values <- function() list(phi = runif(1,0,1),
                                  p = runif(1,0,1),
                                  z = zinits)
# parameters to monitor
parameters.to.save <- c("phi", "p")
# MCMC details
n.iter <- 5000
n.burnin <- 1000
n.chains <- 2
# run NIMBLE
mcmc.phip <- nimbleMCMC(code = hmm.phip, 
                        constants = my.constants,
                        data = my.data,              
                        inits = initial.values,
                        monitors = parameters.to.save,
                        niter = n.iter,
                        nburnin = n.burnin, 
                        nchains = n.chains)
# numerical summaries
MCMCsummary(mcmc.phip, round = 2)
```

Let's now turn to the model with time-varying survival and constant detection. We modify the CJS model NIMBLE code by no longer having the observation matrix time-specific. I'm just providing the model code to save space:
```{r eval=FALSE}
hmm.phitp <- nimbleCode({
  for (t in 1:(T-1)){
    phi[t] ~ dunif(0, 1)        # prior survival
    gamma[1,1,t] <- phi[t]      # Pr(alive t -> alive t+1)
    gamma[1,2,t] <- 1 - phi[t]  # Pr(alive t -> dead t+1)
    gamma[2,1,t] <- 0           # Pr(dead t -> alive t+1)
    gamma[2,2,t] <- 1           # Pr(dead t -> dead t+1)
  }
  p ~ dunif(0, 1) # prior detection
  delta[1] <- 1          # Pr(alive t = 1) = 1
  delta[2] <- 0          # Pr(dead t = 1) = 0
  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)
  omega[1,2] <- p        # Pr(alive t -> detected t)
  omega[2,1] <- 1        # Pr(dead t -> non-detected t)
  omega[2,2] <- 0        # Pr(dead t -> detected t)
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
```

We obtain the following numerical summaries for parameters, confirming high detection and temporal variation in survival:
```{r echo = FALSE}
load(here::here("dat","dipper.RData"))
MCMCsummary(object = mcmc.phitp, params = c("phi","p"), round = 2)
```

Now the model with time-varying detection and constant survival, for which the NIMBLE code has a constant over time transition matrix:
```{r eval=FALSE}
hmm.phipt <- nimbleCode({
  phi ~ dunif(0, 1)      # prior survival
  gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
  gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
  gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
  gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
  delta[1] <- 1          # Pr(alive t = 1) = 1
  delta[2] <- 0          # Pr(dead t = 1) = 0
  for (t in 1:(T-1)){
    p[t] ~ dunif(0, 1)       # prior detection
    omega[1,1,t] <- 1 - p[t] # Pr(alive t -> non-detected t)
    omega[1,2,t] <- p[t]     # Pr(alive t -> detected t)
    omega[2,1,t] <- 1        # Pr(dead t -> non-detected t)
    omega[2,2,t] <- 0        # Pr(dead t -> detected t)
  }
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2])
      y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1])
    }
  }
})
```

Numerical summaries for the parameters are:
```{r echo = FALSE}
load(here::here("dat","dipper.RData"))
MCMCsummary(object = mcmc.phipt, params = c("phi","p"), round = 2)
```

We note that these two models do no longer have parameter redundancy issues. 

Before we move to the next section, you might ask how to fit these models with `nimbleEcology` as in Section \@ref(nimblemarginalization). Conveniently there are specific NIMBLE functions for the marginalized likelihood of the CJS model and its derivatives. These function are named generically `dCJSxx()` where the first `x` is for survival and the second `x` is for detection and `x` can be `s` for scalar or constant or `v` for vector or time-dependent. For example, to implement the model with constant survival and detection probabilities, you would use `dCJSss()`:

```{r}
# load nimbleEcology in case we forgot previously
library(nimbleEcology)
# data
y <- dipper %>%
  select(year_1981:year_1987) %>%
  as.matrix()
y <- y[ first != ncol(y), ] # get rid of individuals for which 
                            # first detection = last capture
# NIMBLE code
hmm.phip.nimbleecology <- nimbleCode({
  phi ~ dunif(0, 1) # survival prior
  p ~ dunif(0, 1)   # detection prior
  # likelihood
  for (i in 1:N){
    y[i, first[i]:T] ~ dCJS_ss(probSurvive = phi, 
                               probCapture = p, 
                               len = T - first[i] + 1)
  }
})
# occasions of first capture
first <- apply(y, 1, function(x) min(which(x !=0)))
# constants
my.constants <- list(N = nrow(y), 
                     T = ncol(y), 
                     first = first)
# data
my.data <- list(y = y) # 0 = non-detected, 1 = detected
# initial values: marginalized likelihood, hence no latent states 
# therefore no need for initial values for latent states
initial.values <- function() list(phi = runif(1,0,1),
                                  p = runif(1,0,1))
# parameters to monitor
parameters.to.save <- c("phi", "p")
# MCMC details
n.iter <- 2500
n.burnin <- 1000
n.chains <- 2
# run NIMBLE
mcmc.phip.nimbleecology <- nimbleMCMC(code = hmm.phip.nimbleecology, 
                        constants = my.constants,
                        data = my.data,              
                        inits = initial.values,
                        monitors = parameters.to.save,
                        niter = n.iter,
                        nburnin = n.burnin, 
                        nchains = n.chains)
# numerical summaries
MCMCsummary(mcmc.phip.nimbleecology, round = 2)
```

We are left with four models, each saying a different story about the data, with temporal variation or not in either survival or detection probability. How to quantify the most plausible of these four ecological hypotheses? Rendez-vous in the next section. 


## Model comparison with WAIC {#waic}

Which of the four models above is best supported by the data? To address this question, we need to remember that we used all the observed data to fit these models. What really matters is how well each model will perform when predicting future data, a property known as predictive accuracy. A natural measure of predictive accuracy is the likelihood, often referred in the context of model comparison as the predictive density. In practice, however, we do not know the true process or the future data, so the predictive density can only be estimated, and with some bias. 

You may have heard about the Akaike Information Criterion (AIC) in the frequentist framework, and the Deviance Information Criterion (DIC) in the Bayesian framework. Here, we will also consider the Widely Applicable Information Criterion or Watanabe Information Criterion (WAIC). AIC, DIC and WAIC each aim to provide an approximation of predictive accuracy. 

While AIC is the predictive measure of choice in the frequentist framework for ecologists, DIC has been around for some time for Bayesian applications due to its availability in popular BUGS pieces of software. However, AIC and BIC use a point estimate of the unknown parameters, while we have access to their entire (posterior) distribution with the Bayesian approach. Also, DIC has been shown to misbehave when the posterior distribution is not well summarized by its mean. For a more fully Bayesian approach we would like to use the entire posterior distribution to evaluate the predictive performance, which is exactly what WAIC does. 

Conveniently, NIMBLE calculates WAIC for you. The only modification you need to make is to add `WAIC = TRUE` in the call to the `nimbleMCMC()` function. For example, for the CJS model, we write:
```{r eval = FALSE}
mcmc.phitpt <- nimbleMCMC(code = hmm.phitpt,
                          constants = my.constants,
                          data = my.data,
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter,
                          nburnin = n.burnin,
                          nchains = n.chains,
                          WAIC = TRUE) 
```

<!-- To obtain WAIC, set WAIC = TRUE in nimbleMCMC. If using a more customized workflow, set enableWAIC = TRUE in configureMCMC or (if skipping configureMCMC) in buildMCMC, followed by setting WAIC = TRUE in runMCMC, if using runMCMC to manage sample generation.  -->

I re-ran the four models to calculate the WAIC value for each of them
```{r eval = FALSE}
data.frame(model = c("both survival & detection constant",
                     "time-dependent survival, constant detection",
                     "constant survival, time-dependent detection",
                     "both survival & detection time-dependent"),
           WAIC = c(mcmc.phip$WAIC$WAIC,
                    mcmc.phitp$WAIC$WAIC,
                    mcmc.phipt$WAIC$WAIC,
                    mcmc.phitpt$WAIC$WAIC))
```{r echo = FALSE}
load(here::here("dat","dipper_waic.RData"))
data.frame(model = c("both survival & detection constant",
                     "time-dependent survival, constant detection",
                     "constant survival, time-dependent detection",
                     "both survival & detection time-dependent"),
           WAIC = c(mcmc.phip$WAIC$WAIC,
                    mcmc.phitp$WAIC$WAIC,
                    mcmc.phipt$WAIC$WAIC,
                    mcmc.phitpt$WAIC$WAIC))
```

Lower values of WAIC imply higher predictive accuracy, thefore we would favor model with constant parameters.

## Goodness of fit {#gof}

In the previous section, Section \@ref(waic), we compared models between each other based on their predictive accuracy -- we assessed their *relative* fit. However, even though we were able to rank these models according to predictive accuracy, it could happen that all models actually had poor predictive performance -- this has to do with *absolute* fit. 

How to assess the goodness of fit of the CJS model to capture-recapture data? 

### Posterior predictive checks

In the Bayesian framework, we use posterior predictive checks to assess absolute model fit. The basic idea is to compare the observed data with replicated data generated from the model. If the model is a good fit to the data, then the replicated data predicted from the model should look similar to the observed data. To make the comparison tractable, some summary statistics are generally used. For the CJS model, this is often done with the m-array, which records the number of individuals released in a given year and first recaptured in subsequent years. For examples, see @KerySchaub2011, @paganin2023computational, and the NIMBLE website https://r-nimble.org/examples/posterior_predictive.html.

Posterior predictive checks are powerful tools. However, there are long-established procedures for evaluating absolute fit and diagnosing violations of specific CJS model assumptions, and it would be a shame to ignore them. 

<!-- Classical m-array (minimal sufficient statistics for CJS model) as in . Individual performance in @chambert2014 and @nater2020trout. Sojourn time is geometric assumption in @conn2018. -->

<!-- For the CJS model, we would use the so-called m-array which gathers the elements $m_{ij}$ for the number of marked individuals initially released at time $i$ that were first detected again at time $j$.  -->

<!-- Refer to a case study. With m-array and Nimble functions. Refer to paper by Paganin & de Valpine and use code in https://github.com/salleuska/fastCPPP. Also papers by Chambert et al. (individual performance) and Conn et al. (geometric time, and hidden semi-Markov models). See my repo on ppp checks.  -->

<!-- This has an m-array structure. The number of individuals released at occasion $i$ ($R_i$) and the number of first recaptures at occasion $j$, given release at occasion $i$ ($m_{ij}$) are provided. For example, 38 birds were released in 1969 among which, 22 were first recaptured in 1970, and 16 (= 38 - 22) were never observed again. -->

### Classical tests

We focus here on two assumptions that have an ecological interpretation: transience and trap-dependence. The transience test evaluates whether newly encountered individuals are as likely to be detected again as previously encountered ones. A signal of transience is often seen as an excess of individuals never seen again. The trap-dependence test evaluates whether individuals that were not detected at a given occasion are as likely to be detected at the next occasion as those that were. Trap-dependence is often seen as an effect of trapping on detection. Although these tests are commonly referred to as the test of transience and the test of trap-dependence, you should keep in mind that transience and trap-dependence are only two possible reasons why these tests may reveal a lack of fit.

These tests are implemented in the package `R2ucare`, and we illustrate its use with the dipper data.

We load the package `R2ucare`:
```{r}
# To install the R2ucare package:
# if(!require(devtools)) install.packages("devtools")
# devtools::install_github("oliviergimenez/R2ucare")
library(R2ucare)
```

We get the capture-recapture data:
```{r}
# capture-recapture data
dipper <- read_csv("dat/dipper.csv")
# get encounter histories
y <- dipper %>%
  select(year_1981:year_1987) %>%
  as.matrix()
# number of birds with a particular capture-recapture history
size <- rep(1, nrow(y))
```

<!-- The overall test shows that we cannot reject the hypothesis that the CJS models fits the data well: -->
<!-- ```{r} -->
<!-- overall_CJS(y, size) -->
<!-- ``` -->

We may perform a test specifically to assess a transient effect:
```{r}
test3sr(y, size)
```

Or trap-dependence:
```{r}
test2ct(y, size)
```

None of these tests is significant, but what to do if these tests are significant? 
Transience can occur for different reasons. Some animals may simply pass through without belonging to the study population (true transients). Others may reproduce once and then die or permanently disperse, reflecting the cost of first reproduction. In some cases, marking itself may cause individuals to die or leave the area. Whatever the cause, these transient individuals are never detected again after their initial capture, so their probability of local survival is zero after initial capture.

This suggests a way to account for transience by modeling a two-age class effect on survival, where age here refers not to biological age but to time since first capture. The first age class, Age 1, corresponds to newly marked in the interval immediately following capture. This is where transients live: if they are true transients, they will never be seen again because their local survival after marking is effectively 0. The second age class, Age 2+ corresponds to established residents and all subsequent intervals for individuals that remained in the study population beyond the first interval. 

We allow survival to differ between these two ages, defining $\phi_1$ as the apparent survival in the first interval after initial capture, and $\phi_{2+}$ as the apparent survival in all subsequent intervals. If there are transients, $\phi_1$ will be pulled lower than $\phi_{2+}$, since the first interval mixes true residents (who survive locally with probability $\phi_{2+}$) and transients (who never survive locally to the next occasion). A useful quantity to compute here is the transient proportion $\tau$, defined as $\displaystyle \tau = 1 - \frac{\phi_{1}}{\phi_{2+}}$. 

We will later see in Section \@ref(agecov) how to encode an age effect on survival, and I will use this approach I just described to account for transience in Section \@ref(trapdep). Note also that transience can be represented through states in a HMM [see @genovart2019 for more details].

Trap-dependence may arise in several ways. It can occur when animals are directly affected by trapping, either positively or negatively (true trap-dependence). It may also result from observers visiting some parts of the study area more often after individuals have been detected (preferential sampling), or from habitat heterogeneity, where some patches are more accessible and individuals located there have higher detection probabilities (access bias). Trap-dependence can also reflect individual differences in age, sex, or social status that influence movements or activity patterns and thus detection probability (individual heterogeneity). Finally, it may arise when temporary emigration is non-random, for instance if individuals skip reproduction (skipped reproduction).

In short, trap-dependence designates some form of correlation between detection events. To address this issue, this correlation needs to be accounted for, and we show how to do so in a case study at Section \@ref(trapdep).

### Design considerations

So far, we have considered assumptions related to the model. There are also assumptions tied to the study design. In particular, when we talk about survival, it is always in reference to the study area, and we need to be clear about what this means. What we estimate is usually called *apparent* survival, not *true* survival. Apparent survival is the product of true survival and site fidelity, and is therefore always lower than true survival unless fidelity equals one.

Other design assumptions are worth noting, which I only list here. Marks should not be lost, individual identity should be recorded without error (no false positives), and captured animals should represent a random sample of the population.

## Covariates {#covariates}

In the models we have considered so far, survival and detection probabilities may vary over time, but we do not include ecological drivers that might explain these variation. Luckily, in the spirit of generalized linear models, we can make these parameters dependent on external covariates over time, such as environmental conditions for survival or sampling effort for detection. 

Besides variation over time, we will also cover individual variation in these parameters, in which for example survival vary according to sex or some phenotypic characteristics (e.g. size or body mass). 

Let's illustrate the use of covariates with the dipper example. 

### Temporal covariates

#### Discrete 

A major flood occurred during the 1983 breeding season (from October 1982 to May 1983). Because captures during the breeding season occurred before and after the flood, survival in the two years 1982-1983 and 1983-1984 were likely to be affected. Indeed survival of a species living along and feeding in the river in these two flood years was most likely lower than in nonflood years. Here we will use a discrete or categorical covariate, or a group.

Let's use a covariate `flood` that contains 1s and 2s, indicating whether we are in a flood or nonflood year for each year: 1 if nonflood year, and 2 if flood year. 
```{r eval = FALSE}
flood <- c(1, # 1981-1982 (nonflood)
           2, # 1982-1983 (flood)
           2, # 1983-1984 (flood)
           1, # 1984-1985 (nonflood)
           1, # 1985-1986 (nonflood)
           1) # 1986-1987 (nonflood)
```

Then we write the model code: 
```{r eval = FALSE}
hmm.phifloodp <- nimbleCode({
  delta[1] <- 1                        # Pr(alive t = 1) = 1
  delta[2] <- 0                        # Pr(dead t = 1) = 0
  for (t in 1:(T-1)){
    gamma[1,1,t] <- phi[flood[t]]      # Pr(alive t -> alive t+1)
    gamma[1,2,t] <- 1 - phi[flood[t]]  # Pr(alive t -> dead t+1)
    gamma[2,1,t] <- 0                  # Pr(dead t -> alive t+1)
    gamma[2,2,t] <- 1                  # Pr(dead t -> dead t+1)
  }
  p ~ dunif(0, 1)        # prior detection
  omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)
  omega[1,2] <- p        # Pr(alive t -> detected t)
  omega[2,1] <- 1        # Pr(dead t -> non-detected t)
  omega[2,2] <- 0        # Pr(dead t -> detected t)
  phi[1] ~ dunif(0, 1)   # prior for survival in nonflood years
  phi[2] ~ dunif(0, 1)   # prior for survival in flood years
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
```

We use nested indexing above when specifying survival in the transition matrix. E.g. for year $t = 2$, `phi[flood[t]]` gives `phi[flood[2]]` which will be `phi[2]` because `flood[2]` is 2 that (a flood year).

Let's provide the constants in a list: 
```{r eval = FALSE}
my.constants <- list(N = nrow(y),
                     T = ncol(y),
                     first = first,
                     flood = flood)
```

Now a function to generate initial values:
```{r eval = FALSE}
initial.values <- function() list(phi = runif(2,0,1),
                                  p = runif(1,0,1),
                                  z = zinits)
```

The parameters to be monitored:
```{r eval = FALSE}
parameters.to.save <- c("p", "phi")
```

The MCMC details:
```{r eval = FALSE}
n.iter <- 5000
n.burnin <- 1000
n.chains <- 2
```

We're all set, and we run NIMBLE: 
```{r eval = FALSE}
mcmc.phifloodp <- nimbleMCMC(code = hmm.phifloodp, 
                             constants = my.constants,
                             data = my.data,              
                             inits = initial.values,
                             monitors = parameters.to.save,
                             niter = n.iter,
                             nburnin = n.burnin, 
                             nchains = n.chains)
```

The numerical summaries are given by:
```{r eval = FALSE}
MCMCsummary(mcmc.phifloodp, round = 2)
```
```{r, echo = FALSE}
load(here::here("dat/phifloodpni.RData"))
MCMCsummary(mcmc.phifloodp, round = 2)
```

Having a look to the numerical summaries, we see that as expected, survival in flood years (`phi[2]`) is much lower than survival in non-flood years (`phi[1]`). You could formally test this difference by considering the difference `phi[1] - phi[2]`. Alternatively, this can be done afterwards and calculating the probability that this difference is positive (or `phi[1] > phi[2]`). Using a single chain for convenience, we do:

```{r}
phi1 <- mcmc.phifloodp$chain1[,'phi[1]']
phi2 <- mcmc.phifloodp$chain1[,'phi[2]']
mean(phi1 - phi2 > 0)
```

An important point here is that we formulated an ecological hypothesis which we translated into a model. The next step would consist in calculating WAIC for this model and compare it with that of the four other model we have fitted so far (see Section \@ref(waic)). 

<!-- **Do it, and explain difference between conditional and marginal WAIC.** -->

Another method to include a discrete covariate consists in considering the effect of the difference between its levels. For example, we could consider survival in nonflood years as the reference and test the difference in survival with flood years. 

To do so, we write survival as a linear function of our covariate on some scale, e.g. $\text{logit}(\phi_t) = \beta_1 + \beta_2 \;\text{flood}_t$ where the $\beta$'s are regression coefficients we need to estimate (intercept $\beta_1$ and slope $\beta_2$), and $\text{logit}(x) = \log \displaystyle{\left(\frac{x}{1-x}\right)}$ is the logit function. The logit function lives between $-\infty$ and $+\infty$, and sends values between 0 and 1 onto the real line. For example $\log(0.2/(1-0.2))=-1.39$, $\log(0.5/(1-0.5))=0$ and $\log(0.8/(1-0.8))=1.39$. Why use the logit function? Because survival is a probability bounded between 0 and 1, and if we used directly $\phi_t = \beta_1 + \beta_2 \;\text{flood}_t$ we might end up with estimates for the regression coefficients that make survival out of bound. Therefore, we consider survival as a linear function of our covariates on the scale of the logit function, working on the real line, then back-transform using the inverse-logit (reciprocal function) to obtain survival on its natural scale. The inverse-logit function is $\displaystyle{\text{logit}^{-1}(x) = \frac{\exp(x)}{1+\exp(x)} = \frac{1}{1+\exp(-x)}}$. The logit function is often called a link function like in generalized linear models. Other link functions exist, we'll see an example in Section \@ref(multinomiallogit). 

Another point of attention is the prior we will assign to regression coefficients. We no longer assign a prior to survival directly like previously, but we need to assign prior to the $\beta$'s which will induce some prior on survival. And sometimes, your priors on the regression coefficients are non-informative, but the prior on survival is not. Consider for example the case of a single intercept with no covariate. If you assign as a prior to this regression coefficient a normal distribution with mean 0 and large standard deviation (left figure below), which would be my first reflex, then you end up with a very informative prior on survival with a bathtub shape, putting much importance on low and high values (right figure below):
```{r}
# 1000 random values from a N(0,10)
intercept <- rnorm(1000, mean = 0, sd = 10) 
# plogis() is the inverse-logit function in R
survival <- plogis(intercept) 
df <- data.frame(intercept = intercept, survival = survival)
plot1 <- df %>%
  ggplot(aes(x = intercept)) +
  geom_density() +
  labs(x = "prior on intercept")
plot2 <- df %>%
  ggplot(aes(x = survival)) +
  geom_density() +
  labs(x = "prior on survival")
plot1 + plot2
```

Now if you go for a lower standard deviation for the intercept prior (left figure below), e.g. 1.5, the prior on survival is non-informative, looking like a uniform distribution between 0 and 1 (right figure below):
```{r}
set.seed(123)
# 1000 random values from a N(0,1.5)
intercept <- rnorm(1000, mean = 0, sd = 1.5) 
# plogis() is the inverse-logit function in R
survival <- plogis(intercept) 
df <- data.frame(intercept = intercept, survival = survival)
plot1 <- df %>%
  ggplot(aes(x = intercept)) +
  geom_density() +
  labs(x = "prior on intercept")
plot2 <- df %>%
  ggplot(aes(x = survival)) +
  geom_density() +
  labs(x = "prior on survival")
plot1 + plot2
```

Now let's go back to our model. We first define our flood covariate with 0 if nonflood year, and 1 if flood year:
```{r eval = FALSE}
flood <- c(0, # 1981-1982 (nonflood)
           1, # 1982-1983 (flood)
           1, # 1983-1984 (flood)
           0, # 1984-1985 (nonflood)
           0, # 1985-1986 (nonflood)
           0) # 1986-1987 (nonflood)
```

Then we write the NIMBLE code:
```{r eval = FALSE}
hmm.phifloodp <- nimbleCode({
  delta[1] <- 1                 # Pr(alive t = 1) = 1
  delta[2] <- 0                 # Pr(dead t = 1) = 0
  for (t in 1:(T-1)){
    logit(phi[t]) <- beta[1] + beta[2] * flood[t]
    gamma[1,1,t] <- phi[t]      # Pr(alive t -> alive t+1)
    gamma[1,2,t] <- 1 - phi[t]  # Pr(alive t -> dead t+1)
    gamma[2,1,t] <- 0           # Pr(dead t -> alive t+1)
    gamma[2,2,t] <- 1           # Pr(dead t -> dead t+1)
  }
  p ~ dunif(0, 1)               # prior detection
  omega[1,1] <- 1 - p           # Pr(alive t -> non-detected t)
  omega[1,2] <- p               # Pr(alive t -> detected t)
  omega[2,1] <- 1               # Pr(dead t -> non-detected t)
  omega[2,2] <- 0               # Pr(dead t -> detected t)
  beta[1] ~ dnorm(0, sd = 1.5)  # prior intercept
  beta[2] ~ dnorm(0, sd = 1.5)  # prior slope
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
```

We wrote $\text{logit}(\phi_t) = \beta_1 + \beta_2 \; \text{flood}_t$, meaning that survival in nonflood years ($\text{flood}_t = 0$) is $\text{logit}(\phi_t) = \beta_1$ and survival in flood years ($\text{flood}_t = 1$) is $\text{logit}(\phi_t) = \beta_1 + \beta_2$. We see that $\beta_1$ is survival in nonflood years (on the logit scale) and $\beta_2$ is the difference between survival in flood years and survival in nonflood years (again, on the logit scale). In passing we assigned the same prior for both $\beta_1$ and $\beta_2$ but in certain situations, we might think twice before doing that as $\beta_2$ is a difference between two survival probabilities (on the logit scale). 

Let's put our constants in a list:
```{r eval = FALSE}
my.constants <- list(N = nrow(y),
                     T = ncol(y),
                     first = first,
                     flood = flood)
```

Then our function for generating initial values: 
```{r eval = FALSE}
initial.values <- function() list(beta = rnorm(2,0,1),
                                  p = runif(1,0,1),
                                  z = zinits)
```

And the parameters to be monitored: 
```{r eval = FALSE}
parameters.to.save <- c("beta", "p", "phi")
```

Finaly, we run NIMBLE: 
```{r eval = FALSE}
mcmc.phifloodp <- nimbleMCMC(code = hmm.phifloodp, 
                             constants = my.constants,
                             data = my.data,              
                             inits = initial.values,
                             monitors = parameters.to.save,
                             niter = n.iter,
                             nburnin = n.burnin, 
                             nchains = n.chains)
```

You may check that we get the same numerical summaries as above for survival in nonflood years (`phi[1]`, `phi[4]`, `phi[5]` and `phi[6]`) and flood years (`phi[2]` and `phi[3]`):
```{r eval = FALSE}
MCMCsummary(mcmc.phifloodp, round = 2)
```
```{r, echo = FALSE}
load(here::here("dat/phifloodp.RData"))
MCMCsummary(mcmc.phifloodp, round = 2)
```

You may also check how to go from the $\beta$'s to the survival probabilities $\phi$. Let's get the draws from the posterior distribution of the $\beta$'s first: 
```{r}
beta1 <- c(mcmc.phifloodp$chain1[,'beta[1]'], # beta1 chain 1
           mcmc.phifloodp$chain2[,'beta[1]']) # beta1 chain 2
beta2 <- c(mcmc.phifloodp$chain1[,'beta[2]'], # beta2 chain 1
           mcmc.phifloodp$chain2[,'beta[2]']) # beta2 chain 2
```

Then apply the inverse-logit function to get survival in nonflood years, e.g. its posterior mean and credible interval:
```{r}
mean(plogis(beta1))
quantile(plogis(beta1), probs = c(2.5, 97.5)/100)
```

Same thing for survival in flood years:
```{r}
mean(plogis(beta1 + beta2))
quantile(plogis(beta1 + beta2), probs = c(2.5, 97.5)/100)
```

#### Continuous

Instead of a discrete covariate varying over time, we may want to consider a continuous covariate, say $x_t$, through $\text{logit}(\phi_t) = \beta_1 + \beta_2 x_t$. For example, let's investigate the effect of water flow on dipper survival, which should reflect the flood that occurred during the 1983 breeding season. 

We build a covariate with water flow in liters per second measured during the March to May period each year, starting with year 1982:
```{r eval = FALSE}
# water flow in L/s
water_flow <- c(443,  # March-May 1982
                1114, # March-May 1983
                529,  # March-May 1984
                434,  # March-May 1985
                627,  # March-May 1986
                466)  # March-May 1987
```

We do not need water flow in 1981 because we will write the probability $\phi_t$ of being alive in year $t + 1$ given a bird was alive in year $t$ as a linear function of the water flow in year $t + 1$. 

You may have noticed the high value of water flow for 1983, twice as much as in the other years, corresponding to the flood. Importantly, we standardize our covariate to improve convergence:
```{r eval = FALSE}
water_flow_st <- (water_flow - mean(water_flow))/sd(water_flow)
```

Now we write the model code:
```{r eval = FALSE}
hmm.phiflowp <- nimbleCode({
  delta[1] <- 1                 # Pr(alive t = 1) = 1
  delta[2] <- 0                 # Pr(dead t = 1) = 0
  for (t in 1:(T-1)){
    logit(phi[t]) <- beta[1] + beta[2] * flow[t] 
    gamma[1,1,t] <- phi[t]      # Pr(alive t -> alive t+1)
    gamma[1,2,t] <- 1 - phi[t]  # Pr(alive t -> dead t+1)
    gamma[2,1,t] <- 0           # Pr(dead t -> alive t+1)
    gamma[2,2,t] <- 1           # Pr(dead t -> dead t+1)
  }
  p ~ dunif(0, 1)               # prior detection
  omega[1,1] <- 1 - p           # Pr(alive t -> non-detected t)
  omega[1,2] <- p               # Pr(alive t -> detected t)
  omega[2,1] <- 1               # Pr(dead t -> non-detected t)
  omega[2,2] <- 0               # Pr(dead t -> detected t)
  beta[1] ~ dnorm(0, 1.5)       # prior intercept
  beta[2] ~ dnorm(0, 1.5)       # prior slope
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
```

We put the constants in a list: 
```{r eval = FALSE}
my.constants <- list(N = nrow(y),
                     T = ncol(y),
                     first = first,
                     flow = water_flow_st)
```

Initial values as usual: 
```{r eval = FALSE}
initial.values <- function() list(beta = rnorm(2,0,1),
                                  p = runif(1,0,1),
                                  z = zinits)
```

And parameters to be monitored:
```{r eval = FALSE}
parameters.to.save <- c("beta", "p", "phi")
```

Eventually, we run NIMBLE: 
```{r eval = FALSE}
mcmc.phiflowp <- nimbleMCMC(code = hmm.phiflowp, 
                          constants = my.constants,
                          data = my.data,              
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter,
                          nburnin = n.burnin, 
                          nchains = n.chains)
```

We can have a look to the results through a caterpillar plot of the regression parameters: 
```{r, eval = FALSE}
MCMCplot(object = mcmc.phiflowp, params = "beta")
```
```{r, echo = FALSE}
load(here::here("dat/dipperflow.RData"))
MCMCplot(object = mcmc.phiflowp, params = "beta")
```

The posterior distribution of the slope (`beta[2]`) is centered on negative values, suggesting that as water flow increases, survival decreases.

Let's inspect the time-dependent survival probability:
```{r, eval = FALSE}
MCMCplot(object = mcmc.phiflowp, params = "phi", ISB = TRUE)
```
```{r, echo = FALSE}
load(here::here("dat/dipperflow.RData"))
MCMCplot(object = mcmc.phiflowp, params = "phi", ISB = TRUE)
```

Survival between 1982 and 1983 (`phi[2]`) was greatly affected and much lower than on average. This decrease corresponds to the high water flow in 1983 and the flood. These results are in line with our previous findings obtained by considering a discrete covariate for nonflood vs. flood years.

### Individual covariates

In the previous section, we learnt how to explain temporal heterogeneity in survival and detection. Heterogeneity could also originate from individual differences between animals. You may think of a diffence in survival between males and females for a discrete covariate example, or size and body mass for examples of a continuous covariate. Let's illustrate both discrete and continuous covariates on the dipper. 

#### Discrete

We first consider a covariate `sex` that contains 1's and 2's indicating the sex of each bird: 1 if male, and 2 if female. We implement the model with sex effect using nested indexing, similarly to the model with flood vs. nonflood years. The section of the NIMBLE code that needs to be amended is:
```{r eval = FALSE}
...
for (i in 1:N){
  gamma[1,1,i] <- phi[sex[i]]      # Pr(alive t -> alive t+1)
  gamma[1,2,i] <- 1 - phi[sex[i]]  # Pr(alive t -> dead t+1)
  gamma[2,1,i] <- 0                # Pr(dead t -> alive t+1)
  gamma[2,2,i] <- 1                # Pr(dead t -> dead t+1)
}
phi[1] ~ dunif(0,1) # male survival
phi[2] ~ dunif(0,1) # female survival
...
```

After running NIMBLE, we get:
```{r eval = FALSE}
MCMCsummary(object = mcmc.phisexp.ni, round = 2)
```
```{r echo = FALSE}
load(here::here("dat/phisexpni.RData"))
MCMCsummary(object = mcmc.phisexp.ni, round = 2)
```

Male survival (`phi[1]`) looks very similar to female survival (`phi[2]`).

#### Continuous 

Besides discrete individual covariates, you might want to have continuous individual covariates, e.g. wing length in the dipper example. Note that we're considering an individual trait that takes the same value whatever the occasion. We consider wing length here, and more precisely its measurement at first detection. We first standardize the covariate: 
```{r}
wing.length.st <- as.vector(scale(dipper$wing_length))
head(wing.length.st)
```

Now we write the model:
```{r eval = FALSE}
hmm.phiwlp <- nimbleCode({
    p ~ dunif(0, 1)             # prior detection
    omega[1,1] <- 1 - p         # Pr(alive t -> non-detected t)
    omega[1,2] <- p             # Pr(alive t -> detected t)
    omega[2,1] <- 1             # Pr(dead t -> non-detected t)
    omega[2,2] <- 0             # Pr(dead t -> detected t)
  for (i in 1:N){
    logit(phi[i]) <- beta[1] + beta[2] * winglength[i]
    gamma[1,1,i] <- phi[i]      # Pr(alive t -> alive t+1)
    gamma[1,2,i] <- 1 - phi[i]  # Pr(alive t -> dead t+1)
    gamma[2,1,i] <- 0           # Pr(dead t -> alive t+1)
    gamma[2,2,i] <- 1           # Pr(dead t -> dead t+1)
  }
  beta[1] ~ dnorm(mean = 0, sd = 1.5)
  beta[2] ~ dnorm(mean = 0, sd = 1.5)
  delta[1] <- 1                 # Pr(alive t = 1) = 1
  delta[2] <- 0                 # Pr(dead t = 1) = 0
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, i])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
```

We put the constants in a list:
```{r eval = TRUE}
my.constants <- list(N = nrow(y), 
                     T = ncol(y), 
                     first = first,
                     winglength = wing.length.st)
```

We write a function for generating initial values:
```{r eval = FALSE}
initial.values <- function() list(beta = rnorm(2,0,1),
                                  p = runif(1,0,1),
                                  z = zinits)
```

And we run NIMBLE:
```{r eval = FALSE}
mcmc.phiwlp <- nimbleMCMC(code = hmm.phiwlp, 
                          constants = my.constants,
                          data = my.data,              
                          inits = initial.values,
                          monitors = parameters.to.save,
                          niter = n.iter,
                          nburnin = n.burnin, 
                          nchains = n.chains)
```

Let's inspect the numerical summaries for the regression parameters: 
```{r eval = FALSE}
MCMCsummary(mcmc.phiwlp, params = "beta", round = 2)
```
```{r echo = FALSE}
load(here::here("dat/phiwlp.RData"))
MCMCsummary(mcmc.phiwlp, params = "beta", round = 2)
```

Wing length does not seem to explain much individual-to-individual variation in survival -- the posterior distribution of the slope (`beta[2]`) is centered on 0 as we can see from the credible interval. 

Let's plot the relationship between survival and wing length. First, we gather the values generated from the posterior distribution of the regression parameters in the two chains:
```{r}
beta1 <- c(mcmc.phiwlp$chain1[,'beta[1]'], # intercept, chain 1
           mcmc.phiwlp$chain2[,'beta[1]']) # intercept, chain 2
beta2 <- c(mcmc.phiwlp$chain1[,'beta[2]'], # slope, chain 1
           mcmc.phiwlp$chain2[,'beta[2]']) # slope, chain 2
```

Then we define a grid of values for wing length, and predict survival for each MCMC iteration:
```{r}
predicted_survival <- matrix(NA, 
                             nrow = length(beta1), 
                             ncol = length(my.constants$winglength))
for (i in 1:length(beta1)){
  for (j in 1:length(my.constants$winglength)){
    predicted_survival[i,j] <- plogis(beta1[i] + 
                               beta2[i] * my.constants$winglength[j])
  }
}
```

Now we calculate posterior mean and the credible interval (note the ordering):
```{r}
mean_survival <- apply(predicted_survival, 2, mean)
lci <- apply(predicted_survival, 2, quantile, prob = 2.5/100)
uci <- apply(predicted_survival, 2, quantile, prob = 97.5/100)
ord <- order(my.constants$winglength)
df <- data.frame(wing_length = my.constants$winglength[ord],
                 survival = mean_survival[ord],
                 lci = lci[ord],
                 uci = uci[ord])
```

Now time to visualize: 
```{r}
df %>%
  ggplot() + 
  aes(x = wing_length, y = survival) + 
  geom_line() + 
  geom_ribbon(aes(ymin = lci, ymax = uci), 
              fill = "grey70", 
              alpha = 0.5) + 
  ylim(0,1) + 
  labs(x = "wing length", y = "estimated survival")
```

The flat relationship between survival and wing length is confirmed. 

### Several covariates

You may wish to have an effect of both sex and wing length in a model. Let's consider an additive effect of both covariates. We use a covariate `sex` that takes value 0 if male, and 1 if female. We have $\text{logit}(\phi_i) = \beta_1 + \beta_2 \text{sex}_i + \beta_3 \text{winglength}_i$ for bird $i$, so that male survival is $\beta_1 + \beta_3 \text{winglength}_i$ and female survival is $\beta_1 + \beta_2 + \beta_3 \text{winglength}_i$ (both on the logit scale). The relationship between survival and wing length is parallel between males and females, on the logit scale, and the gap between the two is measured by $\beta_2$ (hence the term *additive* effect). 

The NIMBLE code is:
```{r eval = FALSE}
hmm.phisexwlp <- nimbleCode({
  p ~ dunif(0, 1)               # prior detection
  omega[1,1] <- 1 - p           # Pr(alive t -> non-detected t)
  omega[1,2] <- p               # Pr(alive t -> detected t)
  omega[2,1] <- 1               # Pr(dead t -> non-detected t)
  omega[2,2] <- 0               # Pr(dead t -> detected t)
  for (i in 1:N){
    logit(phi[i])<-beta[1]+beta[2]*sex[i]+beta[3]*winglength[i]
    gamma[1,1,i] <- phi[i]      # Pr(alive t -> alive t+1)
    gamma[1,2,i] <- 1 - phi[i]  # Pr(alive t -> dead t+1)
    gamma[2,1,i] <- 0           # Pr(dead t -> alive t+1)
    gamma[2,2,i] <- 1           # Pr(dead t -> dead t+1)
  }
  beta[1] ~ dnorm(mean = 0, sd = 1.5) # intercept male
  beta[2] ~ dnorm(mean = 0, sd = 1.5) # diff bw male and female
  beta[3] ~ dnorm(mean = 0, sd = 1.5) # slope wing length
  delta[1] <- 1                 # Pr(alive t = 1) = 1
  delta[2] <- 0                 # Pr(dead t = 1) = 0
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, i])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
```

We put constants and data in lists:
```{r eval = FALSE}
first <- apply(y, 1, function(x) min(which(x !=0)))
wing.length.st <- as.vector(scale(dipper$wing_length))
my.constants <- list(N = nrow(y), 
                     T = ncol(y), 
                     first = first,
                     winglength = wing.length.st,
                     sex = if_else(dipper$sex == "M", 0, 1))
my.data <- list(y = y + 1)
```

We write a fuction to generate initial values:
```{r eval = FALSE}
zinits <- y
zinits[zinits == 0] <- 1
initial.values <- function() list(beta = rnorm(3,0,2),
                                  p = runif(1,0,1),
                                  z = zinits)
```

We specify the parameters to be monitored:
```{r eval = FALSE}
parameters.to.save <- c("beta", "p")
```

The MCMC details (note that we need to increase the number of iterations to achieve satisfying effective sample sizes):
```{r eval = FALSE}
n.iter <- 5000*4
n.burnin <- 1000
n.chains <- 2
```


And now we run NIMBLE:
```{r eval = FALSE}
mcmc.phisexwlp <- nimbleMCMC(code = hmm.phisexwlp, 
                             constants = my.constants,
                             data = my.data,              
                             inits = initial.values,
                             monitors = parameters.to.save,
                             niter = n.iter,
                             nburnin = n.burnin, 
                             nchains = n.chains)
```

Let's display numerical summaries for all parameters:
```{r eval = FALSE}
MCMCsummary(mcmc.phisexwlp, round = 2)
```
```{r echo = FALSE}
load(here::here("dat/phisexwlp.RData"))
MCMCsummary(mcmc.phisexwlp, round = 2)
```

The slope `beta[3]` is the same for both males and females. Although its posterior mean is negative, its crebible interval suggests that its posterior distribution largely encompasses 0, therefore a very weak signal, if any.

Let's visualize survival as a function of wing length for both sexes. First we put together the values from the two chains we generated in the posterior distributions of the regression parameters: 
```{r}
beta1 <- c(mcmc.phisexwlp$chain1[,'beta[1]'], # beta1 chain 1
           mcmc.phisexwlp$chain2[,'beta[1]']) # beta1 chain 2
beta2 <- c(mcmc.phisexwlp$chain1[,'beta[2]'], # beta2 chain 1
           mcmc.phisexwlp$chain2[,'beta[2]']) # beta2 chain 2
beta3 <- c(mcmc.phisexwlp$chain1[,'beta[3]'], # beta3 chain 1
           mcmc.phisexwlp$chain2[,'beta[3]']) # beta3 chain 2
```

We get survival estimates for each MCMC iteration:
```{r}
predicted_survivalM <- matrix(NA, nrow = length(beta1), 
                              ncol=length(my.constants$winglength))
predicted_survivalF <- matrix(NA, nrow = length(beta1), 
                              ncol=length(my.constants$winglength))
for (i in 1:length(beta1)){
  for (j in 1:length(my.constants$winglength)){
    predicted_survivalM[i,j] <- plogis(beta1[i] + 
                                beta3[i]*my.constants$winglength[j]) 
    predicted_survivalF[i,j] <- plogis(beta1[i] + 
                                beta2[i] + 
                                beta3[i]*my.constants$winglength[j])
  }
}
```

From here, we may calculate posterior mean and credible intervals:
```{r}
mean_survivalM <- apply(predicted_survivalM, 2, mean)
lciM <- apply(predicted_survivalM, 2, quantile, prob = 2.5/100)
uciM <- apply(predicted_survivalM, 2, quantile, prob = 97.5/100)
mean_survivalF <- apply(predicted_survivalF, 2, mean)
lciF <- apply(predicted_survivalF, 2, quantile, prob = 2.5/100)
uciF <- apply(predicted_survivalF, 2, quantile, prob = 97.5/100)
ord <- order(my.constants$winglength)
df <- data.frame(wing_length = c(my.constants$winglength[ord], 
                                 my.constants$winglength[ord]),
                 survival = c(mean_survivalM[ord], 
                              mean_survivalF[ord]),
                 lci = c(lciM[ord],lciF[ord]),
                 uci = c(uciM[ord],uciF[ord]),
                 sex = c(rep("male", length(mean_survivalM)), 
                         rep("female", length(mean_survivalF))))
```

Now on a plot:
```{r}
if (params$bw) {
  df %>%
    ggplot(aes(x = wing_length, y = survival, color = sex, fill = sex)) + 
    geom_line() +
    geom_ribbon(aes(ymin = lci, ymax = uci), alpha = 0.3) +
    ylim(0, 1) +
    labs(x = "wing length",
         y = "estimated survival",
         color = "", fill = "") +
    scale_color_manual(values = c("black", "grey40")) +
    scale_fill_manual(values  = c("grey70", "grey10"))
} else {
  df %>%
    ggplot() + 
    aes(x = wing_length, y = survival, color = sex) + 
    geom_line() + 
    geom_ribbon(aes(ymin = lci, ymax = uci, fill = sex), alpha = 0.5) + 
    ylim(0,1) + 
    labs(x = "wing length", 
         y = "estimated survival", 
         color = "", fill = "")
}
```

Note that the two curves are not exactly parallel because we back-transformed the linear part of the relationship between survival and wing length. You may check that parallelism occurs on the logit scale:
```{r}
predicted_lsurvivalM <- matrix(NA, nrow = length(beta1), 
                              ncol = length(my.constants$winglength))
predicted_lsurvivalF <- matrix(NA, nrow = length(beta1), 
                              ncol = length(my.constants$winglength))
for (i in 1:length(beta1)){
  for (j in 1:length(my.constants$winglength)){
    predicted_lsurvivalM[i,j] <- beta1[i] + 
      beta3[i] * my.constants$winglength[j] 
    predicted_lsurvivalF[i,j] <- beta1[i] + beta2[i] + 
      beta3[i] * my.constants$winglength[j]
  }
}
mean_lsurvivalM <- apply(predicted_lsurvivalM, 2, mean)
mean_lsurvivalF <- apply(predicted_lsurvivalF, 2, mean)
ord <- order(my.constants$winglength)
df <- data.frame(wing_length = c(my.constants$winglength[ord], 
                                 my.constants$winglength[ord]),
                 survival = c(mean_lsurvivalM[ord], 
                              mean_lsurvivalF[ord]),
                 sex = c(rep("male", length(mean_lsurvivalM)), 
                         rep("female", length(mean_lsurvivalF))))

if (params$bw) {
  df %>%
    ggplot(aes(x = wing_length, y = survival, color = sex, linetype = sex)) +
    geom_line(linewidth = 1) +
    ylim(-2, 2) +
    labs(x = "wing length",
         y = "estimated survival (on the logit scale)",
         color = "", linetype = "") +
    scale_color_manual(values = c("black", "grey70")) +
    scale_linetype_manual(values = c("solid", "solid"))
} else {
  df %>%
    ggplot() + 
    aes(x = wing_length, y = survival, color = sex) + 
    geom_line() + 
    ylim(-2,2) + 
    labs(x = "wing length", 
         y = "estimated survival (on the logit scale)", 
         color = "")
}
```

### Random effects {#randomeffects}

If individual variation in survival is not fully explained by our covariates, we may add random effects through $\text{logit}(\phi_i) = \beta_1 + \beta_2 x_i + \varepsilon_i$ where $\varepsilon_i \sim N(0,\sigma^2)$. We consider individual variation in this section, but the reasoning holds for temporal variation. In essence, we are treating the individual survival probabilities $\phi_i$ as a sample from a population of survival probabilities, and we assume a normal distribution with mean the linear component (with or without a covariate) and standard deviation $\sigma$. The variation that is unexplained by the covariate $x_i$ is measured by the variation $\sigma$ in the residuals $\varepsilon_i$. 

Why is it important? Ignoring individual heterogeneity generated by individuals having contrasted performances over life may mask senescence or hamper the understanding of life history trade-offs. Overall, failing to incorporate unexplained residual variance may induce bias in parameter estimates and lead to detecting an effect of the covariate more often than it should be.

Let's go back to our dipper example with wing length as a covariate, and write the NIMBLE code: 
```{r eval = FALSE}
hmm.phiwlrep <- nimbleCode({
    p ~ dunif(0, 1)             # prior detection
    omega[1,1] <- 1 - p         # Pr(alive t -> non-detected t)
    omega[1,2] <- p             # Pr(alive t -> detected t)
    omega[2,1] <- 1             # Pr(dead t -> non-detected t)
    omega[2,2] <- 0             # Pr(dead t -> detected t)
  for (i in 1:N){
    logit(phi[i]) <- beta[1] + beta[2] * winglength[i] + eps[i]
    eps[i] ~ dnorm(mean = 0, sd = sdeps)
    gamma[1,1,i] <- phi[i]      # Pr(alive t -> alive t+1)
    gamma[1,2,i] <- 1 - phi[i]  # Pr(alive t -> dead t+1)
    gamma[2,1,i] <- 0           # Pr(dead t -> alive t+1)
    gamma[2,2,i] <- 1           # Pr(dead t -> dead t+1)
  }
  beta[1] ~ dnorm(mean = 0, sd = 1.5)
  beta[2] ~ dnorm(mean = 0, sd = 1.5)
  sdeps ~ dunif(0, 10)
  delta[1] <- 1                 # Pr(alive t = 1) = 1
  delta[2] <- 0                 # Pr(dead t = 1) = 0
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, i])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
```

The prior on the standard deviation of the random effect is uniform between 0 and 10. 

We now write a function for generating initial values:
```{r eval = FALSE}
initial.values <- function() list(beta = rnorm(2,0,1.5),
                                  sdeps = runif(1,0,3),
                                  p = runif(1,0,1),
                                  z = zinits)
```

We specify the parameters to be monitored:
```{r eval = FALSE}
parameters.to.save <- c("beta", "sdeps", "p")
```

We increase the number of iterations and the length of the burn-in period to reach better convergence:
```{r eval = FALSE}
n.iter <- 10000
n.burnin <- 5000
n.chains <- 2
```

And finally, we run NIMBLE:
```{r eval = FALSE}
mcmc.phiwlrep <- nimbleMCMC(code = hmm.phiwlrep, 
                            constants = my.constants,
                            data = my.data,              
                            inits = initial.values,
                            monitors = parameters.to.save,
                            niter = n.iter,
                            nburnin = n.burnin, 
                            nchains = n.chains)
```

We inspect the numerical summaries: 
```{r eval = FALSE}
MCMCsummary(mcmc.phiwlrep, round = 2)
```
```{r echo = FALSE}
load(here::here("dat/phiwlrepbad.RData"))
MCMCsummary(mcmc.phiwlrep, round = 2)
```

The effective sample size for the standard deviation of the random effect is very low. Let's try something else, which means that the MCMC chains are exploring that parameter space inefficiently. A common strategy to address this problem is to reparameterize the model using a *non-centered* formulation. 

In the *centered parameterization* we've used so far, the random effect is expressed directly in terms of its variance (or standard deviation). This often creates strong correlations between the random effects and their variance parameter, which in turn can slow down mixing and reduce the effective sample size. In the *non-centered parameterization*, we instead separate the structure of the random effect from its scale. In practice, we introduce a standardized random effect $\varepsilon_i \sim N(0,1)$ and then multiply it by the standard deviation $\sigma$. This decouples the randomness from the scale parameter and usually improves sampling efficiency. In code, this looks like:
```{r eval = FALSE}
...
  for (i in 1:N){
    logit(phi[i])<-beta[1]+beta[2]*winglength[i] + sdeps * eps[i]
    eps[i] ~ dnorm(mean = 0, sd = 1)
...
```

After running NIMBLE, we inspect the numerical summaries, and see that effective sample sizes are much better:
```{r eval = FALSE}
MCMCsummary(mcmc.phiwlrep, round = 2)
```
```{r echo = FALSE}
load(here::here("dat/phiwlrep.RData"))
MCMCsummary(mcmc.phiwlrep, round = 2)
```

<!-- Let's plot the posterior distribution of the standard deviation of the random effect: -->
<!-- ```{r} -->
<!-- sdeps <- c(mcmc.phiwlrep$chain1[,"sdeps"], # chain 1 -->
<!--            mcmc.phiwlrep$chain2[,"sdeps"]) # chain 2 -->
<!-- sdeps %>% -->
<!--   as_tibble() %>% -->
<!--   ggplot() +  -->
<!--   aes(x = value) +  -->
<!--   geom_histogram(color = "white", binwidth = .03, fill = "gray70") -->
<!-- ``` -->

### Individual time-varying covariates {#agecov}

So far, we allowed covariates to vary along a single dimension, either time or individual. What if we need to consider a covariate that varies from one animal to the other, and over time. Think of age for example, its value is specific to each individual, and it (sadly) changes over time. 

Age has a particular meaning in the capture-recapture framework. It is the time elapsed since first encounter, which is a proxy of true age, but not true age. If age is known at first encounter, then it is true age. For example, if the dippers were marked as young, then we would have the true biological age of each bird.  

The convenient thing is that age has no missing value because age at $t+1$ is just age at $t$ to which we add 1. This suggests a way to code the age effect in NIMBLE as follows: 
```{r eval = FALSE}
hmm.phiage.in <- nimbleCode({
  p ~ dunif(0, 1)                     # prior detection
  omega[1,1] <- 1 - p                 # Pr(alive t -> non-detected t)
  omega[1,2] <- p                     # Pr(alive t -> detected t)
  omega[2,1] <- 1                     # Pr(dead t -> non-detected t)
  omega[2,2] <- 0                     # Pr(dead t -> detected t)
  for (i in 1:N){
    for (t in first[i]:(T-1)){
    # phi1 = beta1 + beta2; phi1+ = beta1
    logit(phi[i,t]) <- beta[1] + beta[2] * equals(t, first[i]) 
    gamma[1,1,i,t] <- phi[i,t]        # Pr(alive t -> alive t+1)
    gamma[1,2,i,t] <- 1 - phi[i,t]    # Pr(alive t -> dead t+1)
    gamma[2,1,i,t] <- 0               # Pr(dead t -> alive t+1)
    gamma[2,2,i,t] <- 1               # Pr(dead t -> dead t+1)
    }
  }
  beta[1] ~ dnorm(mean = 0, sd = 1.5) # phi1+
  beta[2] ~ dnorm(mean = 0, sd = 1.5) # phi1 - phi1+
  phi1plus <- plogis(beta[1])         # phi1+
  phi1 <- plogis(beta[1] + beta[2])   # phi1
  delta[1] <- 1                       # Pr(alive t = 1) = 1
  delta[2] <- 0                       # Pr(dead t = 1) = 0
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, i, j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
```

Here we used `equals(t, first[i])` which renders 1 when $t$ is the first encounter `first[i]` and 0 otherwise. Therefore we distinguish survival over the first interval after first encounter $\phi_1$ (`logit(phi[i,t]) <- beta[1] + beta[2]`) from survival afterwards $\phi_{1+}$ (`logit(phi[i,t]) <- beta[1]`).

We put all constants in a list:
```{r eval = FALSE}
first <- apply(y, 1, function(x) min(which(x !=0)))
my.constants <- list(N = nrow(y), 
                     T = ncol(y), 
                     first = first)
```

And the data in a list:
```{r eval = FALSE}
my.data <- list(y = y + 1)
```

We write a function to generate initial values:
```{r eval = FALSE}
zinits <- y
zinits[zinits == 0] <- 1
initial.values <- function() list(beta = rnorm(2,0,5),
                                  p = runif(1,0,1),
                                  z = zinits)
```

And specify the parameters to be monitored:
```{r eval = FALSE}
parameters.to.save <- c("phi1", "phi1plus", "p")
```

We now run NIMBLE:
```{r eval = FALSE}
mcmc.phi.age.in <- nimbleMCMC(code = hmm.phiage.in, 
                              constants = my.constants,
                              data = my.data,              
                              inits = initial.values,
                              monitors = parameters.to.save,
                              niter = n.iter,
                              nburnin = n.burnin, 
                              nchains = n.chains)
```

We display the results: 
```{r eval = FALSE}
MCMCsummary(mcmc.phi.age.in, round = 2)
```
```{r echo = FALSE}
load(here::here("dat/phiagein.RData"))
MCMCsummary(mcmc.phi.age.in, round = 2)
```

Age or time elapsed since first encounter does not seem to have an effect on survival here. 

Another method to include an age effect is to create an individual by time covariate and use nested indexing (as in the flood/nonflood example) to distinguish survival over the interval after first detection from survival afterwards: 
```{r eval = FALSE}
age <- matrix(NA, nrow = nrow(y), ncol = ncol(y) - 1)
for (i in 1:nrow(age)){
  for (j in 1:ncol(age)){
    if (j == first[i]) age[i,j] <- 1 # age = 1
    if (j > first[i]) age[i,j] <- 2  # age > 1
  }
}
```

Now we may write the NIMBLE code for this model. We just need to remember that survival is no longer defined on the logit scale as in the previous model, so we simply use uniform priors:  
```{r eval = FALSE}
hmm.phiage.out <- nimbleCode({
  p ~ dunif(0, 1)                   # prior detection
  omega[1,1] <- 1 - p               # Pr(alive t -> non-detected t)
  omega[1,2] <- p                   # Pr(alive t -> detected t)
  omega[2,1] <- 1                   # Pr(dead t -> non-detected t)
  omega[2,2] <- 0                   # Pr(dead t -> detected t)
  for (i in 1:N){
    for (t in first[i]:(T-1)){
    phi[i,t] <- beta[age[i,t]]      # beta1 = phi1, beta2 = phi1+
    gamma[1,1,i,t] <- phi[i,t]      # Pr(alive t -> alive t+1)
    gamma[1,2,i,t] <- 1 - phi[i,t]  # Pr(alive t -> dead t+1)
    gamma[2,1,i,t] <- 0             # Pr(dead t -> alive t+1)
    gamma[2,2,i,t] <- 1             # Pr(dead t -> dead t+1)
    }
  }
  beta[1] ~ dunif(0, 1) # phi1
  beta[2] ~ dunif(0, 1) # phi1+
  phi1 <- beta[1]
  phi1plus <- beta[2]
  delta[1] <- 1                     # Pr(alive t = 1) = 1
  delta[2] <- 0                     # Pr(dead t = 1) = 0
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, i, j-1])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
```

We put all constants in a list, including the age covariate:
```{r eval = FALSE}
first <- apply(y, 1, function(x) min(which(x !=0)))
my.constants <- list(N = nrow(y), 
                     T = ncol(y), 
                     first = first,
                     age = age)
```

We re-write a function to generate initial values: 
```{r eval = FALSE}
zinits <- y
zinits[zinits == 0] <- 1
initial.values <- function() list(beta = runif(2,0,1),
                                  p = runif(1,0,1),
                                  z = zinits)
```

And we run NIMBLE:
```{r eval = FALSE}
mcmc.phi.age.out <- nimbleMCMC(code = hmm.phiage.out, 
                               constants = my.constants,
                               data = my.data,              
                               inits = initial.values,
                               monitors = parameters.to.save,
                               niter = n.iter,
                               nburnin = n.burnin, 
                               nchains = n.chains)
```

We display numerical summaries for the model parameters, and acknowledge that we obtain similar results to the other parameterization:
```{r eval = FALSE}
MCMCsummary(mcmc.phi.age.out, round = 2)
```
```{r echo = FALSE}
load(here::here("dat/phiageout.RData"))
MCMCsummary(mcmc.phi.age.out, round = 2)
```

Like I mentioned earlier, age is easy to deal with as it does not contain missing values. Now think of size or body mass for a minute. The problem is that we cannot record size or body mass when an animal is non-detected. The easiest way to cope with individual time-varying covariates is to discretize e.g. in small, medium and large as in Chapter \@ref(dispersal). Another option is to come up with a model for the covariate and fill in missing values by simulating from this model. 

## Why Bayes? Incorporate prior information {#elicitprior}

### Prior elicitation

Before we close this section, I'd like to cover one last topic. Think again of the CJS model with constant parameters. So far, we have assumed a non-informative prior on survival $\text{Beta}(1,1) = \text{Uniform}(0,1)$. With this prior, we have seen in Section \@ref(cjsderivatives) that mean posterior survival is $\phi = 0.56$ with credible interval $[0.52,0.62]$. 

<!-- Graphically we may represent the posterior distribution of survival obtained with two chains with different colors, and our prior in gray dashed line: -->

<!-- ```{r, echo = FALSE} -->
<!-- load(here::here("dat","dipper.RData")) -->
<!-- PR <- runif(1500, 0, 1) -->
<!-- MCMCtrace(mcmc.phip, -->
<!--           params = c('phi'), -->
<!--           ISB = FALSE, -->
<!--           exact = TRUE, -->
<!--           priors = PR, -->
<!--           pdf = FALSE, -->
<!--           Rhat = FALSE, -->
<!--           n.eff = FALSE, -->
<!--           #          post_zm = TRUE, -->
<!--           sz_txt = NULL, -->
<!--           ind = TRUE, -->
<!--           type = "density", -->
<!--           lwd_den = 3, -->
<!--           lwd_pr = 3, -->
<!--           col_pr = "gray70", -->
<!--           lty_pr = 2, -->
<!--           main_den = "", -->
<!--           xlab_den = "survival") -->
<!-- ``` -->

The thing is that we know a lot about passerines and it is a shame not to be able to use this information and act as if we have to start from scratch and know nothing. 

We illustrate how to incorporate prior information by acknowledging that species with similar body masses have similar survival. By gathering information on several other European passerines than the dipper, let's assume we have built a regression of survival vs. body mass -- an allometric relationship. 

Now knowing dippers weigh on average 59.8g, we're in the position to build a prior for dipper survival probability by predicting its value using the regression. We obtain a predicted survival of 0.57 and a standard deviation of 0.075. Using an informative prior `phi ~ dnorm(0.57, sd = 0.073)` in NIMBLE instead of our `phi ~ dunif(0,1)`, we get a mean posterior of $0.56$ with credible interval $[0.52, 0.61]$. There's barely no difference with the non-informative prior, quite a disappointment. 

Now let's assume that we had only the three first years of data, what would have happened? We fit the model with constant parameters with both the non-informative and informative priors to the dataset from which we delete the final 4 years of data. Now the benefit of using the prior information becomes clear as the credible interval when prior information is ignored has a width of 0.53, which is more than twice as much as when prior information is used (0.24), illustrating the increased precision provided by the prior. We may assess visually this gain in precision by comparing the survival posterior distributions with and without informative prior:
  
```{r, echo = FALSE}
load(here::here("dat","phip3y.RData"))
phinoprior <- c(mcmc.phip$chain1[,"phi"], mcmc.phip$chain2[,"phi"])
load(here::here("dat","phipriorp3y.RData"))
phiprior <- c(mcmc.phip$chain1[,"phi"], mcmc.phip$chain2[,"phi"])
df <- data.frame(posterior = c(phinoprior, phiprior),
                 type = c(rep("w/ vague prior", length(phinoprior)),
                          rep("w/ informative prior", length(phiprior))))

if (params$bw) {
  df %>%
    ggplot(aes(x = posterior, fill = type, linetype = type)) +
    geom_density(aes(y = ..density..),
                 alpha = 0.4,
                 color = "black") +
    labs(x = "survival", fill = "", linetype = "") +
    scale_fill_manual(values = c("grey80", "grey40")) +
    scale_linetype_manual(values = c("solid", "solid"))
} else {
  df %>%
    ggplot() +
    aes(x = posterior, fill = type) +
    geom_density(aes(y = ..density..),
                 bins = 40,
                 color = "white",
                 alpha = 0.6) +
    labs(x = "survival", fill = "") +
    scale_fill_manual(values = wesanderson::wes_palette("Royal1")[2:1])
}


```

If the aim is to get an estimate of survival, Gilbert did not have to conduct further data collection after 3 years, and he could have reached the same precision as with 7 years of data by using prior information derived from body mass. In brief, the prior information was worth 4 years of field data. Of course, this is assuming that the ecological question remains the same whether you have 3 or 7 years of data, which is unlikely to be the case, as with long-term data, there is so much we can ask, more than "just" what annual survival probability is. 

### Moment matching

The prior `phi ~ dnorm(0.57, sd = 0.073)` is not entirely satisfying because it is not constrained to be positive or less than one, which is the minimum for a probability (of survival) to be well defined. In our specific example, the prior distribution is centered on positive values far from 0, and the standard deviation is small enough so that the chances to get values smaller than 0 or higher than 1 are null (to convince yourself, just type in `hist(rnorm(1000, mean = 0.57, sd = 0.073))` in R). Can we do better? The answer is yes. 

Remember the Beta distribution? Recall that the Beta distribution is a continuous distribution with values between 0 and 1, which is very convenient to specify priors for survival and detection probabilities. Besides we know everything about the Beta distribution, in particular its mean and variance. If $X \sim Beta(\alpha,\beta)$, then the mean and (variance) of $X$ are $\mu = \text{E}(X) = \frac{\alpha}{\alpha + \beta}$ and $\sigma^2 = \text{Var}(X) = \frac{\alpha\beta}{(\alpha + \beta)^2 (\alpha + \beta + 1)}$. 

In the capture-recapture example, we know a priori that the mean of the probability we're interested in is $\mu = 0.57$ and its variance is $\sigma^2 = 0.073^2$. Parameters $\mu$ and $\sigma^2$ are seen as the moments of a $Beta(\alpha,\beta)$ distribution. Now we look for values of $\alpha$ and $\beta$ that match the observed moments of the Beta distribution $\mu$ and $\sigma^2$. We need another set of equations:

$$\alpha = \bigg(\frac{1-\mu}{\sigma^2}- \frac{1}{\mu} \bigg)\mu^2$$
$$\beta = \alpha \bigg(\frac{1}{\mu}-1\bigg)$$
For our model, that means:

```{r echo = TRUE}
(alpha <- ( (1 - 0.57)/(0.073*0.073) - (1/0.57) )*0.57^2)
(beta <- alpha * ( (1/0.57) - 1))
```

Now we simply have to use `phi ~ dbeta(25.6,19.3)` as a prior instead of our `phi ~ dnorm(0.57, sd = 0.073)`.

## Summary

+ The CJS model is a HMM with time-varying parameters to account for variation due to environmental conditions in survival or to sampling effort in detection. 

+ Covariates can be considered to try and explain temporal and/or individual variation in survival and detection probabilities. If needed, random effects can be added to cope with unexplained variation. 

+ For model comparison, the WAIC can be used to evaluate the relative predictive performance of capture-recapture models. 

+ Statistical models rely on assumptions, and the CJS model makes no exception. There are procedures to assess the goodness of fit of the CJS model to capture-recapture data. 

## Suggested reading

+ @buckland2016 provides a historical perspective on the CJS model and anecdotes. The monography by @LebretonEtAl1992 is a must-read to better understand the CJS model and its applications. The HMM formulation of the CJS model was proposed by @gimenez2007 and @royle2008.

+ @gimenez2009 deals with parameter redundancy in capture-recapture models in a Bayesian framework. For an exhaustive treatment, see @cole2020 excellent book.

+ Relative to model comparison, I warmly recommend @mcelreathbook to better understand WAIC, with the accompanying video, see <https://www.youtube.com/watch?v=vSjL2Zc-gEQ>. The paper by @gelman2004 is also much helpful. 

+ On posterior predictive checks, you may check out @conn2018. The `R2ucare` package is introduced by @gimenez2018r2ucare.

+ Temporal heterogeneity is addressed in papers by @grosbois_assessing_2008 and @frederiksen2014, while individual heterogeneity is reviewed by @gimenez2018ih.

+ Regarding covariates, I did not use the formalization of linear models and sticked to an intuitive (hopefully) illustration of the use of covariates. More details can be found in Chapter 6 of @cooch2017intromark. 

+ The example on how to incorporate prior information is from @mccarthy2005.

<!--chapter:end:4-survive.Rmd-->

```{r include=FALSE, cache=FALSE}
# packages
library(tidyverse)
theme_set(theme_light(base_size = 14))
library(nimble)
library(MCMCvis)
library(magick)
library(pdftools)
library(wesanderson)
library(RColorBrewer)
library(patchwork)
library(emo)
#library(nimbleEcology)
#library(basicMCMCplots)

# R options
options(width = 60)

# chunk options
knitr::opts_chunk$set(
  comment = "##",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE
  )
```
# Sites and states {#dispersal}

## Introduction

In this fifth chapter, you will learn about the Arnason-Schwarz model that allows estimating transitions between sites and states based on capture-recapture data. You will also see how to deal with uncertainty in the assignment of states to individuals.  

## The Arnason-Schwarz (AS) model {#ASmodel}

In Chapter \@ref(survival), we got acquainted with the Cormack-Jolly-Seber (CJS) model which accommodates transitions between the states alive and dead while accounting for imperfect detection. It is often the case that besides being alive, more detailed information is collected on the state of animals when they are detected. For example, if the study area is split into several discrete sites, you may record where an animal is detected, the state being now alive in this particular site. The Arnason-Schwarz (AS) model can be viewed as an extension to the CJS model in which we estimate movements between sites on top of survival. The AS model is named after the two statisticians -- Neil Arnason and Carl Schwarz -- who came up with the idea. 

### Theory

Let's assume for now that we have two sites, say 1 and 2. The way we usually think of analyzing the data is to start from the detections and non-detections and infer the transitions between sites and movements. Schematically, when a animal is detected in site 1 or site 2, it obviously means that it is alive in that site, whereas when it is not detected, it may be dead or alive in either site. Schematically, we have:

```{r, echo = FALSE}
ggplot() +
  geom_point(aes(1, 1), size = 2.5, alpha = .7) +
  geom_point(aes(1, 1.5), size = 2.5, alpha = .7) +
  geom_point(aes(1, 2), size = 2.5, alpha = .7) +
  geom_text(aes(1, 2, label = 'non-detection'), nudge_x = -0.6, size = 7) +
  geom_text(aes(1, 1.5, label = 'detection in site 1'), nudge_x = -0.6, size = 7) +
  geom_text(aes(1, 1, label = 'detection in site 2'), nudge_x = -0.6, size = 7) +
  geom_point(aes(2, 1), size = 2.5, alpha = .7) +
  geom_point(aes(2, 1.5), size = 2.5, alpha = .7) +
  geom_point(aes(2, 2), size = 2.5, alpha = .7) +
  geom_text(aes(2, 2, label = 'alive in site 1'), nudge_x = 0.5, size = 7) +
  geom_text(aes(2, 1.5, label = 'alive in site 2'), nudge_x = 0.5, size = 7) +
  geom_text(aes(2, 1, label = 'dead'), nudge_x = 0.5, size = 7) +
  xlim(0, 3) +
  ylim(0.5, 3) +
  annotate('text', x = 1, y = 2.6, label = 'Observations', size = 10) +
  annotate('text', x = 2, y = 2.6, label = 'States', size = 10) +
  geom_segment(aes(x = 1, y = 2, xend = 2, yend = 2), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 2, xend = 2, yend = 1.5), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 2, xend = 2, yend = 1), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 1.5, xend = 2, yend = 2), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 1, xend = 2, yend = 1.5), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  theme_void()
```

Observations and states are indeed closely related, but we do not have a perfect states to observations correspondence, and the HMM framework will help you make the distinction clear, which in turn will make the modelling easier. Usually, we focus our energy on the observations but what we'd really like is to spend time thinking of the ecological processes that we observed imperfectly. In the HMM framework, when we are to build a model, we think of the states and their dynamic over time, and these states emit the observations we're given to make. Going back to the our example, when an animal is alive in either site, it may get detected in that site or go undetected. When an animal is dead, then it goes undetected for sure. Schematically, we obtain:

```{r, echo = FALSE}
ggplot() +
  geom_point(aes(1, 1), size = 2.5, alpha = .7) +
  geom_point(aes(1, 1.5), size = 2.5, alpha = .7) +
  geom_point(aes(1, 2), size = 2.5, alpha = .7) +
  geom_text(aes(2, 2, label = 'non-detection'), nudge_x = 0.5, size = 7) +
  geom_text(aes(2, 1.5, label = 'detection in site 1'), nudge_x = 0.6, size = 7) +
  geom_text(aes(2, 1, label = 'detection in site 2'), nudge_x = 0.6, size = 7) +
  geom_point(aes(2, 1), size = 2.5, alpha = .7) +
  geom_point(aes(2, 1.5), size = 2.5, alpha = .7) +
  geom_point(aes(2, 2), size = 2.5, alpha = .7) +
  geom_text(aes(1, 2, label = 'alive in site 1'), nudge_x = -0.6, size = 7) +
  geom_text(aes(1, 1.5, label = 'alive in site 2'), nudge_x = -0.6, size = 7) +
  geom_text(aes(1, 1, label = 'dead'), nudge_x = -0.6, size = 7) +
  xlim(0, 3) +
  ylim(0.5, 3) +
  annotate('text', x = 1, y = 2.6, label = 'States', size = 10) +
  annotate('text', x = 2, y = 2.6, label = 'Observations', size = 10) +
    geom_segment(aes(x = 1, y = 2, xend = 2, yend = 2), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 2, xend = 2, yend = 1.5), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 1.5, xend = 2, yend = 2), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 1.5, xend = 2, yend = 1), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 1, xend = 2, yend = 2), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  theme_void()
```

We have $z = 1$ for alive in site 1, $z = 2$ for alive in site 2 and $z = 3$ for dead. We will code $y = 1$ for non-detected, $y = 2$ for detected in site 1 and $y = 3$ for detected in site 2. The parameters are:   
- $\pi^r$ is the probability the a newly encountered individual is in state $r$;   
- $p_t^r$ is the probability of detection at $t$ for a bird in site $r$ at $t$;  
- $\phi_t^r$ is the survival probability for birds in site $r$ at between $t$ and $t+1$;  
- $\psi_t^{rs}$ is the probability of being in site $s$ at time $t+1$ for animals that were in site $r$ at $t$ and have survived to $t+1$, in short movement conditional on survival.

These parameters can be modelled as functions of covariates as in Section \@ref(covariates). But for now we will drop the time index for simplicity.

We follow the presentation of HMM as in Chapter \@ref(hmmcapturerecapture). Let's start with the vector of initial states. At first encounter, an animal may be alive in site 1 with probability $\pi^1$ or in site 2 with the complementary probability $1 - \pi^{1}$, but it cannot be dead. Therefore, we have: 

$$\begin{matrix}
& \\
\delta =
    \left ( \vphantom{ \begin{matrix} 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    z_t=1 & z_t=2 & z_t=3 \\[0.3em] \hdashline
\pi^1 & 1 - \pi^{1} & 0\\
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \end{matrix} } \right )
    \begin{matrix}
    \end{matrix}
\end{matrix}$$

We move on to the transition matrix which connects the states at $t-1$ in rows to the states at $t$ in columns. For example, the probability of moving from site 1 at $t-1$ to site $2$ at $t$ is the product of the survival probability in site 1 over that time interval, times the probability of moving from site 1 to 2 for those animals who survived. We have:

$$\begin{matrix}
& \\
\Gamma =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    z_{t}=1 & z_{t}=2 & z_{t}=3 \\[0.3em] \hdashline
\phi^1 (1-\psi^{12}) & \phi^1 \psi^{12} & 1 - \phi^1\\
\phi^2 \psi^{21} & \phi^2 (1-\psi^{21}) & 1 - \phi^2\\
0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
    \begin{matrix}
    z_{t-1}=1 \\ z_{t-1}=2 \\ z_{t-1}=3
    \end{matrix}
\end{matrix}$$

Finally, the observation matrix relates the states an animal is in at $t$ in rows to the observations at $t$ in columns. If an animal is dead ($z_t=3$), it cannot be detected ($\Pr(y_t=1|z_t=3)=\Pr(y_t=2|z_t=3)=0$ and $\Pr(y_t=3|z_t=3)=1$), whereas when it is alive in either site, it can be detected or not. We have: 

$$\begin{matrix}
& \\
\Omega =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    y_t=1 & y_t=2 & y_t=3 \\[0.3em] \hdashline
1 - p^1 & p^1 & 0\\
1 - p^2 & 0 & p^2\\
1 & 0 & 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
    \begin{matrix}
    z_{t}=1 \\ z_{t}=2 \\ z_{t}=3
    \end{matrix}
\end{matrix}$$

The vector of initial state probabilities sums up to one, as well as the rows of the transition and observation matrices. 

## Fitting the AS model {#ASmodelfitting}

### Geese data

To introduce this chapter, we will use data on the Canada goose (*Branta canadensis*; geese hereafter) kindly provided by Jay Hestbeck (Figure \@ref(fig:pixdipper)). 

```{r pixgeese, echo=FALSE, out.width="100%", fig.cap="Canada goose (Branta canadensis). Credit: Max McCarthy.", fig.align='center'}
knitr::include_graphics("images/goose.jpg")
```

In total, 21277 geese were captured, marked with coded neck bands and recaptured between 1984 and 1989 in their wintering locations. Specifically, geese were monitored in the Atlantic flyway, in large areas along the East coast of the USA, namely 3 sites in the mid--Atlantic (New York, Pennsylvania, New Jersey), Chesapeake (Delaware, Maryland, Virginia), and Carolinas (North and South Carolina). Birds were adults and sub-adults when banded. 

You may see the data below: 

```{r echo = TRUE, eval = FALSE}
y <- read_csv("geese.csv") %>% as.matrix()
head(y)
```

```{r echo = FALSE}
y <- read_csv("dat/geese.csv") %>% as.matrix()
head(y)
```


The six columns are years in which the geese were captured, banded and recapture. A 0 stands for a non-detection, and detections were coded in the 3 wintering sites 1, 2 and 3 for mid--Atlantic, Chesapeake and Carolinas respectively. This is only a subsample of 500 individuals of the whole dataset that I will use for illustration here. 

### NIMBLE implementation

To write the NIMBLE code corresponding to the AS model, we will make our life easier and start with 2 sites only -- we drop the Carolinas wintering site for now. We replace all 3's by 0's in the dataset:

```{r}
y[y==3] <- 0
# remove rows with 0's
mask <- apply(y, 1, sum)
y <- y[mask!=0,]
```

Also we consider parameters constant over time.

<!-- Note: You may code non-detections as $y_t = 2$, and the first column in the observation matrix should go last. -->

<!-- Quick answer about the -1 and the important issue of coding states and obs. I did this on purpose, to have folks think about the difference between observations and states (non-detection obs should not be confused with state for dead). This becomes even more crucial when we get to multievent models where several observations may be generated by a single state. I get the intuition argument perfectly, but I’d like them to fight against it at first, then once they’re comfortable with the difference, they may code obs/states as they see fit. Let’s see how it goes. I agree that we should mention that during the multistate lecture, in the spirit of « you’re free to code states and jobs the way you like ». I’ll add something. -->

We start with comments to define the quantities -- parameters, states and observations -- we will use in the NIMBLE code:
```{r eval = FALSE}
multisite <- nimbleCode({
  # -------------------------------------------------
  # Parameters:
  # phi1: survival probability site 1
  # phi2: survival probability site 2
  # psi12: movement probability from site 1 to site 2
  # psi21: movement probability from site 2 to site 1
  # p1: detection probability site 1
  # p2: detection probability site 2
  # -------------------------------------------------
  # States (z):
  # 1 alive at site 1
  # 2 alive at site 2
  # 3 dead
  # Observations (y):
  # 1 not seen
  # 2 seen at site 1
  # 3 seen at site 2
  # -------------------------------------------------
...
```

The we specify priors for the survival, transition and detection probabilities:
```{r eval = FALSE}
multisite <- nimbleCode({
...
  # Priors
  phi1 ~ dunif(0, 1)
  phi2 ~ dunif(0, 1)
  psi12 ~ dunif(0, 1)
  psi21 ~ dunif(0, 1)
  p1 ~ dunif(0, 1)
  p2 ~ dunif(0, 1)
...
```

We now write the vector of initial state probabilities:
```{r eval = FALSE}
multisite <- nimbleCode({
...
  # initial state probabilities
  delta[1] <- pi1          # Pr(alive in 1 at t = first)
  delta[2] <- 1 - pi1      # Pr(alive in 2 at t = first)
  delta[3] <- 0            # Pr(dead at t = first) = 0
...
```

Actually, the initial state is known exactly: It is alive at site of initial capture, and $\pi^1$ is the proportion of individuals first captured in site 1, there is no need to make it explicit in the model and estimate it. Therefore, in the likelihood, instead of `z[i,first[i]] ~ dcat(delta[1:3])`, you can use `z[i,first[i]] <- y[i,first[i]] - 1` and just forget about $\pi^1$, for now. Note that the same trick applies to the CJS model. 

We write the transition matrix:
```{r eval = FALSE}
multisite <- nimbleCode({
...
  # probabilities of state z(t+1) given z(t)
  # (read as gamma[z(t),z(t+1)] = gamma[fromState,toState])

  gamma[1,1] <- phi1 * (1 - psi12)
  gamma[1,2] <- phi1 * psi12
  gamma[1,3] <- 1 - phi1
  gamma[2,1] <- phi2 * psi21
  gamma[2,2] <- phi2 * (1 - psi21)
  gamma[2,3] <- 1 - phi2
  gamma[3,1] <- 0
  gamma[3,2] <- 0
  gamma[3,3] <- 1
...
```

In the same way, the observation matrix is:
```{r eval = FALSE}
multisite <- nimbleCode({
...
  # probabilities of y(t) given z(t)
  # (read as omega[y(t),z(t)] = omega[Observation,State])

  omega[1,1] <- 1 - p1     # Pr(alive 1 t -> non-detected t)
  omega[1,2] <- p1         # Pr(alive 1 t -> detected site 1 t)
  omega[1,3] <- 0          # Pr(alive 1 t -> detected site 2 t)
  omega[2,1] <- 1 - p2     # Pr(alive 2 t -> non-detected t)
  omega[2,2] <- 0          # Pr(alive 2 t -> detected site 1 t)
  omega[2,3] <- p2         # Pr(alive 2 t -> detected site 2 t)
  omega[3,1] <- 1          # Pr(dead t -> non-detected t)
  omega[3,2] <- 0          # Pr(dead t -> detected site 1 t)
  omega[3,3] <- 0          # Pr(dead t -> detected site 2 t)
...
```

At last, we are ready to specify the likelihood which, and this this the magic of HMM, is the same as the likelihood of the CJS model, only the vector of initial states, the transition and observation matrices were changed:
```{r eval = FALSE}
multisite <- nimbleCode({
...
  # likelihood
  for (i in 1:N){
    # latent state at first capture
    z[i,first[i]] <- y[i,first[i]] - 1
    for (t in (first[i]+1):K){
      # z(t) given z(t-1)
      z[i,t] ~ dcat(gamma[z[i,t-1],1:3])
      # y(t) given z(t)
      y[i,t] ~ dcat(omega[z[i,t],1:3])
    }
  }
})
```

We need to provide NIMBLE with constants, data, initial values, some parameters to monitor and MCMC details:

```{r eval = FALSE}
# occasions of first capture
first <- apply(y, 1, function(x) min(which(x !=0)))
# constants
my.constants <- list(first = first, 
                     K = ncol(y), 
                     N = nrow(y))
# data
my.data <- list(y = y + 1)
# initial values 
zinits <- y # say states are observations, detections in A or B   
            # are taken as alive in same sites 
# non-detections become alive in site A or B
zinits[zinits==0] <- sample(c(1,2), sum(zinits==0), replace = TRUE) 
initial.values <- function(){list(phi1 = runif(1, 0, 1), 
                                  phi2 = runif(1, 0, 1), 
                                  psi12 = runif(1, 0, 1), 
                                  psi21 = runif(1, 0, 1), 
                                  p1 = runif(1, 0, 1), 
                                  p2 = runif(1, 0, 1), 
                                  pi1 = runif(1, 0, 1),
                                  z = zinits)}
# parameters to monitor
parameters.to.save <- c("phi1", "phi2","psi12", "psi21", 
                        "p1", "p2", "pi1")
# MCMC details
n.iter <- 20000
n.burnin <- 1000
n.chains <- 2
```

Now we may run NIMBLE:
```{r eval = FALSE}
mcmc.multisite <- nimbleMCMC(code = multisite, 
                             constants = my.constants,
                             data = my.data,              
                             inits = initial.values,
                             monitors = parameters.to.save,
                             niter = n.iter,
                             nburnin = n.burnin, 
                             nchains = n.chains)
```

We may have a look to the results via a caterpillar plot: 
```{r, echo = FALSE}
load(here::here("dat","geese_2sites.RData"))
```
```{r}
MCMCplot(mcmc.multisite)
```

Remember mid--Atlantic is site 1, and Chesapeake site 2. Detection in mid--Atlantic (around 0.5) is higher than in Cheasapeake (around 0.4) although it comes with more uncertainty (wider credible interval). Survival in both sites are estimated at around 0.6--0.7. Note that by going multisite, we could make these parameters site-specific and differences might reflect habitat quality for example. Now the novelty lies in our capability to estimate movements from site 1 to site 2 and from site 2 to site 1 from a winter to the next. The annual probability of remaining in the same site for two successive winters, used as a measure of site fidelity, was lower in the mid--Atlantic ($1-\psi_{12}$ around 0.8) than in the Chesapeake ($1-\psi_{21}$ around 0.9). The estimated probability of moving to the Chesapeake from the mid--Atlantic was four times as high as the probability of moving in the opposite direction.

We may also have a look to numerical summaries, which confirm our ecological interpretation of the model parameter estimates:
```{r echo = FALSE}
load(here::here("dat","geese_2sites.RData"))
```
```{r}
MCMCsummary(mcmc.multisite, round = 2)
```

You could add time-dependence to the demographic parameters, e.g. survival and movements, and assess the effect of winter harshness with some temporal covariates; Individual covariates could also be considered. See Section \@ref(covariates). 

Before we move to the next section, I will illustrate the use of `nimbleEcology` to fit the AS to the geese data with 2 sites (see Section \@ref(nimblemarginalization)). Using the function `dHMM()` which implements HMM with time-independent observation and transition matrices, we have:

```{r eval = FALSE}
# read in data
geese <- read_csv("geese.csv", col_names = TRUE)
y <- as.matrix(geese)
# drop Carolinas
y[y==3] <- 0 # act as if there was no detection in site 3 Carolinas
mask <- apply(y, 1, sum)
y <- y[mask!=0,] # remove rows w/ 0s only
# get occasions of first encounter
get.first <- function(x) min(which(x != 0))
first <- apply(y, 1, get.first)
# filter out individuals that are first captured at last occasion. 
# These individuals do not contribute to parameter estimation, 
# and also they cause problems with nimbleEcology
mask <- which(first!=ncol(y)) 
y <- y[mask, ]                # keep only these
first <- first[mask]

# NIMBLE code 
multisite.marginalized <- nimbleCode({
  
  # -------------------------------------------------
  # Parameters:
  # phi1: survival probability site 1
  # phi2: survival probability site 2
  # psi12: movement probability from site 1 to site 2
  # psi21: movement probability from site 2 to site 1
  # p1: recapture probability site 1
  # p2: recapture probability site 2
  # pi1: prop of being in site 1 at initial capture
  # -------------------------------------------------
  # States (z):
  # 1 alive at 1
  # 2 alive at 2
  # 3 dead
  # Observations (y):  
  # 1 not seen
  # 2 seen at site 1 
  # 3 seen at site 2
  # -------------------------------------------------
  
  # priors
  phi1 ~ dunif(0, 1)
  phi2 ~ dunif(0, 1)
  psi12 ~ dunif(0, 1)
  psi21 ~ dunif(0, 1)
  p1 ~ dunif(0, 1)
  p2 ~ dunif(0, 1)
  pi1 ~ dunif(0, 1)
  
  # probabilities of state z(t+1) given z(t)
  gamma[1,1] <- phi1 * (1 - psi12)
  gamma[1,2] <- phi1 * psi12
  gamma[1,3] <- 1 - phi1
  gamma[2,1] <- phi2 * psi21
  gamma[2,2] <- phi2 * (1 - psi21)
  gamma[2,3] <- 1 - phi2
  gamma[3,1] <- 0
  gamma[3,2] <- 0
  gamma[3,3] <- 1
  
  # probabilities of y(t) given z(t)
  omega[1,1] <- 1 - p1     # Pr(alive 1 t -> non-detected t)
  omega[1,2] <- p1         # Pr(alive 1 t -> detected 1 t)
  omega[1,3] <- 0          # Pr(alive 1 t -> detected 2 t)
  omega[2,1] <- 1 - p2     # Pr(alive 2 t -> non-detected t)
  omega[2,2] <- 0          # Pr(alive 2 t -> detected 1 t)
  omega[2,3] <- p2         # Pr(alive 2 t -> detected 2 t)
  omega[3,1] <- 1          # Pr(dead t -> non-detected t)
  omega[3,2] <- 0          # Pr(dead t -> detected 1 t)
  omega[3,3] <- 0          # Pr(dead t -> detected 2 t)
  
  # likelihood 
  # initial state probs
  for(i in 1:N) {
    # first state propagation
    init[i, 1:3] <- gamma[ y[i, first[i] ] - 1, 1:3 ]        
  }
  for (i in 1:N){
    y[i,(first[i]+1):K] ~ dHMM(init = init[i,1:3],# data first[i]+1
                               probObs = omega[1:3,1:3], # obs
                               probTrans = gamma[1:3,1:3], # trans
                               len = K - first[i], # nb of occasions
                               checkRowSums = 0) # do not check 
                                                 # whether elements 
                                                 # in a row sum up 
                                                 # to 1
  }
})
# constants
my.constants <- list(first = first, 
                     K = ncol(y), 
                     N = nrow(y))
# data
my.data <- list(y = y + 1)
# initial values 
initial.values <- function(){list(phi1 = runif(1, 0, 1), 
                                  phi2 = runif(1, 0, 1), 
                                  psi12 = runif(1, 0, 1), 
                                  psi21 = runif(1, 0, 1), 
                                  p1 = runif(1, 0, 1), 
                                  p2 = runif(1, 0, 1))}
# parameters to monitor
parameters.to.save <- c("phi1", "phi2","psi12", "psi21", "p1", "p2")
# MCMC details
n.iter <- 5000
n.burnin <- 1000
n.chains <- 2
# run NIMBLE
mcmc.multisite.marginalized <- nimbleMCMC(
  code = multisite.marginalized, 
  constants = my.constants,
  data = my.data,              
  inits = initial.values,
  monitors = parameters.to.save,
  niter = n.iter,
  nburnin = n.burnin, 
  nchains = n.chains)
```

We obtain:
```{r echo = FALSE}
load(here::here("dat","twositemarginalized.Rdata"))
```
```{r}
MCMCsummary(mcmc.multisite.marginalized, round = 2)
```

There are no differences whatsoever in these parameters estimates compared to those we obtained earlier. 

### Goodness of fit {#gofas}

Like for the CJS model, we need to ensure that the AS model provides a good fit to the data. With regard to classical tests, the goodness-of-fit testing procedures we covered in Section \@ref(gof) for the CJS model have been extended to the AS model. These procedure are also available in the package `R2ucare`. While the transience and trap-dependence tests can be used on each site, it is worth mentionning a test that is specific to the AS model with several sites. The "where before where after" (WBWA) tests for memory, in other words it's a test for the Markovian property of the HMM in the particular context of capture-recapture. WBWA quantifies whether there is a relationship between where an animal has last been seen and where it will next be seen again. If a relationship exists, positive or negative, this suggests memory in the movements, and the probability for an animal of moving to a site at $t$, given it is present in a site at $t-1$ should be made dependent of where it was at $t-2$. This is called a second-order Markov process. 

Going back to the geese data, the WBWA test is implemented as follows on the whole dataset:
```{r echo = TRUE, eval = FALSE}
# To install the R2ucare package:
# if(!require(devtools)) install.packages("devtools")
# devtools::install_github("oliviergimenez/R2ucare")
library(R2ucare)
geese <- read_csv2("allgeese.csv") %>% as.matrix()
y <- geese[,1:6]
size <- geese[,7]
wbwa <- test3Gwbwa(y, size)
wbwa$test3Gwbwa
```

```{r echo = FALSE}
# To install the R2ucare package:
# if(!require(devtools)) install.packages("devtools")
# devtools::install_github("oliviergimenez/R2ucare")
library(R2ucare)
geese <- read_csv2("dat/allgeese.csv") %>% as.matrix()
y <- geese[,1:6]
size <- geese[,7]
wbwa <- test3Gwbwa(y, size)
wbwa$test3Gwbwa
```

There is clearly a strong (not to say significant) positive relationship judging by the value of the statistic. I will demonstrate how to account for this memory issue in an extension of the AS model in a case study in Section \@ref(memorymodel).

## What if more than 2 sites?

So far we have considered two sites only, for the sake of simplicity. Indeed when going for three sites (or more), a difficulty arises. While the movement probabilities still need to be between 0 and 1, the sum of all probabilities of moving from a site should also sum to one. This is because an individual alive in site 1 for example, has to stay in 1, move to 2 or move to 3, it has no other choice. This is no problem when you have only two sites because the probability of moving from 1 to 2 is always estimated between 0 and 1, and its complementary, the probability of moving from 2 to 1 will be too. When you have three sites, it might happen that the sum of the estimates for $\psi^{12}$ and $\psi^{13}$ is larger than one, even though they're both between 0 and 1, which would make $\psi^{11} = 1 - \psi^{12} - \psi^{13}$ negative. 

There are basically two methods to fulfill both constraints, either to assign a Dirichlet (which is pronounced deer-eesh-lay) prior to the movement probabilities, or to use a multinomial logit link function. 

### Dirichlet prior {#dirichletprior}

The Dirichlet distribution extends the Beta distribution multivariate we have seen previously (Figure \@ref(fig:betadistribution)) for values between 0 and 1 that add up to 1. Going back to our example with 3 sites, we would like to come up with a prior for parameters of moving from 1, which are $\psi^{11}$, $\psi^{12}$ and $\psi^{13}$. The Dirichlet distribution of dimension 3 has a vector of parameters $(\alpha_1, \alpha_2, \alpha_3)$ that controls its shape. The sum of all $\alpha$'s can be interpreted as a measure of precision: The higher the sum, the more peaked is the distribution on the mean value, the mean value along each dimension being the ratio of the corresponding over the sum of all $\alpha$'s. When all $\alpha$'s are equal, the distribution is symmetric (Figure \@ref(fig:dirichletdistribution)). Its mean is $(1/3, 1/3, 1/3)$ in our example with 3 parameters, whatever the value of $\alpha$. When $\alpha_1 = \alpha_2 = \alpha_3 = 1$, we obtain a uniform marginal distribution for the $\psi$'s, while values below 1 ($\alpha_1 = \alpha_2 = \alpha_3 = 0.1$) result in the distribution concentrating in the corners (skewed U-shaped forms) and values above 1 ($\alpha_1 = \alpha_2 = \alpha_3 = 10$) result in unimodal marginal distributions.

<!-- The probability density function for dirichlet is $f(x) = \displaystyle{\frac{1}{\text{B}({\mathbf \alpha})} \prod_{i=1}^K{x_i^{\alpha_i-1}}}$ where $\text{B}({\mathbf \alpha}) = \displaystyle{\frac{\prod_{i=1}^K{\Gamma({\alpha_i})}}{\Gamma(\sum_{i=1}^K{\alpha_i})}}$ and ${\mathbf \alpha} = (\alpha_1, \ldots, \alpha_K)$ the concentration parameters and $K$ the dimension of the space where $x$ takes values (Figure \@ref(fig:dirichlet)). -->
<!-- <https://en.wikipedia.org/wiki/Dirichlet_distribution#Occurrence_and_applications> -->
<!-- <https://stats.stackexchange.com/questions/130248/what-is-a-dirichlet-prior> <https://mc-stan.org/docs/functions-reference/dirichlet-distribution.html> <https://www.cs.helsinki.fi/u/ahonkela/dippa/node95.html> <https://rpubs.com/JanpuHou/295096> <https://www.biorxiv.org/content/10.1101/711317v2.full.pdf> <https://www.statisticshowto.com/dirichlet-distribution/> <https://research.wu.ac.at/ws/portalfiles/portal/17761231/Report125.pdf> -->

(ref:captiondirichlet) The Dirichlet distribution as a prior for $(\psi^{11}, \psi^{12}, \psi^{13})$ with vector of parameters $\alpha$. Here all components of $\alpha$ are equal which makes the distribution symmetric, and its mean is $(1/3, 1/3, 1/3)$. When $\alpha = 1$, the prior for the $\psi$'s is uniform (middle panel), unimodal when $\alpha = 10$ (right panel) and concentrated in the corners (0 and 1) when $\alpha = 0.1$ (left panel).


```{r dirichletdistribution, echo = FALSE, message=FALSE, warning=FALSE, fig.cap='(ref:captiondirichlet)'}
# --- packages
library(gtools)   # rdirichlet
library(dplyr)
library(tibble)
library(ggplot2)

# --- data (unchanged)
set.seed(123)
n <- 1000
alpha1 <- c(.1, .1, .1)
alpha2 <- c(1, 1, 1)
alpha3 <- c(10, 10, 10)

p1 <- rdirichlet(n, alpha1)
p2 <- rdirichlet(n, alpha2)
p3 <- rdirichlet(n, alpha3)

df <- cbind(rbind(p1, p2, p3),
            c(rep("alpha = c(0.1, 0.1, 0.1)", n),
              rep("alpha = c(1, 1, 1)", n),
              rep("alpha = c(10, 10, 10)", n))) |>
  as_tibble() |>
  mutate(
    psi11 = as.numeric(V1),   # top
    psi12 = as.numeric(V2),   # left
    psi13 = as.numeric(V3),   # right
    alpha = V4
  )

# --- barycentric (psi11, psi12, psi13) -> Cartesian (X,Y)
# Vertices: Left=(0,0) [psi12], Right=(1,0) [psi13], Top=(0.5, sqrt(3)/2) [psi11]
tri_h <- sqrt(3)/2
df_xy <- df |>
  mutate(
    S  = psi11 + psi12 + psi13,         # should be 1, but keep for safety
    X  = 0.5 * (2*psi13 + psi11) / S,
    Y  = (tri_h * psi11) / S
  )

# --- triangle boundary for annotation
triangle <- tibble(
  X = c(0, 1, 0.5, 0),
  Y = c(0, 0, tri_h, 0)
)

# --- plot: filled density (like stat_density_tern) + points + facets
ggplot(df_xy, aes(X, Y)) +
  # density "polygons" (2D KDE on projected plane)
  stat_density_2d_filled(contour = TRUE, bins = 12, alpha = 0.9) +
  # points overlay (light, like your pch = "+")
  geom_point(alpha = 0.25, shape = 3, size = 0.6) +
  # triangle outline
  geom_path(data = triangle, aes(X, Y), inherit.aes = FALSE, linewidth = 0.6) +
  # vertex labels
  annotate("text", x = 0.5, y = tri_h + 0.04, label = "psi11", fontface = "bold") +
  annotate("text", x = -0.04, y = -0.02,       label = "psi12", fontface = "bold", hjust = 1) +
  annotate("text", x = 1.04, y = -0.02,        label = "psi13", fontface = "bold", hjust = 0) +
  coord_equal(clip = "off") +
  #scale_fill_viridis_d(name = NULL) +
  scale_fill_viridis_d(option = "A", direction = -1) +
  guides(fill = "none") +
  labs(x = NULL, y = NULL) +
  theme_void(base_size = 12) +
  theme(
    plot.margin = margin(10, 20, 10, 20),
    strip.text = element_text(face = "bold"),
    panel.background = element_rect(fill = "white", colour = NA)
  ) +
  facet_wrap(~ alpha, ncol = 3)

```



Going back to our example, in NIMBLE, we consider a Dirichlet prior for each triplet of movement parameters, from site 1 ($\psi^{11}$, $\psi^{12}$ and $\psi^{13}$), from site 2 ($\psi^{21}$, $\psi^{22}$ and $\psi^{23}$) and from site 3 ($\psi^{31}$, $\psi^{32}$ and $\psi^{33}$). 

We start by setting the scene with comments:
```{r eval=FALSE}
...
  # -------------------------------------------------
  # Parameters:
  # phi1: survival prob site 1
  # phi2: survival prob site 2
  # phi3: survival prob site 3
  # psi11 = psi1[1]: mov prob site 1 -> site 1 (reference)
  # psi12 = psi1[2]: mov prob site 1 -> site 2
  # psi13 = psi1[3]: mov prob site 1 -> site 3 
  # psi21 = psi2[1]: mov prob site 2 -> site 1
  # psi22 = psi2[2]: mov prob site 2 -> site 2 (reference)
  # psi23 = psi2[3]: mov prob site 2 -> site 3
  # psi31 = psi3[1]: mov prob site 3 -> site 1
  # psi32 = psi3[2]: mov prob site 3 -> site 2
  # psi33 = psi3[3]: mov prob site 3 -> site 3 (reference)
  # p1: recapture prob site 1
  # p2: recapture prob site 2
  # p3: recapture prob site 3
  # -------------------------------------------------
  # States (z):
  # 1 alive at 1
  # 2 alive at 2
  # 2 alive at 3
  # 3 dead
  # Observations (y):  
  # 1 not seen
  # 2 seen at 1 
  # 3 seen at 2
  # 3 seen at 3
...
```


```{r eval = FALSE}
multisite <- nimbleCode({
...
  # transitions: Dirichlet priors
  psi1[1:3] ~ ddirch(alpha[1:3]) # psi11, psi12, psi13
  psi2[1:3] ~ ddirch(alpha[1:3]) # psi21, psi22, psi23
  psi3[1:3] ~ ddirch(alpha[1:3]) # psi31, psi32, psi33
...
```

Then we use these parameters (which now respect the constraints) to define the transition matrix:

```{r eval = FALSE}
multisite <- nimbleCode({
...
  # probabilities of state z(t+1) given z(t)
  gamma[1,1] <- phi1 * psi1[1]
  gamma[1,2] <- phi1 * psi1[2]
  gamma[1,3] <- phi1 * psi1[3]
  gamma[1,4] <- 1 - phi1
  gamma[2,1] <- phi2 * psi2[1]
  gamma[2,2] <- phi2 * psi2[2]
  gamma[2,3] <- phi2 * psi2[3]
  gamma[2,4] <- 1 - phi2
  gamma[3,1] <- phi3 * psi3[1]
  gamma[3,2] <- phi3 * psi3[2]
  gamma[3,3] <- phi3 * psi3[3]
  gamma[3,4] <- 1 - phi3
  gamma[4,1] <- 0
  gamma[4,2] <- 0
  gamma[4,3] <- 0
  gamma[4,4] <- 1
...
```

When we fit this model to the geese dataset with the detections in the Carolinas wintering site back in, and with `alpha <- c(1, 1, 1)` passed to the constants, we obtain the following results: 
```{r echo = FALSE}
load(here::here("dat","geese_3sites_dirichlet.RData"))
```
```{r}
MCMCsummary(mcmc.multisite, round = 2)
```

Survival probabilities are similar among sites, although lower in the mid-Atlantic (`phi[1]`). The detection probability in Carolinas (`p3`) seems much lower than in the two other wintering sites. The estimated probability of moving to the Chesapeake from the Carolinas (`psi3[2]`) is 2 times as high as the probability of moving in the opposite direction (`psi2[3]`).

In theory, you could include covariates as in Section \@ref(covariates) through the $\alpha$ parameters and the use a log link function (to ensure $\alpha > 0$), e.g. $\log(\alpha) = \beta_1 + \beta_2 x$. However, NIMBLE does not allow that. Fortunately, there is another way to specify the Dirichlet distribution through a ratio of gamma distributions that allows to incorporate covariates.  

The gamma distribution is continuous. It has two parameters $\alpha$ and $\theta$ that control its shape and scale (Figure \@ref(fig:gammadistribution)). Another parameterization considers its shape and rate which is the inverse of the scale. 

(ref:captiongamma) The distribution gamma($\alpha$,$\theta$) for different values of $\alpha$ and $\theta$. The shape argument $\alpha$ determines the overall shape while the scale parameter $\theta$ only affects the scale values (compare the values on X- and Y-axes between the bottom and upper panels). The exponential and chi-square distributions are particular cases of the gamma distribution. If the parameter shape is close to zero, the gamma is very similar to the exponential (bottom and upper left panels). If the parameter shape is large, then the gamma is similar to the chi-squared distribution (bottom and upper right panels).

```{r gammadistribution, echo = FALSE, fig.cap='(ref:captiongamma)'}
# https://blog.revolutionanalytics.com/2015/10/parameters-and-percentiles-the-gamma-distribution.html
plotGamma <- function(shape=2, rate=0.5, to=0.99, p=c(0.1, 0.9), cex=1, ...){
  to <- qgamma(p = to, shape = shape, rate = rate)
  curve(dgamma(x, shape, rate), from = 0, to = to, n = 500, type="l", 
        main = sprintf("gamma(%1.1f, %1.1f)", shape, rate),
        bty = "n", xaxs = "i", yaxs = "i", col = "blue", xlab = "", ylab = "", 
        las = 1, lwd = 2, cex = cex, cex.axis = cex, cex.main = cex, ...)
}
par(mfrow = c(2, 3))
plotGamma(1, 0.1)
plotGamma(3, 0.1)
plotGamma(6, 0.1)
plotGamma(1, 1)
plotGamma(3, 1)
plotGamma(6, 1)
```

If we have three independent random variables $Y_1, Y_2$ and $Y_3$ distributed as gamma distributions with shape parameters the $\alpha$'s and same scale parameter $\theta$, that is $Y_j \sim \text{Gamma}(\alpha_j, \theta)$, then it can be shown that the vector $(Y_1/V, Y_2/V, Y_3/V)$ is Dirichlet with vector of parameters the $\alpha$'s, where $V$ is the sum of the $Y$'s (which is also gamma distributed). In NIMBLE, this suggests using $\theta = 1$ to get a uniform prior:

```{r eval = FALSE}
...
# transitions: Dirichlet priors with Gamma formulation
for (s in 1:3){
  # Y1, Y2, Y3 for psi11, psi12, psi13
  lpsi1[s] ~ dgamma(alpha[s], 1) 
  psi1[s] <- lpsi1[s]/V1 # psi11, psi12, psi13
  # Y'1, Y'2, Y'3 for psi21, psi22, psi23
  lpsi2[s] ~ dgamma(alpha[s], 1) 
  psi2[s] <- lpsi2[s]/V2 # psi21, psi22, psi23
  # Y''1, Y''2, Y''3 for psi31, psi32, psi33
  lpsi3[s] ~ dgamma(alpha[s], 1) 
  psi3[s] <- lpsi3[s]/V3 # psi31, psi32, psi33
}
V1 <- sum(lpsi1[1:3])
V2 <- sum(lpsi2[1:3])
V3 <- sum(lpsi3[1:3])
...
```

From there, we can express the shape parameter of the gamma distribution (precisely the $\alpha$'s here) as a function of covariates as in $\log(\alpha) = \beta_1 + \beta_2 x$ in the spirit of a generalized linear model with a gamma response.

<!-- <https://en.wikipedia.org/wiki/Dirichlet_distribution#Related_distributions>, <https://en.wikipedia.org/wiki/Dirichlet_distribution#Random_variate_generation>, <https://groups.google.com/g/nimble-users/c/4XrJbRLUOyY/m/iDLeAIovAQAJ> -->


### Multinomial logit {#multinomiallogit}

<!-- <https://socialwork.wayne.edu/research/pdf/multi-nomial-logistic-regression.pdf>, <https://www3.nd.edu/~rwilliam/stats3/Mlogit1.pdf>, <https://stats.oarc.ucla.edu/stata/dae/multinomiallogistic-regression/> and <https://en.wikipedia.org/wiki/Multinomial_logistic_regression>. -->

Another possibility to build a prior that ensures the movement probabilities are between 0 and 1 and sum up to 1 is to extend the logit link we used for the CJS model in Section \@ref(covariates). Remember we had $\text{logit}(\phi) = \beta$, we specified a prior on $\beta$ say $\beta \sim N(0,1.5)$ then got a prior on $\phi$ by back-transforming $\beta$ with $\phi = \text{logit}^{-1}(\beta)$. 

Going back to our example with $3$ sites, and focusing on the movement probabilities say, from site 1, we first choose a reference (or pivot) site, say 1, then $\log\left(\displaystyle{\frac{\psi^{12}}{\psi^{11}}}\right) = \beta_2$ and $\log\left(\displaystyle{\frac{\psi^{13}}{\psi^{11}}}\right) = \beta_3$. Interestingly, when exponentiated, the $\beta$'s here can be interpreted as the increase in the odds of moving versus staying on site resulting from a one-unit increase in the covariate. Any of the sites can be chosen to be the reference, this will not change the likelihood and you will get the same results. Now we specify a normal prior distribution for the $\beta$'s. Eventually, to back-transform, we use $\psi^{12} = \displaystyle{\frac{\exp(\beta_2)}{1+\displaystyle{\exp(\beta_2)+\displaystyle{\exp(\beta_3)}}}}$ and $\psi^{13} = \displaystyle{\frac{\exp(\beta_3)}{1+\displaystyle{\exp(\beta_2)+\displaystyle{\exp(\beta_3)}}}}$. The reference parameter, here $\psi^{11}$, is calculated as $\psi^{11} = \displaystyle{\frac{1}{1 + \displaystyle{\exp(\beta_2)+\displaystyle{\exp(\beta_3)}}}}$, or simply as the complementary probability $\psi^{11} = 1 - \psi^{12} - \psi^{13}$.

Note that when there are only 2 sites instead of 3 or more, then the multinomial logit reduces to the logit link. 

In NIMBLE, we write:

```{r eval = FALSE}
multisite <- nimbleCode({
...
  # transitions: multinomial logit
  for (i in 1:2){
    # normal priors on logit of all but one movement prob
    beta1[i] ~ dnorm(0, sd = 1.5)
    beta2[i] ~ dnorm(0, sd = 1.5)
    beta3[i] ~ dnorm(0, sd = 1.5)
    # constrain the transitions such that their sum is < 1
    psi1[i] <- exp(beta1[i]) / (1 + exp(beta1[1]) + exp(beta1[2]))
    psi2[i] <- exp(beta2[i]) / (1 + exp(beta2[1]) + exp(beta2[2]))
    psi3[i] <- exp(beta3[i]) / (1 + exp(beta3[1]) + exp(beta3[2]))
  }
  # reference movement probability
  psi1[3] <- 1 - psi1[1] - psi1[2]
  psi2[3] <- 1 - psi2[1] - psi2[2]
  psi3[3] <- 1 - psi3[1] - psi3[2]
...
```

Then we use these parameters (which now respect the constraints) to define the transition matrix:

```{r eval = FALSE}
multisite <- nimbleCode({
...
  # probabilities of state z(t+1) given z(t)
  gamma[1,1] <- phi1 * psi1[1]
  gamma[1,2] <- phi1 * psi1[2]
  gamma[1,3] <- phi1 * psi1[3]
  gamma[1,4] <- 1 - phi1
  gamma[2,1] <- phi2 * psi2[1]
  gamma[2,2] <- phi2 * psi2[2]
  gamma[2,3] <- phi2 * psi2[3]
  gamma[2,4] <- 1 - phi2
  gamma[3,1] <- phi3 * psi3[1]
  gamma[3,2] <- phi3 * psi3[2]
  gamma[3,3] <- phi3 * psi3[3]
  gamma[3,4] <- 1 - phi3
  gamma[4,1] <- 0
  gamma[4,2] <- 0
  gamma[4,3] <- 0
  gamma[4,4] <- 1
...
```

You may check that the results are very similar to those we obtained with the Dirichlet prior:

```{r echo = FALSE}
load(here::here("dat","geese_3sites_logit.RData"))
```
```{r}
MCMCsummary(mcmc.multisite, round = 2)
```

Both the Dirichlet prior and the multinomial logit link give similar results, and there is not much difference in terms of runtime or quality of convergence, so you should use the option you feel the most comfortable with. 

## Sites may be states {#states}

So far, we have considered geographical locations (or sites) to refine the alive information when an animal is detected. However, it was quickly realized that sites could actually be states defined by physiology or behavior, hence opening up an avenue for applications of capture-recapture models in many fields of ecology. 

Examples of states include:  

+ Epidemiological or disease states: sick/healthy, uninfected/infected/recovered;  
+ Morphological states: small/medium/big, light/medium/heavy;  
+ Life-history states: e.g. breeder/non-breeder,  failed breeder, first-time breeder;  
+ Developmental states: e.g. juvenile/subadult/adult;  
+ Social states: e.g. solitary/group-living,  subordinate/dominant;  
+ Death states: e.g. alive, dead from harvest, dead from natural causes.  

In brief, states are individual, time-specific discrete covariates.

### Titis data 

To illustrate this section, we will consider data collected between 1942 and 1956 by Lance Richdale on the Sooty shearwaters (*Ardenna grisea*), also known as titis (Figure \@ref(fig:pixtiti)).

```{r pixtiti, echo=FALSE, out.width="100%", fig.cap="Sooty shearwater (*Ardenna grisea*). Credit: John Harrison.", fig.align='center'}
knitr::include_graphics("images/titi.jpg")
```

You may see the data below: 

```{r echo = TRUE, eval = FALSE}
titis <- read_csv2("titis.csv", 
                   col_names = FALSE)
titis %>%
  rename(year_1942 = X1,
         year_1943 = X2,
         year_1944 = X3,
         year_1949 = X4,
         year_1952 = X5,
         year_1953 = X6,
         year_1956 = X7)
```

```{r echo = FALSE}
titis <- read_csv2("dat/titis.csv", 
                   col_names = FALSE)
titis %>%
  rename(year_1942 = X1,
         year_1943 = X2,
         year_1944 = X3,
         year_1949 = X4,
         year_1952 = X5,
         year_1953 = X6,
         year_1956 = X7)
```

In total, 1013 titis were captured, marked and recaptured on a small colony on Whero Island in southern New Zealand. These data were previously analyzed by Richard Scofield who kindly provided us with the data. 

Following the way the data were collected, four states were originally considered: Alive breeder; Accompanied by another bird in a burrow; Alone in a burrow; On the surface; Dead. For simplicity, we pooled all alive states (except breeder) together in a non-breeder state (NB) that includes failed breeders (birds that had bred previously – skip reproduction or divorce) and pre-breeders (birds that had yet to breed). Because burrows were not checked before hatching, some birds in the category NB might have already failed. Therefore birds in the breeder state (B) should be seen as successful breeders, and those in the NB state as nonbreeders plus prebreeders and failed breeders. 

In summary, we code the states as 1 for alive and breeding, 2 for alive and non-breeding and 3 for dead. To make the modelling process more self-explanatory, we will use letters B, NB and D but you should keep in mind that these are actually numbers. Observations are non-detected coded as 1, and detected as breeder or non-breeder coded as 2 and 3 respectively.

The aim here is to study life-history trade--offs. Specifically, we ask the questions: Does breeding affect survival? Does breeding in current year affect breeding next year?

### The AS model for states

Basically, the AS model with states is the same model as in the geese example with two sites, see Sections \@ref(ASmodel) and \@ref(ASmodelfitting).

If we let $\phi^B$ and $\phi^{NB}$ be the survival probabilities of breeders and non-breeders, $\psi^{NBB}$ the probability of becoming breeder for a non-breeder, and $\psi^{BNB}$ the probability of skipping reproduction, then the transition matrix is:

$$\begin{matrix}
& \\
\Gamma =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    z_t=B & z_t=NB & z_t=D \\[0.3em] \hdashline
\phi^B (1-\psi^{BNB}) & \phi^B \psi^{BNB} & 1 - \phi^B\\
\phi^{NB} \psi^{NBB} & \phi^{NB} (1-\psi^{NBB}) & 1 - \phi^{NB}\\
0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
    \begin{matrix}
    z_{t-1}=B \\ z_{t-1}=NB \\ z_{t-1}=D
    \end{matrix}
\end{matrix}$$

The costs or reproduction would reflect in future reproduction if breeders have a lower probability of breed next year than non-breeders $\psi^{BB} = 1 - \psi^{BNB} < \psi^{NBB}$ or in survival if the survival of breeders is lower than that of non-breeders $\phi^B < \phi^{NB}$.

The observation matrix is:

$$\begin{matrix}
& \\
\Omega =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    y_t=1 & y_t=2 & y_t=3 \\[0.3em] \hdashline
1 - p^B & p^B & 0\\
1 - p^{NB} & 0 & p^{NB}\\
1 & 0 & 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
    \begin{matrix}
    z_{t}=B \\ z_{t}=NB \\ z_{t}=D
    \end{matrix}
\end{matrix}$$

where $p^B$ and $p^{NB}$ are the detection proabilities of non-breeders and breeders respectively. 

### NIMBLE implementation

We first write the NIMBLE code, which is exactly the same as in the geese example with two sites, see Section \@ref(ASmodelfitting). 

First some definitions which we have as comments in the code:
```{r eval = FALSE}
multistate <- nimbleCode({
  # -------------------------------------------------
  # Parameters:
  # B is for breeder, NB for non-breeder
  # phiB: survival probability state B
  # phiNB: survival probability state NB
  # psiBNB: transition probability from B to NB
  # psiNBB: transition probability from NB to B
  # pB: detection probability B
  # pNB: detection probability NB
  # -------------------------------------------------
  # States (z):
  # 1 alive B
  # 2 alive NB
  # 3 dead
  # Observations (y):
  # 1 not seen
  # 2 seen as B
  # 3 seen as NB
  # -------------------------------------------------
...
```

Then the priors:
```{r eval = FALSE}
multistate <- nimbleCode({
...
  # Priors
  phiB ~ dunif(0, 1)
  phiNB ~ dunif(0, 1)
  psiBNB ~ dunif(0, 1)
  psiNBB ~ dunif(0, 1)
  pB ~ dunif(0, 1)
  pNB ~ dunif(0, 1)
...
```

The transition matrix:
```{r eval = FALSE}
multistate <- nimbleCode({
...
  # probabilities of state z(t+1) given z(t)
  gamma[1,1] <- phiB * (1 - psiBNB)
  gamma[1,2] <- phiB * psiBNB
  gamma[1,3] <- 1 - phiB
  gamma[2,1] <- phiNB * psiNBB
  gamma[2,2] <- phiNB * (1 - psiNBB)
  gamma[2,3] <- 1 - phiNB
  gamma[3,1] <- 0
  gamma[3,2] <- 0
  gamma[3,3] <- 1
...
```

The observation matrix:
```{r eval = FALSE}
multistate <- nimbleCode({
...
  # probabilities of y(t) given z(t)
  omega[1,1] <- 1 - pB    # Pr(alive B t -> non-detected t)
  omega[1,2] <- pB        # Pr(alive B t -> detected B t)
  omega[1,3] <- 0         # Pr(alive B t -> detected NB t)
  omega[2,1] <- 1 - pNB   # Pr(alive NB t -> non-detected t)
  omega[2,2] <- 0         # Pr(alive NB t -> detected B t)
  omega[2,3] <- pNB       # Pr(alive NB t -> detected NB t)
  omega[3,1] <- 1         # Pr(dead t -> non-detected t)
  omega[3,2] <- 0         # Pr(dead t -> detected N t)
  omega[3,3] <- 0         # Pr(dead t -> detected NB t)
...
```

And the likelihood:
```{r eval = FALSE}
multistate <- nimbleCode({
...
  # likelihood
  for (i in 1:N){
    # latent state at first capture
    z[i,first[i]] <- y[i,first[i]] - 1
    for (t in (first[i]+1):K){
      # z(t) given z(t-1)
      z[i,t] ~ dcat(gamma[z[i,t-1],1:3])
      # y(t) given z(t)
      y[i,t] ~ dcat(omega[z[i,t],1:3])
    }
  }
})
```

We run NIMBLE and get the following results:
```{r echo = FALSE}
load(here::here("dat","titis.RData"))
```
```{r}
MCMCsummary(mcmc.multistate, round = 2)
```

Non-breeder individuals seem to have a survival higher than breeder individuals, suggesting a trade-off between reproduction and survival. Let's compare graphically the survival of breeder and non-breeder individuals. First we gather the values generated for $\phi^B$ and $\phi^{NB}$ for the two chains:

```{r}
phiB <- c(mcmc.multistate$chain1[,"phiB"], 
          mcmc.multistate$chain2[,"phiB"])
phiNB <- c(mcmc.multistate$chain1[,"phiNB"], 
           mcmc.multistate$chain2[,"phiNB"])
df <- data.frame(param = c(rep("phiB", length(phiB)), 
                           rep("phiNB", length(phiB))), 
                 value = c(phiB, phiNB))
```

Then, we plot the two posterior distributions:

```{r}
if (params$bw) {
  df %>%
    ggplot(aes(x = value, fill = param)) +
    geom_density(color = "white", alpha = 0.6, position = 'identity') +
    scale_fill_manual(values = c("grey70", "black")) +
    labs(fill = "", x = "survival")
} else {
  df %>%
    ggplot(aes(x = value, fill = param)) +
    geom_density(color = "white", alpha = 0.6, position = 'identity') +
    scale_fill_manual(values = c("#69b3a2", "#404080")) +
    labs(fill = "", x = "survival")
}

```

There is little overlap between the two distributions, suggesting an actual trade--off. A formal test of the trade-off would consist in fitting the model with survival irrespective of the state, and compare its WAIC value to the model we just fitted.

What about a potential trade-off on reproduction?

```{r}
psiBNB <- c(mcmc.multistate$chain1[,"psiBNB"], 
            mcmc.multistate$chain2[,"psiBNB"])
psiBB <- 1 - psiBNB
psiNBB <- c(mcmc.multistate$chain1[,"psiNBB"], 
            mcmc.multistate$chain2[,"psiNBB"])
df <- data.frame(param = c(rep("psiBB", length(phiB)), 
                           rep("psiNBB", length(phiB))), 
                 value = c(psiBB, psiNBB))

if (params$bw) {
  df %>%
    ggplot(aes(x = value, fill = param)) +
    geom_density(color = "white", alpha = 0.6, position = 'identity') +
    scale_fill_manual(values = c("grey70", "black")) +
    labs(fill = "", x = "breeding probabilities")
} else {
  df %>%
    ggplot(aes(x = value, fill = param)) +
    geom_density(color = "white", alpha = 0.6, position = 'identity') +
    scale_fill_manual(values = c("#69b3a2", "#404080")) +
    labs(fill = "", x = "breeding probabilities")
}

```

There is no overlap whatsoever, so the two transition probabilities are clearly different. Interestingly, breeder individuals do much better than non-breeder individuals. This failure at detecting a trade-off is probably due to individual heterogeneity that should be accounted for. You could add an individual random effect as in Section \@ref(randomeffects) or consider 2 classes of individuals as we will do in a case study at Section \@ref(indhet).

<!-- See M. Paquet suggestion: Pouvoir utiliser le modèle à la fois pour simuler des données, puis ensuite pour les ajuster au modèle (le tout sans avoir à réécrire le modèle!). Exemple: nodesToSim <- model$getDependencies(c("parameter_name1","parameter_name2"), self = F, downstream = T), # compile Cmodel <- compileNimble(model), #simulate Cmodel$simulate(nodesToSim) -->
  
## Issue of local minima {#localminima}

In the frequentist approach, we use the maximum likelihood theory to estimate parameters. The maximum likelihood estimates are the values that get you to the maximum of the model likelihood. To find out the maximum of the likelihood, we use iterative optimization algorithms (e.g. the default method is that of Nelder and Mead in the R `optim()` function). However, sometimes, our model likelihood contains several maxima and there is no guarantee that the algorithms will find the global maximum corresponding to the maximum likelihood estimates, and it may get stuck in a local maximum. Let's illustrate this issue with some simulated data that were kindly provided by Jérôme Dupuis. We consider 2 sites (or alive states), say 1 and 2, and 7 sampling occasions. The survival probability is constant $\phi = 1$ as well as the detection probability $p = 0.6$. The probability of moving from 1 to 2 is $\psi^{12} = 0.6$ and $\psi^{21} = 0.85$ in the opposite direction. Here are the encounter histories of the 27 individuals that were simulated by Jérôme:

```{r echo = TRUE}
dat <- matrix(c(2, 0, 2, 1, 2, 0, 2,
                2, 0, 2, 1, 2, 0, 2,
                2, 0, 2, 1, 2, 0, 2,
                2, 0, 2, 1, 2, 0, 2,
                1, 1, 1, 0, 1, 0, 1,
                1, 1, 1, 0, 1, 0, 1,
                1, 1, 1, 0, 1, 0, 1,
                1, 1, 1, 0, 1, 0, 1,
                2, 0, 2, 0, 2, 0, 1,
                2, 0, 2, 0, 2, 0, 1,
                2, 0, 2, 0, 2, 0, 1,
                2, 0, 2, 0, 2, 0, 1,
                1, 0, 1, 0, 1, 0, 1,
                1, 0, 1, 0, 1, 0, 1,
                1, 0, 1, 0, 1, 0, 1,
                1, 0, 1, 0, 1, 0, 1,
                2, 0, 2, 0, 2, 0, 2,
                2, 0, 2, 0, 2, 0, 2,
                2, 0, 2, 0, 2, 0, 2,
                2, 0, 2, 0, 2, 0, 2,
                1, 0, 1, 0, 1, 0, 2,
                1, 0, 1, 0, 1, 0, 2,
                1, 0, 1, 0, 1, 0, 2,
                1, 0, 1, 0, 1, 0, 2,
                2, 2, 0, 1, 0, 2, 1,
                2, 2, 0, 1, 0, 2, 1,
                2, 2, 0, 1, 0, 2, 1,
                2, 2, 0, 1, 0, 2, 1,
                2, 1, 0, 2, 0, 1, 1,
                2, 1, 0, 2, 0, 1, 1,
                2, 1, 0, 2, 0, 1, 1,
                2, 1, 0, 2, 0, 1, 1),
              byrow = T,
              ncol = 7)
```

In Figure \@ref(fig:inits), we provide an illustration of the influence of the choice of initial values when trying to maximize the likelihood, or rather to minimize the deviance (which is minus two times the log of the likelihood). The black curve is the what we called the profile deviance for $\psi^{21}$. Profiling the deviance consists in taking a slice of it in the direction of a parameter of interest and treating the other parameters as nuisance parameters. In our example, we set $\psi^{21}$ to a value (on the x-axis) an minimize the deviance (on the y-axis) with respect to the other parameters. There are two minima, but only the global minimum (corresponding to the lowest value of deviance) corresponding to $\psi^{21}$ around 0.8 is of interest to us. The thing is that if you start your optimization algorithm by picking value in the red area, then it will get stuck in the local minimum and will tell you the maximum likelihood estimate of $\psi^{21}$ is around 0.35, which is obviously far from the value we used to simulate the data. In contrast, if you pick initial values in the green area, then the algorithm will converge to the global minimum. 

```{r inits, echo = FALSE, fig.cap = "Influence of the choice of initial values on the convergence to the global minimum of the deviance illustrated with simulated data. The black curve is the profile deviance of the probability to move from site 2 to 1. If an initial value is picked in the red area (on the left), we end up in the local minimum while if it is picked in the green area (on the right), then we get the global minimum which corresponds to the maximum lilkelihood estimate.", fig.show = "hold", out.width="100%"}
knitr::include_graphics("images/multistate_local_minimav2_Page_07.png")
```

You might argue that this is a problem of the optimization algorithm and therefore inherent to the frequentist approach. Well, it turns out that MCMC algorithms are not immune to the issue. If you fit the AS model with constant parameters to the simulated data, here is the trace for the probability of moving from 2 to 1:

```{r, echo = FALSE}
load(here::here("dat","localminima.RData"))
psiBA <- c(mcmc.multisite$chain1[,"psi21"], mcmc.multisite$chain2[,"psi21"])
plotpsiBA <- psiBA %>%
  as_tibble() %>%
  ggplot() +
  aes(x = 1:length(value), y = value) +
  geom_line(color = "gray70") +
  labs(y = "psi21", x = "iterations") +
  geom_hline(yintercept = 0.85, lty = 2, color = "blue")

psiAB <- c(mcmc.multisite$chain1[,"psi12"],mcmc.multisite$chain2[,"psi12"])
plotpsiAB <- psiAB %>%
  as_tibble() %>%
  ggplot() +
  aes(x = 1:length(value), y = value) +
  geom_line(color = "gray70") +
  labs(y = "psi12", x = "iterations") +
  geom_hline(yintercept = 0.6, lty = 2, color = "blue")

det <- c(mcmc.multisite$chain1[,"p"], mcmc.multisite$chain2[,"p"])
plotdet <- det %>%
  as_tibble() %>%
  ggplot() +
  aes(x = 1:length(value), y = value) +
  geom_line(color = "gray70") +
  labs(y = "detection", x = "iterations") +
  geom_hline(yintercept = 0.6, lty = 2, color = "blue")

#plotdet / (plotpsiAB + plotpsiBA)

plotpsiBA
```

Clearly, there are two regimes. The chain spends most of its time around high values of $\psi^{21}$ close to the true value represented by the blue dashed line. But sometimes, the chain jumps to values around 0.3-0.4. This behavior translates into two modes in the posterior distribution for $\psi^{21}$ where the mode on the right is closer to the truth represented by the dashed blue vertical line:

```{r, echo = FALSE}
load(here::here("dat","localminima.RData"))
psiBA <- c(mcmc.multisite$chain1[,"psi21"], mcmc.multisite$chain2[,"psi21"])
plotpsiBA <- psiBA %>%
  as_tibble() %>%
  ggplot() +
  aes(x = value) +
  geom_histogram(color = "white", binwidth = .03, fill = "gray70") +
  geom_density(aes(y = .03 * ..count..)) +
  labs(x = "psi21", y = "") +
  geom_vline(xintercept = 0.85, lty = 2, color = "blue")

psiAB <- c(mcmc.multisite$chain1[,"psi12"],mcmc.multisite$chain2[,"psi12"])
plotpsiAB <- psiAB %>%
  as_tibble() %>%
  ggplot() +
  aes(x = value) +
  geom_histogram(color = "white", binwidth = .03, fill = "gray70") +
  geom_density(aes(y = .03 * ..count..)) +
  labs(x = "psi12", y = "") +
  geom_vline(xintercept = 0.6, lty = 2, color = "blue")


det <- c(mcmc.multisite$chain1[,"p"], mcmc.multisite$chain2[,"p"])
plotdet <- det %>%
  as_tibble() %>%
  ggplot() +
  aes(x = value) +
  geom_histogram(color = "white", binwidth = .03, fill = "gray70") +
  geom_density(aes(y = .03 * ..count..)) +
  labs(x = "detection", y = "") +
  geom_vline(xintercept = 0.6, lty = 2, color = "blue")

#library(patchwork)
#plotdet / (plotpsiAB + plotpsiBA)

plotpsiBA
```

The issue of local minima is a difficult problem. How to get out of this problematic situation? In the frequentist approach, the trick is to fit your model several times with different initial values each time, hoping that you'll get to fall in the green area somehow as in Figure \@ref(fig:inits). In the Bayesian approach, the key to handle distributions with multiple modes is to sample the posteriors efficiently. Assuming the chains we run in NIMBLE spend more time in the region of the parameter space corresponding to the global minimum, then I recommend using the median or the mode to summarize the posterior distribution. In the simulated example, we get a median of 0.79 for $\psi^{21}$, not too bad given that the data were simulated with a value of 0.85 for that parameter:

```{r echo = FALSE}
load(here::here("dat","localminima.RData"))
```
```{r}
MCMCsummary(mcmc.multisite, round = 2)
```

As a general advice, I recommend to always inspect the trace plots to find out whether you have posterior distributions with multiple modes which would suggest local minima.

## Uncertainty {#multievent}

In the AS model, we assume that we can without a doubt assign a site or a state to an animal whenever it is detected. But this is not always the case. For example, when the breeding status in mammals or birds is ascertained based on the presence of offspring or eggs, we are uncertain of whether a female is breeding or not when the offspring or eggs are not seen. Another example is when the epidemiological status in mammals or birds is ascertained based on some tests run on some animals when captured, we are uncertain whether these animals are healthy or sick when detected from distance without possibility to manipulate them for testing. In this section we will cover the extension of the AS model to uncertain states -- known as multievent models after @pradel_multievent_2005 -- through two examples, one on breeding states and the other on disease states. We will cover other examples in the part on Case studies.

### Breeding states {#breedingmultievent}

We will revisit the titis example \@ref(states) and try to assess life-history trade-offs while accounting for uncertainty in breeding status. We still have 3 states, which are alive and breeding, alive and non-breeding and dead. With regard to observations, a bird may be not encountered. It may also be encountered, but in contrast with our previous analysis of the titis data, we don't know its state for sure. It may be found and ascertained (or classified) as breeder. It may be found and ascertained as non-breeder. It may be found but we are unable to determine whether it's breeding or non-breeding. 

<!-- Ingredients -->

<!-- + 3 states -->
<!--     + breeding (B) -->
<!--     + non-breeding (NB) -->
<!--     + dead (D) -->

<!-- + 4 observations -->
<!--     + not encountered (0) -->
<!--     + found, ascertained as breeder (1) -->
<!--     + found, ascertained as non-breeder (2) -->
<!--     + found, status unknown (3) -->

How do the states generate the observations?

```{r, echo = FALSE}
ggplot() +
  geom_point(aes(1, 1), size = 2.5, alpha = .7) +
  geom_point(aes(1, 1.5), size = 2.5, alpha = .7) +
  geom_point(aes(1, 2), size = 2.5, alpha = .7) +
  geom_text(aes(1.5, 2, label = 'not encountered'), nudge_x = 1, size = 7) +
  geom_text(aes(1.5, 1.5, label = 'found, ascertained as breeder'), nudge_x = 1.5, size = 7) +
  geom_text(aes(1.5, 1, label = 'found, ascertained as non-breeder'), nudge_x = 1.7, size = 7) +
  geom_text(aes(1.5, 0.5, label = 'found, status unknown'), nudge_x = 1.2, size = 7) +
  geom_point(aes(1.5, 0.5), size = 2.5, alpha = .7) +
  geom_point(aes(1.5, 1), size = 2.5, alpha = .7) +
  geom_point(aes(1.5, 1.5), size = 2.5, alpha = .7) +
  geom_point(aes(1.5, 2), size = 2.5, alpha = .7) +
  geom_text(aes(.5, 2, label = 'breeding'), nudge_x = 0, size = 7) +
  geom_text(aes(.5, 1.5, label = 'non-breeding'), nudge_x = -0.2, size = 7) +
  geom_text(aes(.5, 1, label = 'dead'), nudge_x = 0.1, size = 7) +
  xlim(0, 4.5) +
  ylim(0.5, 3) +
  annotate('text', x = .5, y = 2.6, label = 'States', size = 10) +
  annotate('text', x = 2.5, y = 2.6, label = 'Observations', size = 10) +

  geom_segment(aes(x = 1, y = 1, xend = 1.5, yend = 2), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +

  geom_segment(aes(x = 1, y = 1.5, xend = 1.5, yend = 1), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 1.5, xend = 1.5, yend = 2), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 1.5, xend = 1.5, yend = .5), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +

  geom_segment(aes(x = 1, y = 2, xend = 1.5, yend = .5), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 2, xend = 1.5, yend = 1.5), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 2, xend = 1.5, yend = 2), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +

  theme_void()
```

Each alive state can generate 3 observations. The only deterministic link is that between the dead state and the observation non-encountered, because if a bird is dead, it cannot be detected for sure.

Let's specify the model. First thing we need, and it's a big difference with the AS model, we need initial state probabilities because we cannot assign states to individuals with certainty. We write down the probability for each state at first encounter, or the vector of initial state probabilities:

$$\begin{matrix}
& \\
\delta =
    \left ( \vphantom{ \begin{matrix} 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    z_t=B & z_t=NB & z_t=D \\[0.3em] \hdashline
\pi^B & 1 - \pi^{B} & 0\\
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \end{matrix} } \right )
    \begin{matrix}
    \end{matrix}
\end{matrix}$$

where $\pi^B$ is the probability that a newly encountered individual is a breeder, and $\pi^{NB} = 1 - \pi^B$ is the probability that a newly encountered individual is a non-breeder (the complementary probability of $\pi^B$). The probability of being dead at first encounter is 0 (a bird is alive when it is first encountered).

Now the transition matrix, this is the easy part as it doesn't change. We have:

$$\begin{matrix}
& \\
\Gamma =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    z_t=B & z_t=NB & z_t=D \\[0.3em] \hdashline
\phi^B (1-\psi^{BNB}) & \phi^B \psi^{BNB} & 1 - \phi^B\\
\phi^{NB} \psi^{NBB} & \phi^{NB} (1-\psi^{NBB}) & 1 - \phi^{NB}\\
0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
    \begin{matrix}
    z_{t-1}=B \\ z_{t-1}=NB \\ z_{t-1}=D
    \end{matrix}
\end{matrix}$$

where $\phi^B$ is the breeder survival, $\phi_ {NB}$ that of non-breeders, $\psi^{BNB}$ is the probability for an individual breeding a year to be a non-breeder the next year, and $\psi^{NBB}$ is the probability for an non-breeder individual to breeder the next year. 

Last, the observation matrix. The main difference between multisite/multistate and multievent models is here, in the observation parameters. Besides $p^B$ the detection probability of breeders and $p^{NB}$ that of non-breeders, we introduce two new parameters: $\beta^B$ is the probability to correctly assign an individual that is in state B to state B, and $\beta^{NB}$ is the probability to correctly assign an individual that is in state NB to state NB. The complementary of these $\beta$ parameters are often called false positive probabilities. We put everything in a matrix, as usual. In rows we have the states: breeding, non-breeding and dead. In columns, at the same occasion, we have the observations: non-detected, detected and ascertained B, detected and ascertained NB, and detected but state unknown:

$$\begin{matrix}
& \\
\Omega =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    y_t=1 & y_t=2 & y_t=3 & y_t=4 \\[0.3em] \hdashline
1 - p^B & p^B \beta^B & 0 & p^B (1-\beta_ B) \\
1-p^{NB} & 0 & p^{NB} \beta^{NB} & p^{NB} (1-\beta^{NB})\\
1 & 0 & 0 & 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right )
    \begin{matrix}
    z_{t}=B \\ z_{t}=NB \\ z_{t}=D
    \end{matrix}
\end{matrix}$$

For example, the probability of being detected and assigned to state B, given that you're in state B is the product of $p^B$ the detection probability in B and $\beta^B$ the probability of correctly assigning a breeding individual to state B.

At first encounter, all individuals are captured, but you still need to assign them a state. This means that we should set $p^B = p^{NB} = 1$ and use:

$$\begin{matrix}
& \\
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    y_{t = \text{first}}=1 & y_{t = \text{first}}=2 & y_{t = \text{first}}=3 & y_{t = \text{first}}=4 \\[0.3em] \hdashline
 0 & \beta^B & 0 & (1-\beta^B)\\
0 & 0 & \beta^{NB} & (1-\beta^{NB})\\
1 & 0 & 0 & 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right )
    \begin{matrix}
    z_{t = \text{first}}=B \\ z_{t = \text{first}}=NB \\ z_{t = \text{first}}=D
    \end{matrix}
\end{matrix}$$

To implement this model in NIMBLE, we start by using comments to define the parameters, states and observations in the header of the code:

```{r eval = FALSE}
multievent <- nimbleCode({
  # -------------------------------------------------
  # Parameters:
  # phiB: survival probability state B
  # phiNB: survival probability state NB
  # psiBNB: transition probability from B to NB
  # psiNBB: transition probability from NB to B
  # pB: recapture probability B
  # pNB: recapture probability NB
  # piB prob. of being in initial state breeder
  # betaNB prob ascertain breeding status of ind encountered as NB
  # betaB prob ascertain breeding status of ind encountered as B
  # -------------------------------------------------
  # States (z):
  # 1 alive B
  # 2 alive NB
  # 3 dead
  # Observations (y):
  # 1 = non-detected
  # 2 = seen and ascertained as breeder
  # 3 = seen and ascertained as non-breeder
  # 4 = not ascertained
  # -------------------------------------------------
...
```

Then we assign prior to all parameters to be estimated. Because we deal with probabilities, the uniform distribution between 0 and 1 will do the job:

```{r eval = FALSE}
multievent <- nimbleCode({
...
  # Priors
  phiB ~ dunif(0, 1)
  phiNB ~ dunif(0, 1)
  psiBNB ~ dunif(0, 1)
  psiNBB ~ dunif(0, 1)
  pB ~ dunif(0, 1)
  pNB ~ dunif(0, 1)
  piB ~ dunif(0, 1)
  betaNB ~ dunif(0, 1)
  betaB ~ dunif(0, 1)
...
```

Now we write the vector of initial state probabilities:
```{r eval = FALSE}
multievent <- nimbleCode({
...
  # vector of initial stats probs
  delta[1] <- piB # prob. of being in initial state B
  delta[2] <- 1 - piB # prob. of being in initial state NB
  delta[3] <- 0 # prob. of being in initial state dead
...
```

The transition matrix:

```{r eval = FALSE}
multievent <- nimbleCode({
...
  # probabilities of state z(t+1) given z(t)
  gamma[1,1] <- phiB * (1 - psiBNB)
  gamma[1,2] <- phiB * psiBNB
  gamma[1,3] <- 1 - phiB
  gamma[2,1] <- phiNB * psiNBB
  gamma[2,2] <- phiNB * (1 - psiNBB)
  gamma[2,3] <- 1 - phiNB
  gamma[3,1] <- 0
  gamma[3,2] <- 0
  gamma[3,3] <- 1
...
```

And the observation matrix:

```{r eval = FALSE}
multievent <- nimbleCode({
...
  # probabilities of y(t) given z(t)
  omega[1,1] <- 1 - pB             # Pr(alive B t -> non-detected t)
  omega[1,2] <- pB * betaB         # Pr(alive B t -> detected B t)
  omega[1,3] <- 0                  # Pr(alive B t -> detected NB t)
  omega[1,4] <- pB * (1 - betaB)   # Pr(alive B t -> detected U t)
  omega[2,1] <- 1 - pNB            # Pr(alive NB t -> non-detected t)
  omega[2,2] <- 0                  # Pr(alive NB t -> detected B t)
  omega[2,3] <- pNB * betaNB       # Pr(alive NB t -> detected NB t)
  omega[2,4] <- pNB * (1 - betaNB) # Pr(alive NB t -> detected U t)
  omega[3,1] <- 1                  # Pr(dead t -> non-detected t)
  omega[3,2] <- 0                  # Pr(dead t -> detected N t)
  omega[3,3] <- 0                  # Pr(dead t -> detected NB t)
  omega[3,4] <- 0                  # Pr(dead t -> detected U t)
...
```

The observation matrix at first encounter:
```{r eval = FALSE}
multievent <- nimbleCode({
...
  # probabilities of y(first) given z(first)
  # Pr(alive B t = first -> non-detected t = first)
  omega.init[1,1] <- 0          
  # Pr(alive B t = first -> detected B t = first)
  omega.init[1,2] <- betaB      
  # Pr(alive B t = first -> detected NB t = first)
  omega.init[1,3] <- 0          
  # Pr(alive B t = first -> detected U t = first)
  omega.init[1,4] <- 1 - betaB  
  # Pr(alive NB t = first -> non-detected t = first)
  omega.init[2,1] <- 0          
  # Pr(alive NB t = first -> detected B t = first)
  omega.init[2,2] <- 0          
  # Pr(alive NB t = first -> detected NB t = first)
  omega.init[2,3] <- betaNB     
  # Pr(alive NB t = first -> detected U t = first)
  omega.init[2,4] <- 1 - betaNB 
  # Pr(dead t = first -> non-detected t = first)
  omega.init[3,1] <- 1          
  # Pr(dead t = first -> detected N t = first)
  omega.init[3,2] <- 0          
  # Pr(dead t = first -> detected NB t = first)
  omega.init[3,3] <- 0          
  # Pr(dead t = first -> detected U t = first)
  omega.init[3,4] <- 0          
...
```

Eventually, we get to the likelihood:
```{r eval = FALSE}
multievent <- nimbleCode({
...
  # likelihood
  for (i in 1:N){
    # latent state at first capture
    z[i,first[i]] ~ dcat(delta[1:3])
    # obs at first encounter
    y[i,first[i]] ~ dcat(omega.init[z[i,first[i]],1:4]) 
    for (t in (first[i]+1):K){
      # z(t) given z(t-1)
      z[i,t] ~ dcat(gamma[z[i,t-1],1:3])
      # y(t) given z(t)
      y[i,t] ~ dcat(omega[z[i,t],1:4])
    }
  }
})
```

The only change is in the line `y[i,first[i]] ~ dcat(omega.init[z[i,first[i]],1:4])` where we use the observation matrix at first encounter. 

We run NIMBLE and get the following numerical summaries for the model parameters:
```{r echo = FALSE}
load(here::here("dat","titisuncertain.RData"))
```
```{r}
MCMCsummary(mcmc.multievent, round = 2)
```

Breeders are difficult to assign to the correct state $\beta^B$, while non-breeders are relatively well classified as non-breeders $\beta^{NB}$. 

There is again no cost of current reproduction on future reproduction. We no longer detect a cost of breeding on survival. 

<!-- Uncertainty was simulated, so no ecological interpretation to be found. Say it was simulated though. -->

### Disease states {#diseasemultievent}

Let's have a look to another example. We consider a system of an emerging pathogen *Mycoplasma gallisepticum* Edward and Kanarek and its host the house finch, *Carpodacus mexicanus* Müller. The pathogen causes moderate to severe eye swelling (Figure \@ref(fig:pixfinch)).

```{r pixfinch, echo=FALSE, fig.cap="A house finch with a heavy infection caused by conjunctivitis. Credit: Jim Mondok.", out.width="100%", fig.align='center'}
knitr::include_graphics("images/infectedhousefinch.jpg")
```

Here we're asking whether the presence of clinical signs of the pathogen influences survival. The objective of the study was also to quantify infection (moving from state healthy to state ill) and recovery (moving from state ill to state healthy) probabilities. The birds were captured via mist nets and marked with individually identifiable color bands over three years. The data were kindly provided by Paul Conn and Evan Cooch. The difficulty was that ascertaining the disease status of birds seen from distance was difficult since determining the presence of the pathogen was only possible when the bird's eyes were clearly visible. In this context, how to study the dynamics of the disease?

First, we think of states and observations. We have:

+ 3 states
    + healthy (H)
    + ill (I)
    + dead (D)

+ 4 observations
    + not seen (1)
    + captured healthy (2)
    + captured ill (3)
    + health status unknown, i.e. seen at distance (4)

How do the states generate observations?

```{r, echo = FALSE}
ggplot() +
  geom_point(aes(1, 1), size = 2.5, alpha = .7) +
  geom_point(aes(1, 1.5), size = 2.5, alpha = .7) +
  geom_point(aes(1, 2), size = 2.5, alpha = .7) +
  geom_text(aes(1.5, 2, label = 'not seen (1)'), nudge_x = 1.2, size = 7) +
  geom_text(aes(1.5, 1.5, label = 'captured healthy (2)'), nudge_x = 1.5, size = 7) +
  geom_text(aes(1.5, 1, label = 'captured ill (3)'), nudge_x = 1.3, size = 7) +
  geom_text(aes(1.5, 0.5, label = 'status unknown (4)'), nudge_x = 1.5, size = 7) +
  geom_point(aes(2, 0.5), size = 2.5, alpha = .7) +
  geom_point(aes(2, 1), size = 2.5, alpha = .7) +
  geom_point(aes(2, 1.5), size = 2.5, alpha = .7) +
  geom_point(aes(2, 2), size = 2.5, alpha = .7) +
  geom_text(aes(.5, 2, label = 'healthy'), nudge_x = 0, size = 7) +
  geom_text(aes(.5, 1.5, label = 'ill'), nudge_x = 0.2, size = 7) +
  geom_text(aes(.5, 1, label = 'dead'), nudge_x = 0.1, size = 7) +
  xlim(0, 4.5) +
  ylim(0.5, 3) +
  annotate('text', x = .5, y = 2.6, label = 'States', size = 8) +
  annotate('text', x = 2.7, y = 2.6, label = 'Observations', size = 8) +

  geom_segment(aes(x = 1, y = 1, xend = 2, yend = 2), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +

  geom_segment(aes(x = 1, y = 1.5, xend = 2, yend = 1), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 1.5, xend = 2, yend = 2), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 1.5, xend = 2, yend = .5), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +

  geom_segment(aes(x = 1, y = 2, xend = 2, yend = .5), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 2, xend = 2, yend = 1.5), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 2, xend = 2, yend = 2), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +

  theme_void()
```

Clearly, this is the same model as in the previous section on titis, Section \@ref(breedingmultievent), in which loosely speaking we replace breeder by healthy and non-breeder by ill.

The vector of initial state probabilities is:

$$\begin{matrix}
& \\
\delta =
    \left ( \vphantom{ \begin{matrix} 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    z_t=H & z_t=I & z_t=D \\[0.3em] \hdashline
\pi^H & 1 - \pi^{H} & 0\\
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \end{matrix} } \right )
    \begin{matrix}
    \end{matrix}
\end{matrix}$$

where $\pi^H$ is the probability that a newly encountered individual is healthy, and $\pi^{I} = 1 - \pi^H$ is the probability that a newly encountered individual is ill.

The transition matrix is:

$$\begin{matrix}
& \\
\Gamma =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    z_t=H & z_t=I & z_t=D \\[0.3em] \hdashline
\phi^H (1-\psi^{HI}) & \phi^H \psi^{HI} & 1 - \phi^H\\
\phi^{I} \psi^{IH} & \phi^{I} (1-\psi^{IH}) & 1 - \phi^{I}\\
0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
    \begin{matrix}
    z_{t-1}=H \\ z_{t-1}=I \\ z_{t-1}=D
    \end{matrix}
\end{matrix}$$

where $\phi^H$ is the survival probability of healthy individuals, $\phi^I$ the survival probability of ill individuals, $\psi^{HI}$ the probability of getting ill (infection rate) and $\psi^{IH}$ the probability of recovering from the disease (recovery rate).

Image you'd like to model the dynamic of an incurable disease, the transition matrix would be modified by having $\psi^{IH} = 0$, and once a bird gets ill, it remains ill $\psi^{II} = 1 - \psi^{IH} = 1$. Therefore we would have:

$$\begin{matrix}
& \\
\Gamma =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    z_t=H & z_t=I & z_t=D \\[0.3em] \hdashline
\phi^H (1-\psi^{HI}) & \phi^H \psi^{HI} & 1 - \phi^H\\
0 & \phi^{I}  & 1 - \phi^{I}\\
0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
    \begin{matrix}
    z_{t-1}=H \\ z_{t-1}=I \\ z_{t-1}=D
    \end{matrix}
\end{matrix}$$

For analysing the house finch data, we allow recovering from the disease. The observation matrix is:

$$\begin{matrix}
& \\
\Omega =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    y_t=0 & y_t=1 & y_t=2 & y_t=3 \\[0.3em] \hdashline
1-p^H & p^H \beta^H & 0 & p^H (1-\beta^H)\\
1-p^I & 0 & p^{I} \beta^{I} & p^{I} (1-\beta^{I})\\
1 & 0 & 0 & 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right )
    \begin{matrix}
    z_{t}=H \\ z_{t}=I \\ z_{t}=D
    \end{matrix}
\end{matrix}$$

where $\beta^H$ is the probability to assign a healthy individual to state H, and $\beta^{I}$ is the probability to assign a sick individual to state I. $p^H$ is the detection probability of healthy individuals, $p^I$ that of sick individuals.

Using the code we developped for the titis example, we get the following results on the finches by running NIMBLE:

```{r echo = FALSE}
load(here::here("dat","disease.RData"))
MCMCsummary(samples2, round = 2)
```

Healthy individuals are correctly assigned ($\beta^H$ is almost 1), while infected individuals are difficult to ascertain ($\beta^I$ is around 0.05). Unexpectedly, ill birds have a better survival than healthy individuals (compare $\phi^I$ and $\phi^H$). Infection rate ($\psi^{HI}$) is 75%, recovery rate is 20% ($\psi^{IH}$).

<!-- ```{r, echo = FALSE} -->
<!-- load(here::here("dat","disease.RData")) -->
<!-- MCMCplot(out) -->
<!-- ``` -->

## Summary

+ The AS model is a HMM that extends the CJS model by allowing the estimation of movements between sites (e.g. geographical locations) or transitions between states (e.g. breeding status). This flexibility allows addressing all sorts of questions in ecology and evolution. 

+ Covariates can be considered, and appropriate priors or link functions need to be used when there are more than 2 sites or 2 alive states. 

+ Model comparison can be achieved with the WAIC and the goodness of fit of the AS model to capture-recapture data can be assessed with classical procedures.

+ Importantly, the HMM framework allows to account for uncertainty when assigning states to individuals. 

+ The models covered in this chapter haven been called multistratum/strata models, multisite models (section \@ref(ASmodel)), multistate models (section \@ref(states)) and multievent models (section \@ref(multievent)). These models are all HMMs.  

## Suggested reading

+ The AS model was introduced in @arnason1972, @arnason1973 and @SchwarzEtAl1993. Very soon clever folks realized that sites could be replaced by states as in @NicholsEtAl1992 and @NicholsEtAl1994. For a review of models with sites and states, see @LebretonEtAl2009. 

+ The geese data were analyzed in @hestbeck1991estimates and @BrownieEtAl1993, and the titis data in @scofield2001titi. The house finches data were analyzed in @FaustinoEtAl2004 and @ConnCooch2009 [see also @cooch2012disease]. Check out @santoro2014host, @MarescotEtAl2018 and @ollivier2023lyme for other examples in disease ecology.

+ Section \@ref(localminima) on local minima was inspired by chapter 10 of @cooch2017intromark.

+ Classical goodness of fit tests are reviewed in @pradel2005gof. See also @pradel2003gof for tests specifically designed for multisite/multistate models. 

+ Models with uncertainty were introduced in @pradel_multievent_2005. @dupuis_bayesian_1995 had a similar idea for the AS model. For a review, see @gimenez_estimating_2012.

<!-- Several papers propose adapted MCMC algo. Also Gelman advice: "Say you have already found several distinct modes of the posterior and you are happy that these are the most important modes, and if the posterior around these modes is reasonably normal. Then you can calculate the hessian at these modes (say, using optim in R with hessian=T) and you can approximate the posterior as a mixture of normals (or t distributions). See p318-319 in Gelman et al. (2003) "Bayesian Data Analysis" for details. Then you can use the normal/t-mixture approximation as the proposal distribution in an independence sampler to obtain samples from the full posterior." -->

<!-- + @evans2017elicit explain and provide Shiny app to elicit prior with Dirichlet.  -->



<!--chapter:end:5-move.Rmd-->

```{r include=FALSE, cache=FALSE}
# packages
library(tidyverse)
theme_set(theme_light(base_size = 14))
library(nimble)
library(MCMCvis)
library(magick)
library(pdftools)
library(wesanderson)
library(RColorBrewer)
library(patchwork)
library(emo)
#library(nimbleEcology)
#library(basicMCMCplots)

# R options
options(width = 60)

# chunk options
knitr::opts_chunk$set(
  comment = "##",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE
  )
```
# (PART) Case studies {-}

# Introduction {-}

This third part `Case studies` provides real-world case studies from the scientific literature that you can reproduce using material covered in previous chapters. These problems can either i) be used to cement and deepen your understanding of methods and models, ii) be adapted for your own purpose, or iii) serve as teaching projects. For each case study, I recall the ecological question, build the model step by step and conclude with a discussion of the results. I provide only the code snippets needed to illustrate specific points; the complete code and data are available at <https://github.com/oliviergimenez/banana-book/tree/master/appendix>. 

<!--chapter:end:introductionpartthree.Rmd-->

```{r include=FALSE, cache=FALSE}
# packages
library(tidyverse)
theme_set(theme_light(base_size = 14))
library(nimble)
library(MCMCvis)
library(magick)
library(pdftools)
library(wesanderson)
library(RColorBrewer)
library(patchwork)
library(emo)
#library(nimbleEcology)
#library(basicMCMCplots)

# R options
options(width = 60)

# chunk options
knitr::opts_chunk$set(
  comment = "##",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE
  )
```
# Dealing with covariates {#covariateschapter}

## Introduction

Capture-recapture models often aim not just to estimate demographic parameters, but also to understand what drives their variation as we have seen in Chapter \@ref(survival). Here, we will cover the selection of covariates from a potentially large set, using an extension of standard MCMC algorithms known as reversible jump MCMC (RJMCMC), and how to handle with uncertainty in key covariates, namely age or sex, when these are not perfectly known for all individuals.

## Covariate selection with Reversible Jump MCMC

### Motivation

In Section \@ref(waic), we used WAIC to figure our which model, among several candidates, was best supported by the data. Each model there represented a different ecological hypothesis. Now when you are in a situation where you have several individual or temporal covariates that might explain variation in some demographic parameters, say survival as in Section \@ref(covariates), things can quickly become a bit more tedious. 
Let's look at a real-world example with the white stork (*Ciconia ciconia*) population in Baden-Württemberg, Germany. From the 1960s to the 1990s, all Western European stork populations were in decline. One leading hypothesis was that these declines were driven by reduced food availability, itself caused by severe droughts in the storks' wintering grounds in the Sahel region [e.g. @kanya90, @grosbois_assessing_2008].

To explore this idea, we'll use rainfall measurements from 10 meteorological stations chosen to represent the storks' wintering area: Diourbel, Gao, Kayes, Kita, Maradi, Mopti, Ouahigouya, Ségou, Tahoua, and Tombouctou. The data we have are the cumulative rainfall amounts (in mm) over June, July, August, and September -- roughly the rainy season in the Sahel: 

```{r echo = FALSE}
# dakar	diourbel (2)	gao (3)	kandi	kayes (5)	kita (6)	koutiala	maradi (8)	mopti (9)	natitingou	ouahigouya (11)	sikasso	ségou (13)	tahoua (14)	tombouctou (15) 
rainfall_raw <- as.matrix(read.table(here::here("dat", "pluies.txt")))
# select Diourbel, Gao, Kayes, Kita, Maradi, Mopti, Ouahigouya, Ségou, Tahoua, and Tombouctou
filter <- c(2,3,5,6,8,9,11,13,14,15)
rainfall_raw <- rainfall_raw[,filter]
mean_rainfall <- apply(rainfall_raw, 2, mean)
sd_rainfall <- apply(rainfall_raw, 2, sd)
rainfall <- (rainfall_raw - matrix(rep(mean_rainfall, 16), ncol = 10, byrow = T)) / matrix(rep(sd_rainfall, 16), ncol = 10, byrow = T)
colnames(rainfall_raw) <- c("Diourbel", "Gao", "Kayes", "Kita", "Maradi", "Mopti", "Ouahigouya", "Ségou", "Tahoua", "Tombouctou")
head(rainfall_raw)
```

Our question is: Which combination of these stations best explains variation in survival? If we tried to answer this by testing every possible model, we would have to consider every subset of the 10 stations and compare 1024 models (2^10 combinations). That's far too many for a WAIC-based approach to be practical.

Instead of comparing all possible models one by one, we can use Reversible Jump MCMC (RJMCMC). RJMCMC is an extension of standard Bayesian inference in which the model itself is treated as an additional, discrete parameter. In this framework, the posterior distribution spans both the parameter space (e.g. regression coefficients) and the model space (e.g. which covariates are included). In simple terms, we allow the algorithm to jump between models, switching covariates on or off as it goes. You can think of it as a hiker exploring different trails (models), stopping along each trail to take measurements (parameters) before deciding whether to move onto another path. 

Using RJMCMC, we can estimate the posterior probability that each covariate influences survival, and obtain model-averaged regression coefficients and survival estimates that incorporate both parameter and model uncertainty. 

I won't dive into the mathematical details here but don't worry, you can still follow the analysis without them. Check out Chapter 7 of @king_bayesian_2009 [see also @gimenez2009winbugs] if you're interested in. 

### Model and NIMBLE implementation

For our example, we'll work with data from 321 encounter histories of white storks ringed as chicks between 1956 and 1970. These data were kindly provided by Jean-Dominique Lebreton. We'll fit a Cormack–Jolly–Seber (CJS) model with time-dependent survival and constant detection probability, as described in Section \@ref(cjsderivatives). We model the survival probability `phi` as a linear function of our covariates stored in `x`. To handle model selection inside the RJMCMC, we use a trick: for each covariate, we introduce an indicator variable `ksi` that can take the value 1 (covariate is included in the model) or 0 (covariate is excluded). We then combine the regression coefficients `beta` with these indicators into a single vector `betaksi`. This means that if `ksi[j] = 0`, the effect of covariate `j` is zero, effectively removing it from the model. Here's how it works in the NIMBLE code:
```{r eval = FALSE}
for (t in 1:(T-1)){
  logit(phi[t]) <- intercept + inprod(betaksi[1:10], x[t, 1:10])
  gamma[1,1,t] <- phi[t]      # Pr(alive t -> alive t+1)
  gamma[1,2,t] <- 1 - phi[t]  # Pr(alive t -> dead t+1)
  gamma[2,1,t] <- 0           # Pr(dead t -> alive t+1)
  gamma[2,2,t] <- 1           # Pr(dead t -> dead t+1)
}
```

For the indicators and regression coefficients:
```{r eval = FALSE}
for (j in 1:10){
  betaksi[j] <- beta[j] * ksi[j]
  ksi[j] ~ dbern(psi) # indicator variable associated with betaj
}
psi ~ dbeta(1, 1) # prior on inclusion probability
for (j in 1:10){
  beta[j] ~ dnorm(0, sd = 1.5) # prior slopes
}
intercept ~ dnorm(0, sd = 1.5) # prior intercept
```

The prior on `psi` controls the overall tendency to include covariates in the model. Setting it to `dbeta(1, 1)` makes all inclusion probabilities equally likely, so the data drive the selection. The priors on `beta` and the `intercept` (not consider in the selection) are weakly informative.

As we saw in Section \@ref(change-sampler), NIMBLE allows you to change the default sampler. Here, we're going to do something slightly different and use NIMBLE's `configureRJ()` function to set up RJMCMC for variable selection. The function `configureRJ()` modifies an existing MCMC configuration so that RJMCMC is used to sample certain parameters, allowing covariates to be turned on or off during the run. It uses a univariate normal proposal distribution, and you can adjust the proposal mean and scale. The main arguments are:  
- `targetNodes`: The parameters you want to apply variable selection to (e.g. `beta`);  
- `indicatorNodes`: The indicator variables paired with the target nodes (e.g. `ksi`);  
- `control`: A list for fine-tuning the proposal with `mean` the mean of the proposal distribution (default is 0), `scale` the standard deviation of the proposal (default is 1) and `fixedValue` the value a variable takes when excluded (default is 0). 

Here's how we apply it to our white stork example:
```{r eval = FALSE}
## Build the model and configure default MCMC
RJsurvival <- nimbleModel(code = hmm.phirjmcmcp, 
                          constants = my.constants,
                          data = my.data,
                          inits = initial.values())

Csurvival <- compileNimble(RJsurvival)

RJsurvivalConf <- configureMCMC(RJsurvival)
RJsurvivalConf$addMonitors('ksi')

# Switch to reversible jump sampling for the betas
configureRJ(conf = RJsurvivalConf,
            targetNodes = 'beta',
            indicatorNodes = 'ksi',
            control = list(mean = 0, scale = 2))
```

We then build, compile, and run the RJMCMC:
```{r eval = FALSE}
survivalMCMC <- buildMCMC(RJsurvivalConf)
CsurvivalMCMC <- compileNimble(survivalMCMC, project = RJsurvival)
samples <- runMCMC(mcmc = CsurvivalMCMC, 
                   niter = n.iter,
                   nburnin = n.burnin,
                   nchains = n.chains)
```

When we run this MCMC, `configureRJ()` takes care of proposing moves that either keep a covariate in the model or drop it out by setting its `ksi` value to 0. If a covariate is included (`ksi = 1`), the sampler updates its regression coefficient `beta` using the specified normal proposal distribution. If it's excluded (`ksi = 0`), the coefficient is fixed at zero (our `fixedValue`). Over many iterations, the chain 'jumps' between different combinations of covariates, building up posterior probabilities for each one's inclusion. This means we can later summarise which covariates are most likely to affect survival (via their inclusion probabilities), and model-averaged estimates of survival that incorporate the uncertainty about which covariates belong in the model. This is what we do in `R` in the next section. 

### Results and interpretation

```{r echo = FALSE}
load(here::here("dat","rjmcmc.RData"))
#MCMCsummary(out, round = 2)
```

The RJMCMC run gives us the posterior probabilities of different models where each model corresponds to a specific combination of covariates. To get these probabilities, we first combine the MCMC samples from our two chains:
```{r eval = FALSE}
# Gather two chains
out <- rbind(samples[[1]], samples[[2]])
```

Next, we look at the inclusion indicators `ksi`, which take value 1 if a covariate is in the model and 0 if not. The posterior mean of each `ksi[j]` is simply the estimated probability that covariate j is included:
```{r}
# Number of covariates
K <- 10

# Extract only ksi columns, in order ksi[1], ..., ksi[10]
ksi <- out[, paste0("ksi[", 1:K, "]")]

# Posterior inclusion probabilities for each covariate
inclusion_prob <- colMeans(ksi)
inclusion_prob
```

The posterior inclusion probabilities tell us how likely each covariate is to appear in the 'true' model given the data and priors. Here, `ksi[4]` stands out, with an inclusion probability around 0.96. This corresponds to the the Kita station. 

We can also identify the most probable models visited by the RJMCMC. Each MCMC draw corresponds to a model, which we encode as a binary string (e.g., "0101001001"):
```{r}
# Encode each model draw as a string of 0s and 1s
model_id <- apply(ksi, 1, paste0, collapse = "")

# Empirical posterior model probabilities
post_model_prob <- sort(prop.table(table(model_id)), 
                        decreasing = TRUE)

# Show the top models
head(data.frame(model = names(post_model_prob), 
                prob = as.numeric(post_model_prob)), 10)
```

The posterior model probabilities rank the different combinations of covariates, and in our case, the model containing only the rainfall at Kita is clearly dominant.

In conclusion, a very high inclusion probability for Kita (covariate #4) and a dominant model containing only Kita indicate that this station's rainfall is strongly linked to survival, while others are not.

Now turning to inference, we'd like to get model-averaged parameters. Each covariate's effect is 'on' only when its indicator (`ksi`) is 1. Multiplying `beta` by `ksi` zeros out the effect when that covariate is excluded. Summarising `betaksi` across draws gives the model-averaged effect on the logit scale:
```{r}
# Pull posterior draws
beta  <- out[, paste0("beta[", 1:K, "]")]

# Model-averaged coefficients on the logit scale
betaksi <- beta * ksi

# Summaries: mean, 95% credible intervals, and Pr(effect > 0)
df_betaksi <- data.frame(
  mean  = apply(betaksi, 2, mean),
  low  = apply(betaksi, 2, quantile, probs = 2.5/100),
  high  = apply(betaksi, 2, quantile, probs = 97.5/100),
  P_gt0 = apply(betaksi > 0, 2, mean))

round(df_betaksi, 3)
```

A large `P_gt0` (e.g., > 0.95) suggests strong evidence that the covariate increases survival (on the logit scale).

Now let's get model-averaged survival estimates over time. For each MCMC draw, we build the linear predictor with all covariates using `beta * ksi`, add the intercept, then inverse-logit to get survival `phi`: 
```{r}
invlogit <- function(x) 1 / (1 + exp(-x))

# Table of covariate values
X <- rainfall[1:(16 - 1), 1:K]

# Intercept MCMC draws
intercept <- out[, "intercept"]

# Linear predictor for every time t (rows) 
# and every MCMC draw (columns)
eta <- X %*% t(betaksi) 
eta <- sweep(eta, 2, intercept, "+")  # add intercept per draw

# Back-transform to survival probabilities
phi_draws <- invlogit(eta)

# Summaries by time
df_phi <- data.frame(
  mean  = apply(phi_draws, 1, mean),
  low  = apply(phi_draws, 1, quantile, probs = 2.5/100),
  high  = apply(phi_draws, 1, quantile, probs = 97.5/100))

# Visualize
ggplot(df_phi, aes(x = 1956:1970, y = mean)) +
  geom_ribbon(aes(ymin = low, ymax = high), alpha = 0.2) +
  geom_line(linewidth = 0.9) +
  geom_point() +
  labs(
    x = "Years (interval start)",
    y = "Estimated survival probability",
    title = "Model-averaged survival with 95% credible intervals"
  )
```

Shaded ribbons show 95% credible intervals; the solid line is the posterior mean of survival, which decreases over time, model-averaged over covariate inclusion.

## Uncertainty in age {#ageuncertainty}

### Motivation 

Survival and other demographic parameters often differ between young and older animals, so if we blur age classes we can end up telling the wrong story about population dynamics. In Section \@ref(agecov), we incorporated age as a covariate in capture-recapture models, assuming it was perfectly known. With non-invasive genetics (Figure \@ref(fig:marking)), though, age is not observed: a DNA profile can identify who was there, but not how old they were. If we ignore that uncertainty, survival estimates can be biased. Inspired by what we saw in Section \@ref(multievent), we will see here how HMM capture-recapture models can handle this kind of problem by treating age as a hidden state and separating it from what we actually observe in the field. 

A neat example comes from Apennine brown bears in @Gervasi2017 [see also @gowan2021uncertainty]. Because you cannot age a bear from its DNA, the authors paired genetics with field information to classify detections into two broad age classes, cubs (<1 year) and adults (≥1 year). To do so, they used two criteria. First, classify a newly detected bear as a cub in that year if it was sampled at least once on the same date and site as a known adult female and they shared ≥1 allele at every locus (mother-offspring consistent). That's the lenient criterion (P1). Second, apply a stricter criterion (P2): make the same mother–offspring call, but require two or more such co-sampling occasions with the same female, again on the same date and site each time. 

Why two criteria? Because there's a trade-off. P1 is better at catching real cubs (more sensitive) but risks misclassifying some adults as cubs; P2 is more conservative about calling 'cub', so it reduces false cubs but misses some true ones. 

Instead of pretending these criteria are perfect, the authors model the misclassification explicitly: age is hidden, 'cub/adult by P1/P2' is what we observe, and their model estimates both classification accuracy and age-specific survival at the same time. That way, uncertainty is propagated into the demographic estimates rather than swept under the rug.

Here, I show how to encode that logic in an HMM with NIMBLE: define the hidden age states, write the transition (survival) and detection components, and add a classification step that links hidden age to the observed P1/P2 outcomes. We'll also see how a small subset of known-age individuals (e.g., live-trapped or aged beforehand) anchors the classification step. The payoff is a set of age-specific survival estimates that are robust to imperfect age assignment, which is exactly what we need for sound ecological inference and management.

### Model and NIMBLE implementation

To estimate bear survival, we have at our disposal a 12-year time series of non-invasive genetic sampling data, collected between 2003 and 2014. These data were kindly provided by Vincenzo Gervasi. To build up our model, we first define the states and observations:

- States 
     - alive as cub (C)
     - alive as adult (A)
     - dead (D)

- Observations  
     - not detected (1)
     - detected and classified as cub by both criteria (2)
     - detected and classified as cub by P1 only (3)
     - detected and classified as adult by both criteria (4)

Now we turn to writing our model. 

We start with the vector of initial states. Unknown-age individuals enter as a mixture of cubs and adults:


$$\begin{matrix}
& \\
\delta =
  \left ( \vphantom{ \begin{matrix} 12 \end{matrix} } \right .
          \end{matrix}
          \hspace{-1.2em}
          \begin{matrix}
          z_t=C & z_t=A & z_t=D \\[0.3em] \hdashline
          \pi & 1 - \pi & 0\\
          \end{matrix}
          \hspace{-0.2em}
          \begin{matrix}
          & \\
          \left . \vphantom{ \begin{matrix} 12 \end{matrix} } \right )
\begin{matrix}
\end{matrix}
\end{matrix}$$

where $\pi$ is the probability of being alive as a cub, and $1 - \pi$ is the probability of being alive as an adult. For bears with known age at first detection, we fix the initial state accordingly. In NIMBLE we implement this with an individual-specific $\delta_i$ using `equals()` to pin known ages:
```{r eval = FALSE}
# Initial state
# age[i] == 0: unknown -> use delta: pi, 1 - pi
# age[i] == 1: known cub -> force delta to [1, 0, 0]
# age[i] == 2: known adult -> force delta to [0, 1, 0]
for (i in 1:N){
  # Pr(C)
  delta[1, i] <- equals(age[i], 0) * pi + equals(age[i], 1)  
  # Pr(A)
  delta[2, i] <- equals(age[i], 0) * (1 - pi) + equals(age[i], 2)  
  delta[3, i] <- 0
}
```

We proceed with the transition matrix that contains the survival probabilities. A cub either survives and becomes adult next year ($\phi_C$), or dies; adults either survive in the same class ($\phi_A$) or die: 


$$\begin{matrix}
& \\
\Gamma =
  \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
          \end{matrix}
          \hspace{-1.2em}
          \begin{matrix}
          z_t=C & z_t=A & z_t=D \\[0.3em] \hdashline
          0  & \phi_C & 1 - \phi_C\\
          0 & \phi_A & 1 - \phi_A\\
          0 & 0 & 1
          \end{matrix}
          \hspace{-0.2em}
          \begin{matrix}
          & \\
          \left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t-1}=C \\ z_{t-1}=A \\ z_{t-1}=D
\end{matrix}
\end{matrix}$$
  
Following the paper, adult survival is sex-specific; cub survival is common to both sexes:
```{r eval = FALSE}
# Transition matrix
for (i in 1:N){
  gamma[1,1,i] <- 0
  gamma[1,2,i] <- phiC
  gamma[1,3,i] <- 1 - phiC
  gamma[2,1,i] <- 0
  gamma[2,2,i] <- phiA[sex[i]] # sex-spec adult surv (1=f, 2=m)
  gamma[2,3,i] <- 1 - phiA[sex[i]]
  gamma[3,1,i] <- 0
  gamma[3,2,i] <- 0
  gamma[3,3,i] <- 1
}
```

Last step is about the observations, which arise in two steps: detection then classification. For the detection matrix, we need to introduce intermediate observations, say $y'$ for not detected (1), detected as cub (2) and detected as adult (2): 


$$\begin{matrix}
& \\
\Omega_1 =
  \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
          \end{matrix}
          \hspace{-1.2em}
          \begin{matrix}
          y'_t=1 & y'_t=2 & y'_t=3 \\[0.3em] \hdashline
          1-p_C  & p_C & 0\\
          1-p_A & 0 & 1 - p_A\\
          1 & 0 & 0
          \end{matrix}
          \hspace{-0.2em}
          \begin{matrix}
          & \\
          \left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t}=C \\ z_{t}=A \\ z_{t}=D
\end{matrix}
\end{matrix}$$

where $p_C$ is detection for cubs, and $p_A$ that for adults. Then the classification matrix is: 


$$\begin{matrix}
& \\
\Omega_2 =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    y_t=1 & y_t=2 & y_t=3 & y_t=4 \\[0.3em] \hdashline
1 & 0 & 0 & 0\\
0 & \beta_{C,CC} & \beta_{C,CA} & 1 - \beta_{C,CC} - \beta_{C,CA}\\
0 & \beta_{A,CC} & \beta_{A,CA} & 1 - \beta_{A,CC} - \beta_{A,CA}\\
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right )
    \begin{matrix}
    y'_{t}=1 \\ y'_{t}=2 \\ y'_{t}=3
    \end{matrix}
\end{matrix}$$

where $\beta_{C,CC}$ is the probability that, being a cub, and individual is classified as cub with both criteria, $\beta_{C,CA}$ is the probability that, being a cub, an individual is classified as cub with P1 and as adult with P2, $\beta_{A,CC}$ is the probability that, being an adult, an individual is classified as cub with both criteria, $\beta_{A,CA}$ is the probability that, being an adult, an individual is classified as cub with P1 and as adult with P2.

The observation matrix is the product of the two detection and classification matrices $\Omega_1 \Omega_2$: 


$$\begin{matrix}
& \\
\Omega =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    y_t=1 & y_t=2 & y_t=3 & y_t=4 \\[0.3em] \hdashline
1-p_C & p_C \beta_{C,CC} & p_C \beta_{C,CA} & p_C (1 - \beta_{C,CC} - \beta_{C,CA})\\
1-p_A & p_A \beta_{A,CC} & p_A \beta_{A,CA} & p_A (1 - \beta_{A,CC} - \beta_{A,CA})\\
1 & 0 & 0 & 0\\
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right )
    \begin{matrix}
    z_{t}=1 \\ z_{t}=2 \\ z_{t}=3
    \end{matrix}
\end{matrix}$$

In code, we write $\Omega_1 \Omega_2$ directly, as this is faster than doing the matrix multiplication at each MCMC iteration. For simplicity we use a single detection probability $p$ for both ages, but you can let $p$ vary by age, sex, year or sampling method, as in the paper:
```{r eval = FALSE}
# Observation matrix
omega[1,1] <- 1 - p
omega[1,2] <- p * betaCCC
omega[1,3] <- p * betaCCA
omega[1,4] <- p * (1 - betaCCC - betaCCA)

omega[2,1] <- 1 - p
omega[2,2] <- p * betaACC
omega[2,3] <- p * betaACA
omega[2,4] <- p * (1 - betaACC - betaACA)

omega[3,1] <- 1
omega[3,2] <- 0
omega[3,3] <- 0
omega[3,4] <- 0
```

At first detection, the event 'not detected' is impossible by construction (we condition on the first detection). We therefore use an initial observation matrix $\Omega_{\text{init}}$ with $p$ set to 1 (not shown). 

The likelihood and priors are handled as usual. 

### Results and interpretation

Here are the raw results: 
```{r echo = FALSE}
library(MCMCvis)
load(here::here("dat","age.RData"))
MCMCsummary(out, round = 2)
```

which we can arrange as in Table \@ref(tab:ageuncertaintycompare) to compare them with the results obtained by @Gervasi2017:

```{r ageuncertaintycompare, results='asis', message=FALSE, echo=FALSE}
library(MCMCvis)
library(knitr)

# Request 'phiA' unindexed; MCMCsummary will return phiA[1], phiA[2]
params_request <- c("phiC","phiA","p","pi",
                    "betaCCC","betaCCA","betaACC","betaACA")

ours <- MCMCsummary(out, params = params_request)
rn <- rownames(ours)

# Find and order phiA elements safely
phiA_rows <- rn[startsWith(rn, "phiA[")]
phiA_idx  <- as.integer(sub("phiA\\[|\\]", "", phiA_rows))
phiA_rows <- phiA_rows[order(phiA_idx)]

# Final row order used everywhere below
rows <- c("phiC", phiA_rows, "p", "pi", "betaCCC", "betaCCA", "betaACC", "betaACA")

# Formatter: mean (L–U)
fmt <- function(m, l, u) sprintf("%.2f (%.2f–%.2f)", m, l, u)
ours_fmt <- setNames(
  mapply(fmt, ours[rows, "mean"], ours[rows, "2.5%"], ours[rows, "97.5%"]),
  rows
)

# Paper values (Gervasi et al. 2017, Table 3; detection is overall average from text)
paper_fmt <- c(
  "phiC"       = "0.51 (0.22–0.79)",
  "phiA[1]"    = "0.92 (0.87–0.95)",   # adult female
  "phiA[2]"    = "0.85 (0.76–0.91)",   # adult male
  "p"          = "≈0.71 (0.62–0.79)",  # overall average across designs/years
  "pi"         = "0.062 (0.007–0.396)",
  "betaCCC"    = "0.40 (0.15–0.72)",   # C_{c,cc}
  "betaCCA"    = "0.60 (0.28–0.85)",   # C_{c,ca}
  "betaACC"    = "0.067 (0.024–0.174)",# C_{a,cc}
  "betaACA"    = "0.191 (0.110–0.309)" # C_{a,ca}
)

# Pretty labels with math; no special symbols to keep MathJax happy
labels <- c(
  "phiC"       = "$\\phi_C$ (cub survival)",
  "phiA[1]"    = "$\\phi_{A,f}$ (adult female)",
  "phiA[2]"    = "$\\phi_{A,m}$ (adult male)",
  "p"          = "$p$ (detection)",
  "pi"         = "$\\pi$ (cub at first detection)",
  "betaCCC"    = "$C_{c,cc}$ (cub by both given cub)",
  "betaCCA"    = "$C_{c,ca}$ (cub by P1 only given cub)",
  "betaACC"    = "$C_{a,cc}$ (cub by both given adult)",
  "betaACA"    = "$C_{a,ca}$ (cub by P1 only given adult)"
)

tab <- data.frame(
  Parameter = unname(labels[rows]),
  `NIMBLE` = unname(ours_fmt[rows]),
  `Gervasi et al. (2017)` = unname(paper_fmt[rows]),
  check.names = FALSE
)

library(kableExtra)

kableExtra::kable(
  tab,
  align = c("c","c","c"),
  escape = FALSE,
  booktabs = TRUE,
  caption = "Comparison of parameter estimates for the same HMM to account for age uncertainty: our NIMBLE fit vs. Gervasi et al. (2017, Table 3)."#,
#  format = "latex",
#  longtable = TRUE
) %>%
  kableExtra::kable_styling(
    latex_options = c("repeat_header", "striped"), 
    position = "center", 
    full_width = FALSE,
    latex_table_env = "longtable") 
#  kableExtra::footnote(general = "Intervals are 95% credible intervals for NIMBLE and confidence intervals for Gervasi et al.. Detection in #Gervasi et al. varies by design and year; I report their overall average.")
```

\justifying

Intervals in Table \@ref(tab:ageuncertaintycompare) are 95% credible intervals for NIMBLE and confidence intervals for @Gervasi2017. Detection in @Gervasi2017 varies by design and year; I report their overall average.

Our NIMBLE fit reproduces the main biological signals reported for the Apennine brown bear. Survival shows the expected ordering, that cubs << adults, and adult females > adult males -- with estimates that closely match the published analysis. The credible/confidence intervals overlap broadly, indicating good agreement.

Our detection estimate aligns with the study's average detection, even though their analysis lets detection vary by design and year rather than assuming a single constant value.

For age classification (linking the hidden age to P1/P2 outcomes), mapping our parameters to theirs, we found lower adult-as-cub misclassification than the paper (and thus a higher probability that detected adults are correctly called 'adult by both'), which still matches their qualitative take: the stricter criterion (P2) performs very well for adults.

The main divergence is in the initial state mix. Intervals overlap, but the means differ. A likely explanation is model structure: we used a single, constant detection probability, while the published analysis allows detection to vary by sampling design and year -- and detectability does vary meaningfully across methods and years. Collapsing this heterogeneity into one $p$ can nudge the mixture at first detection toward a higher cub fraction to explain patterns that the richer detection model attributes to design or year effects.

In conclusion, we managed to recover the core findings of the published study (age- and sex-specific survival and average detection). Small discrepancies appear mainly in adult misclassification rates and $\pi$. To mirror @Gervasi2017 even more closely, the natural next step is to let $p$ vary by sampling design/year (an information I did not have), as in their best supported model.

## Uncertainty in sex

### Motivation

Many species show sex differences in demographic parameters, so mislabeling sex or discarding uncertain cases can bias the very patterns we want to estimate. In monomorphic birds for example, field sexing relies on behaviour (e.g., copulation posture, courtship displays, relative body size), and those clues vary in reliability; in the Audouin's gull (*Larus audouinii*) study that motivates this section, almost 80% of individuals were never sexed in the field, making 'known-sex only' analyses both wasteful and biased toward higher survival. 

@pradel2008sex [see also @genovart_exploiting_2012] turned this problem into a HMM inference task: treat sex as a hidden state (male/female/dead) and model the sex-assignment process itself. The model developed by Pradel, Genovart and colleagues separates (i) the probability of attempting a sex judgment (with a time trend, because sexing effort increased) from (ii) criterion-specific accuracy for four behavioural clues (copulation, courtship feeding, begging for food, body size). 

<!-- Two practical findings drive their design: (1) even the least reliable clue (body size) adds information and improves precision when its error rate is estimated, and (2) a small anchor set of genetically sexed birds (24 individuals) is enough to break the model’s inherent dual-solution/label-switching symmetry and stabilize sex ratio and sex-specific survival estimates (Table 5). -->

In brief, the message is: when field classifications are uncertain, exploit them rather than filter them out, and use HMM to couple biological states to imperfect observations and propagate classification uncertainty into survival. 

That philosophy mirrors the age-uncertainty Section \@ref(ageuncertainty) we just completed: there, age was hidden and P1/P2 provided noisy age labels; here, sex is hidden and multiple behavioural criteria provide noisy sex labels. 

### Model and NIMBLE implementation

To estimate Audouin's gull survival, we have at our disposal a dataset with 4093 marked birds from a colony at the Ebro Delta (Spain), collected over 10 years. These data were kindly provided by Meritxell Genovart and Roger Pradel. To build up our model, we first define the states and observations:
  
- States  
     - alive as male (M)
     - alive as female (F)
     - dead (D)

- Observations  
     - not seen (1)
     - judged from copulation to be male (2)
     - judged from begging food to be male (3)
     - judged from coutship feeding to be male (4)
     - judged from body size to be male (5)
     - judged from copulation to be female (6)
     - judged from begging food to be female (7)
     - judged from coutship feeding to be female (8)
     - judged from body size to be female (9)
     - not judged (10)

Now we turn to writing our model. 

We start with the vector of initial states. Unknown-sex individuals enter as a mixture of males and females with probabilities $\pi$ and $1-\pi$: 


$$\begin{matrix}
& \\
\delta =
  \left ( \vphantom{ \begin{matrix} 12 \end{matrix} } \right .
          \end{matrix}
          \hspace{-1.2em}
          \begin{matrix}
          z_t=M & z_t=F & z_t=D \\[0.3em] \hdashline
          \pi & 1 - \pi & 0\\
          \end{matrix}
          \hspace{-0.2em}
          \begin{matrix}
          & \\
          \left . \vphantom{ \begin{matrix} 12 \end{matrix} } \right )
\begin{matrix}
\end{matrix}
\end{matrix}$$

We proceed with the transition matrix that contains the survival probabilities. A male either survives next year as a male ($\phi_M$), or dies; the same happens for females (with probability $\phi_F$): 


$$\begin{matrix}
& \\
\Gamma =
  \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
          \end{matrix}
          \hspace{-1.2em}
          \begin{matrix}
          z_t=M & z_t=F & z_t=D \\[0.3em] \hdashline
          \phi_M  & 0 & 1 - \phi_M\\
          0 & \phi_F & 1 - \phi_F\\
          0 & 0 & 1
          \end{matrix}
          \hspace{-0.2em}
          \begin{matrix}
          & \\
          \left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t-1}=M \\ z_{t-1}=F \\ z_{t-1}=D
\end{matrix}
\end{matrix}$$
  
The vector of initial states and the matrix of transition probabilities are written as usual in NIMBLE:
```{r eval = FALSE}
  delta[1] <- pi
  delta[2] <- 1 - pi
  delta[3] <- 0
  
  gamma[1,1] <- phiM            
  gamma[1,2] <- 0               
  gamma[1,3] <- 1 - phiM        
  gamma[2,1] <- 0               
  gamma[2,2] <- phiF            
  gamma[2,3] <- 1 - phiF        
  gamma[3,1] <- 0               
  gamma[3,2] <- 0               
  gamma[3,3] <- 1               
```

Last step is the observation matrix, which we write as follows (its transposed for convenience):


$$\begin{matrix}
& \\
\Omega' =
  \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right .
          \end{matrix}
          \hspace{-1.2em}
          \begin{matrix}
          z_t=M & z_t=F & z_t=D \\[0.3em] \hdashline
          1 - p  & 1 - p & 1\\
          p e (1-m_4) m_1 x_1 & p e (1-m_4) m_1 (1-x_1) & 0\\
          p e (1-m_4) m_2 x_2 & p e (1-m_4) m_2 (1-x_2) & 0\\
          p e (1-m_4) m_3 x_3 & p e (1-m_4) m_3 (1-x_3) & 0\\
          p e m_4 x_4 & p e m_4 (1-x_4) & 0\\
          p e (1-m_4) m_1 (1-x_1) & p e (1-m_4) m_1 x_1 & 0\\
          p e (1-m_4) m_2 (1-x_2) & p e (1-m_4) m_2 x_2 & 0\\
          p e (1-m_4) m_3 (1-x_3) & p e (1-m_4) m_3 x_3 & 0\\
          p e m_4 (1-x_4) & p e m_4 x_4 & 0\\
          p (1-e) & p (1-e) & 0\\
          \end{matrix}
          \hspace{-0.2em}
          \begin{matrix}
          & \\
          \left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12\end{matrix} } \right )
\begin{matrix}
y_{t}=1 \\ y_{t}=2 \\ y_{t}=3 \\ y_{t}=4 \\ y_{t}=5 \\ y_{t}=6 \\ y_{t}=7 \\ y_{t}=8 \\ y_{t}=9 \\ y_{t}=10
\end{matrix}
\end{matrix}$$

This matrix is a bit more complex than what we have encountered before, and needs some explanations. When an individual is encountered (with probability $p$), there is some chance that it will be sexed ($e$) based on its general appearance (body size: probability $m_4$) or its behaviour (probability $1 - m_4$). When behaviour is used, there are three different criteria (copulation, begging for food and courtship feeding), which occur with probabilities $m_1$, $m_2$, and $m_3$, respectively. Finally, each criterion has its own reliability (probabilities $x_1$, $x_2$, $x_3$, $x_4$, where $x_4$ is the reliability of the body-size criterion). 

I admit that this matrix representation can be difficult to grasp at once. It can be easier to split the observation matrix in several steps, like encountering, sexing, body size sexing, sex determination and correctness, then to sketch a decision tree as in Figure 2 of @genovart_exploiting_2012 (see also appendix S1 in that same paper).

In code, this gives: 
```{r eval = FALSE}
omega[1,1] <- 1 - p                                  
omega[1,2] <- p * e * (1 - m[4]) * m[1] * x[1]      
omega[1,3] <- p * e * (1 - m[4]) * m[2] * x[2]      
omega[1,4] <- p * e * (1 - m[4]) * m[3] * x[3]      
omega[1,5] <- p * e * m[4] * x[4]      
omega[1,6] <- p * e * (1 - m[4]) * m[1] * (1 - x[1])      
omega[1,7] <- p * e * (1 - m[4]) * m[2] * (1 - x[2])      
omega[1,8] <- p * e * (1 - m[4]) * m[3] * (1 - x[3])      
omega[1,9] <- p * e * m[4] * (1 - x[4])      
omega[1,10] <- p * (1 - e)      

omega[2,1] <- 1 - p                                  
omega[2,2] <- p * e * (1 - m[4]) * m[1] * (1 - x[1])      
omega[2,3] <- p * e * (1 - m[4]) * m[2] * (1 - x[2])      
omega[2,4] <- p * e * (1 - m[4]) * m[3] * (1 - x[3])      
omega[2,5] <- p * e * m[4] * (1 - x[4])      
omega[2,6] <- p * e * (1 - m[4]) * m[1] * x[1]      
omega[2,7] <- p * e * (1 - m[4]) * m[2] * x[2]     
omega[2,8] <- p * e * (1 - m[4]) * m[3] * x[3]   
omega[2,9] <- p * e * m[4] * x[4]   
omega[2,10] <- p * (1 - e)      

omega[3,1] <- 1                                  
omega[3,2] <- 0     
omega[3,3] <- 0     
omega[3,4] <- 0     
omega[3,5] <- 0     
omega[3,6] <- 0     
omega[3,7] <- 0     
omega[3,8] <- 0     
omega[3,9] <- 0     
omega[3,10] <- 0     
```

At first detection, the observation 'not detected' is impossible by construction (we condition on the first detection). We therefore use an initial observation matrix $\Omega_{\text{init}}$ with $p$ set to 1 (not shown). 

The likelihood and priors are handled as usual. 

<!-- sm=b(1); % b(1) survie male -->
<!-- sf=b(2); % b(2) survie femelle -->
<!-- p=zeros(10,1); -->
<!-- p(1)=b(23); % b(23) capture occasion 1 %% oublie initialement -->
<!-- p(2)=b(3); % b(3) capture occasion 2 -->
<!-- p(3)=b(4); % b(4) capture occasion 3 -->
<!-- p(4)=b(5); % b(5) capture occasion 4 -->
<!-- p(5)=b(6); % b(6) capture occasion 5 -->
<!-- p(6)=b(7); % b(7) capture occasion 6 -->
<!-- p(7)=b(8); % b(8) capture occasion 7 -->
<!-- p(8)=b(9); % b(9) capture occasion 8 -->
<!-- p(9)=b(10); % b(10) capture occasion 9 -->
<!-- p(10)=b(11); % b(11) capture occasion 10 -->
<!-- sr=b(12); % b(12) sex-ratio = pourcentage de males -->
<!-- % sr=0.4+0.2*b(12); % b(12) sex-ratio = pourcentage de males -->
<!-- % sr=0.5; -->
<!-- ja=b(13); % b(13) intercept de la proba qu'un individu soit juge (tendance lineaire en fonction du temps) -->
<!-- jb=b(14); % b(14) pente de la proba qu'un individu soit juge (tendance lineaire en fonction du temps) -->
<!-- m4a=b(15); % b(15) intercept de la proba cdle (au jugement) d'un jugement par body size -->
<!-- m4b=b(16); % b(16) pente de la proba cdle (au jugement) d'un jugement par body size -->
<!-- m1=b(17); % b(17) proba cdle (au jugement autre que par body size) d'un jugement par copulation -->
<!-- % m1 proba cdle (au jugement autre que par body size) d'un jugement par copulation -->
<!-- m2=(1-m1)*b(18); % b(18) proba cdle (au jugement autre que par body size ou copulation) d'un jugement par begging food -->
<!-- % m2 proba cdle (au jugement autre que par body size) d'un jugement par begging food -->
<!-- m3=1-m1-m2; -->
<!-- % m3 proba cdle (au jugement autre que par body size) d'un jugement par courtship feeding -->
<!-- e1=b(19); % b(19) proba (cdtnt au jugement par copulation) d'une erreur -->
<!-- e2=b(20); % b(20) proba (cdtnt au jugement par begging food) d'une erreur -->
<!-- e3=b(21); % b(21) proba (cdtnt au jugement par courtship feeding) d'une erreur -->
<!-- e4=b(22); % b(122) proba (cdtnt au jugement par body size) d'une erreur -->
<!-- % e4=0; %TEMPO 11-10-04 -->

<!-- % probabilites des evenements (lignes) conditionnellement aux etats (colonnes) -->
<!-- % male femelle mort(male) mort(femelle) -->
<!-- % ------------------------------------------------------------------------------------ -->
<!-- % 0-pas vu -->
<!-- % 1-comportement copulatoire male -->
<!-- % 2-role male dans "beging food" -->
<!-- % 3-role male dans "courtship feeding" -->
<!-- % 4-grande taille relative -->
<!-- % 5-comportement copulatoire femelle -->
<!-- % 6-role femelle dans "beging food" -->
<!-- % 7-role femelle dans "courtship feeding" -->
<!-- % 8-petite taille relative -->
<!-- % 9-pas de jugement -->

### Results and interpretation

Here are the raw results: 

```{r echo = FALSE}
library(MCMCvis)
load(here::here("dat","sex.RData"))
MCMCsummary(out, round = 2)
```

which we can arrange in as in Table \@ref(tab:sexuncertainty) to compare them with the results obtained by @pradel2008sex:
```{r sexuncertainty, results='asis', echo=FALSE, message=FALSE, warning=FALSE}
library(MCMCvis)
library(knitr)

# --- Pull our summaries
params_req <- c("pi","phiF","phiM","m","x")   # m = criterion use; x = correctness p_i
ours <- MCMCsummary(out, params = params_req)
rn   <- rownames(ours)

# Locate and order m[i] and x[i]
m_rows <- rn[startsWith(rn, "m[")]
m_rows <- m_rows[order(as.integer(sub("m\\[|\\]", "", m_rows)))]
x_rows <- rn[startsWith(rn, "x[")]
x_rows <- x_rows[order(as.integer(sub("x\\[|\\]", "", x_rows)))]

# Helper: "mean (L–U)"
fmt <- function(m, l, u) sprintf("%.2f (%.2f–%.2f)", m, l, u)

# Our core
ours_fmt <- c(
  "pi"   = fmt(ours["pi","mean"],    ours["pi","2.5%"],    ours["pi","97.5%"]),
  "phiF" = fmt(ours["phiF","mean"],  ours["phiF","2.5%"],  ours["phiF","97.5%"]),
  "phiM" = fmt(ours["phiM","mean"],  ours["phiM","2.5%"],  ours["phiM","97.5%"])
)

# Our m[i] (criterion use)
ours_m_fmt <- setNames(
  mapply(fmt, ours[m_rows,"mean"], ours[m_rows,"2.5%"], ours[m_rows,"97.5%"]),
  m_rows
)

# Our error rates = 1 - x[i]
err_mean <- 1 - ours[x_rows,"mean"]
err_lcl  <- 1 - ours[x_rows,"97.5%"]
err_ucl  <- 1 - ours[x_rows,"2.5%"]
ours_err_fmt <- setNames(mapply(fmt, err_mean, err_lcl, err_ucl), x_rows)

# ---- Pradel et al. (2007), Table 5, Model B (RUN 6) ----
round2 <- function(x) sprintf("%.2f", x)

# Core (means with SEs) — rounded
pr_core_mean <- c(pi = 0.5325, phiF = 0.9122, phiM = 0.8597)
pr_core_se   <- c(pi = 0.0286, phiF = 0.0142, phiM = 0.0141)
pr_core <- c(
  "pi"   = sprintf("%s (SE %s)", round2(pr_core_mean["pi"]),   round2(pr_core_se["pi"])),
  "phiF" = sprintf("%s (SE %s)", round2(pr_core_mean["phiF"]), round2(pr_core_se["phiF"])),
  "phiM" = sprintf("%s (SE %s)", round2(pr_core_mean["phiM"]), round2(pr_core_se["phiM"]))
)

# m1..m3 constants rounded; m4 time-varying note unchanged
pr_m_vals <- c(0.2904, 0.5973, 0.1123)
pr_m <- c(
  "m[1]" = sprintf("%s", round2(pr_m_vals[1])),
  "m[2]" = sprintf("%s", round2(pr_m_vals[2])),
  "m[3]" = sprintf("%s", round2(pr_m_vals[3])),
  "m[4]" = "time-varying"
)

# Error rates (mean with SE) — rounded
pr_err_mean <- c(0.0577, 0.0561, 0.0000, 0.0928)
pr_err_se   <- c(0.0407, 0.0308, 0.1553, 0.0741)
pr_err <- setNames(
  sprintf("%s (SE %s)", round2(pr_err_mean), round2(pr_err_se)),
  paste0("x[", 1:4, "]")
)

# Nice labels
crit_labs <- c("Copulation","Begging","Courtship feeding","Body size")
m_labs <- setNames(paste0("$m_", 1:4, "$ (", crit_labs, ")"), paste0("m[",1:4,"]"))
e_labs <- setNames(paste0("Error (", crit_labs, ")"), paste0("x[",1:4,"]"))
top_labs <- c(
  "pi"   = "$\\mu$ (proportion male)",
  "phiF" = "$\\phi_F$ (female survival)",
  "phiM" = "$\\phi_M$ (male survival)"
)

# ---- Assemble comparison table ----
tab <- data.frame(
  Parameter = c(
    unname(top_labs[c("pi","phiF","phiM")]),
    unname(m_labs[paste0("m[",1:4,"]")]),
    unname(e_labs[paste0("x[",1:4,"]")])
  ),
  `NIMBLE` = c(
    ours_fmt[c("pi","phiF","phiM")],
    unname(ours_m_fmt[paste0("m[",1:4,"]")]),
    unname(ours_err_fmt[paste0("x[",1:4,"]")])
  ),
  `Pradel et al. (2008)` = c(
    pr_core[c("pi","phiF","phiM")],
    pr_m[paste0("m[",1:4,"]")],
    pr_err[paste0("x[",1:4,"]")]
  ),
  check.names = FALSE,
  row.names = NULL
)

library(kableExtra)

# ---- Build caption with explicit m4(t) values ----
a <- -7.3979
b <-  0.6258
T <- 10                       # years reported for p(t) in RUN 6
t <- 1:T
m4_pred <- plogis(a + b * t)  # predicted m4(t)
m4_str  <- paste(sprintf("%.3f", m4_pred), collapse = ", ")

kableExtra::kable(
  tab,
  align = c("l","c","c"),
  escape = FALSE,
  booktabs = TRUE,
  caption = "Comparison of parameter estimates for the same HMM to account for sex uncertainty: our NIMBLE fit vs. Pradel et al. (2008, Table 5, model B no genetically sexed anchors)."#,
#  format = "latex",
#  longtable = TRUE
) %>%
 kableExtra::kable_styling(latex_options = c("repeat_header", "striped"), 
                position = "center", 
                full_width = FALSE)
```

\justifying

Intervals in Table \@ref(tab:sexuncertainty) are 95% credible intervals for NIMBLE and confidence intervals for @pradel2008sex. Our error rates are `1 − x[i]`. Pradel's $m$'s were provided by the main author of the paper himself. Note that `m4` was time-varying; the estimates were for $t=1,\ldots,10$: 0.001, 0.002, 0.004, 0.007, 0.014, 0.026, 0.047, 0.084, 0.146, 0.242.

Our NIMBLE fit recovers the main biological signals reported for the Audouin's gulls analysis. Survival shows the expected ordering -- adult females ≥ adult males -- with broadly overlapping intervals and means that are close to the published model. In our run, the female--male gap is a bit smaller (0.90 vs 0.89), but the direction matches the paper's message (higher female survival).

We used a single, constant detection probability and obtained $p \approx 0.65$, which sits near the middle of the year‐specific values obtained by the authors (not shown in the paper).

The estimated probabilities of which clue is used align closely with the published analysis for the three 'behavioural' criteria: $m_1 \approx 0.29$ (copulation), $m_2 \approx 0.60$ (begging), $m_3 \approx 0.11$ (courtship feeding). The paper lets body size use vary over time; our constant estimate ($m_4 \approx 0.17$) should be read as a pooled average across years—consistent with their finding of a low but increasing use of this criterion.

The main discrepancy lies in the error rates by criterion. The published analysis finds low misclassification (roughly 5–10% for most criteria, with a very imprecise estimate for courtship feeding). Our fit suggests substantially higher error across criteria. That discrepancy is where we expect sensitivity when there are no known‐sex anchors (and some components are simplified). Without anchors, the model can admit dual solutions (swapping sex labels and flipping error probabilities) that fit nearly equally well; small modelling choices or initial values can tip the chain toward one mode, see @pradel2008sex. 

Our estimate of the proportion of males at first encounter ($\mu \approx 0.52$) agrees closely with the published result, reinforcing that the state mix is well constrained by the data even when sex is uncertain.

To conclude, the sex‐uncertainty HMM retrieves the core demographic pattern (female ≥ male survival) and matches the paper on overall detectability and the use of criteria. To mirror the published results more closely, one could add a small anchor set of genetically sexed individuals [an information used in @pradel2008sex but that I did not have].

<!-- ## Covariate selection with reversible jump MCMC -->

<!-- RJMCMC in @gimenez2009fitness on Common blackbirds or @gimenez2009winbugs on White stork. -->

<!-- As an illustration, we use data on the white stork *Ciconia ciconia* population in Baden Wurttemberg (Germany), consisting of 321 capture histories of individuals ringed as chicks between 1956 and 1971. From the 60's to the 90's, all Western European stork populations were declining @bair91. This trend was likely the result of reduced food availability @schau05 caused by severe droughts observed in the wintering ground of storks in the Sahel region. This hypothesis has been examined in several studies (@kanya90 and @barb99).  -->

<!-- Check out <https://r-nimble.org/nimbleExamples/RJMCMC_example.html> and <https://r-nimble.org/variable-selection-in-nimble-using-reversible-jump-mcmc>. -->

<!-- Somewhere explain how to use if-else in model code to consider alternative models, w/ some covariate in/out. Avoids rewriting all models, we see what's changed, and it avoids errors. Example: -->

<!-- ```{r eval = FALSE} -->
<!-- if(covariate){ -->
<!-- logit(survival[t]) <- beta[1] + beta[2] *x[t] -->
<!-- }else{ -->
<!-- logit(survival[t]) <- beta[1] -->
<!-- }#ifelse -->
<!-- ``` -->

<!-- then specify "covariate=TRUE/FALSE". -->

<!-- ## Missing values {#naincov} -->

<!-- Work on missing values by @bonner2006 (see @gimenez2009winbugs) and @langrock2013maximum and @worthington2015. See also @rose2018. -->

<!-- ## Nonlinearities -->

<!-- Splines à la @gimenez_semiparametric_2006, possibly w/ jagam <https://rdrr.io/cran/mgcv/src/R/jagam.r>.  -->

<!-- ## Spatial -->

<!-- 3D Splines as in @Peron2011. (I)CAR as in @saracco2010icar (see  (<https://github.com/Andrew9Lawson/Bayesian-DM-code-examples>, <https://github.com/Andrew9Lawson/Bayesian_DM_Nimble_code/tree/ICAR-and-other-code> and <https://r-nimble.org/html_manual/cha-spatial.html> for NIMBLE implementation). Add RSR @khan2022rsr (see Jags code at <https://gist.github.com/oliviergimenez/0d5519654adef09060581eb49e2128ce>).  -->

<!--chapter:end:6-covariates.Rmd-->

```{r include=FALSE, cache=FALSE}
# packages
library(tidyverse)
theme_set(theme_light(base_size = 14))
library(nimble)
library(MCMCvis)
library(magick)
library(pdftools)
library(wesanderson)
library(RColorBrewer)
library(patchwork)
library(emo)
#library(nimbleEcology)
#library(basicMCMCplots)

# R options
options(width = 60)

# chunk options
knitr::opts_chunk$set(
  comment = "##",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE
  )
```
# Addressing model lack of fit {#lackoffit}

## Introduction

Capture-recapture models rely on assumptions that must hold for inference to be reliable. In Section \@ref(gof), we saw what could go wrong and how to diagnose those issues. In this chapter, we turn to remedies and show how to fix them by building models that explicitly accommodate lack of fit. We focus on three topics: trap-dependence (detection today affects detection tomorrow), memory in the state process (the Markov assumption is too short -- transitions depend on more than the current state), and individual heterogeneity (persistent differences among animals). 

## Accounting for trap-dependence {#trapdep}

### Motivation

Capture-recapture inference can go sideways when detection depends on past capture. If animals become trap‐shy (avoid traps) or trap‐happy (seek them) after being caught, the independence assumption breaks, and survival or detection can be biased if we ignore it. Tests for this trap‐dependence exist, see Section \@ref(gof), and surveys show it's common across taxa -- roughly 70% of reviewed studies reported evidence for it [@pradeltrapdep2012].

The fix is to encode the behavioural response. Following @pradeltrapdep2012, we treat trap‐awareness as a (possibly temporary) state: right after a capture, individuals move to a 'trap‐aware' state with its own detection probability, so that detection at time $t+1$ can differ for animals caught vs. not caught at $t$. This HMM formulation avoids awkward data splitting, and plays nicely with age or covariates. Importantly, in the authors' example, ignoring trap‐dependence underestimated survival, illustrating why modelling trap-dependence matters.

Here, I adopt that logic in NIMBLE: define a trap‐aware state, let detection depend on it, and keep the rest of the HMM machinery unchanged. 

### Model and NIMBLE implementation

For our example, we'll work with data from 519 encounter histories of Cory's shearwaters (*Calonectris diomedea*) marked as adults between 2001 and 2008 at Pantaleu Islet (Balearic Archipelago, Spain). These data were kindly provided by Ana Sanz-Aguilar. If you perform goodness-of-fit tests on this dataset, as in Section \@ref(gof), you will end up with a significant trap-dependence effect (as well as a transience effect). To build up our model and explicitly account for this lack of fit, we first define the states and observations:

- States  
      - A for 'trap-aware', the original state of an individual when it is first released  
      - U for 'trap-unaware', which follows any occasion where it is not captured   
      - D for dead

- Observations  
      - not detected (1)   
      - detected (2)

Now we turn to writing our model. We start with the vector of initial states. Individuals enter as trap-aware with probability 1: 


$$\begin{matrix}
& \\
\delta =
\left ( \vphantom{ \begin{matrix} 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
z_t=A & z_t=U & z_t=D \\[0.3em] \hdashline
1 & 0 & 0\\
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \end{matrix} } \right )
\begin{matrix}
\end{matrix}
\end{matrix}$$

We proceed with the transition matrix: 


$$\begin{matrix}
& \\
\Gamma =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
z_t=A & z_t=U & z_t=D \\[0.3em] \hdashline
\phi p' & \phi (1-p') & 1 - \phi\\
\phi p & \phi (1-p) & 1 - \phi\\
0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t-1}=A \\ z_{t-1}=U \\ z_{t-1}=D
\end{matrix}
\end{matrix}$$

You might have noticed something ususual in that $\Gamma$ contains both the survival and detection probabilities. Why is that? We track three hidden states from the end of session $t$ to $t+1$: $A =$ trap-aware (the bird was just caught at $t$), $U =$ trap-unaware (not caught at $t$), and $D =$ dead. Between sessions, everyone either survives with probability $\phi$ or dies with $1 - \phi$ (which moves them to $D$, an absorbing state). If alive at $t+1$, the awareness flag for the next session is set by whether the bird gets caught at $t+1$: those caught will be $A$ next time, those not caught will be $U$. Because capture probabilities can differ by current awareness, we allow $p'$ for birds that were $A$ at $t$ and $p$ for birds that were $U$ at $t$. If $p'>p$ you have trap-happy behaviour (recently caught birds are easier to catch next time); if $p'<p$, it's trap-shy. This 'survive -> update awareness via capture' factorization is what the transition matrix formalizes.

Following the paper, adult survival is age-specific to account for a transient effect, see Section \@ref(gof):
```{r eval = FALSE}
# Transition matrix
  for (i in 1:N){
    for (t in first[i]:(K-1)){
      phi[i,t] <- beta[age[i,t]] # beta1 = phi1, beta2 = phi2+
      gamma[1,1,i,t] <- phi[i,t] * pprime
      gamma[1,2,i,t] <- phi[i,t] * (1 - pprime)
      gamma[1,3,i,t] <- 1 - phi[i,t]
      gamma[2,1,i,t] <- phi[i,t] * p
      gamma[2,2,i,t] <- phi[i,t] * (1 - p)
      gamma[2,3,i,t] <- 1 - phi[i,t] 
      gamma[3,1,i,t] <- 0
      gamma[3,2,i,t] <- 0 
      gamma[3,3,i,t] <- 1
    }
  }
```

In the code above, age is passed in the data and created as follows:
```{r eval = FALSE}
# Age effect via individual x time cov and nested indexing 
# to distinguish survival over interval after first detection 
# from survival afterwards: 
age <- matrix(NA, nrow = nrow(y), ncol = ncol(y) - 1)
for (i in 1:nrow(age)){
  for (j in 1:ncol(age)){
    if (j == first[i]) age[i,j] <- 1 # age = 1
    if (j > first[i]) age[i,j] <- 2  # age > 1
  }
}
```

Last step is the observation matrix:


$$\begin{matrix}
& \\
\Omega =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
y_t=1 & y_t=2 \\[0.3em] \hdashline
0 & 1 \\
1 & 0 \\
1 & 0 
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t}=A \\ z_{t}=U \\ z_{t}=D
\end{matrix}
\end{matrix}$$

If an animal is trap-aware at $t$, that means that it has just been captured. If it is trap unaware or dead, it has not been captured during this session. In code, we write:
```{r eval = FALSE}
# Observation matrix
  omega[1,1] <- 0
  omega[1,2] <- 1
  omega[2,1] <- 1
  omega[2,2] <- 0
  omega[3,1] <- 1
  omega[3,2] <- 0
```

The likelihood and priors are handled as usual. 

### Results and interpretation

Here are the raw results with trap-dependence:
```{r echo = FALSE}
library(MCMCvis)
load(here::here("dat","calonectris-w-trap-dep.RData"))
MCMCsummary(out, round = 2)
```

The two detection probabilities, depending on whether a bird was previously caught `pprime` or not `p`, differ clearly, providing evidence of trap-happiness. Our survival estimates are very similar to those obtained by @pradeltrapdep2012 who found $\phi_1 = 0.77\; (0.70, 0.82)$ and $\phi_2 = 0.87\; (0.82,0.90)$ (check out their Table 1). Interestingly, when we fit the same model by ignoring trap-dependence, we get the following results: 
```{r echo = FALSE}
library(MCMCvis)
load(here::here("dat","calonectris-wo-trap-dep.RData"))
MCMCsummary(out, round = 2)
```

When compared the our previous estimates, we see that ignoring trap-dependence leads to an underestimation of survival, either $\phi_1$ the transient survival or $\phi_{2}$ the resident survival.

The approach described here can be conveniently extended to several sites or states, see @pradeltrapdep2012.

## Allowing your Markov models to remember {#memorymodel}

### Motivation

How do we make our models remember? So far, the dynamics of our states have been first-order Markov: the state an animal moves to next depends only on the state it occupies now. But if we think of states as sites, transitions are dispersal or migration, and many species show site fidelity or directional return that reflects where they were several steps back.

To relax the first-order assumption, we move to a second-order Markov description, and what happens at $t+1$ depends on the site at $t$ and at $t−1$. This idea, often called a memory model, was introduced in multisite capture-recapture by @hestbeck1991estimates and @BrownieEtAl1993, then formulated cleanly within the HMM framework by @pradel_multievent_2005 and @rouan2009memory.

To illustrate the memory model, we will use the geese data introduced in Chapter \@ref(dispersal). As we saw in Section \@ref(gofas), there is a strong positive association between the site where an animal was last seen and the site where it will next be seen. This suggests that a first-order model is too simple and that transitions at $t+1$ should not only depend on $t$ but also $t-1$. 

### Model and NIMBLE implementation

As a reminder, the two main ingredients for a HMM capturing dispersal between 2 sites are a transition matrix:


$$\begin{matrix}
& \\
\Gamma =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
z_t=A & z_t=B & z_t=D \\[0.3em] \hdashline
\phi^A (1-\psi^{AB}) & \phi^A \psi^{AB} & 1 - \phi^A\\
\phi^B \psi^{BA} & \phi^B (1-\psi^{BA}) & 1 - \phi^B\\
0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t-1}=A \\ z_{t-1}=B \\ z_{t-1}=D
\end{matrix}
\end{matrix}$$

and an observation matrix:


$$\begin{matrix}
& \\
\Omega =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
y_t=1 & y_t=2 & y_t=3 \\[0.3em] \hdashline
1 - p^A & p^A & 0\\
1 - p^B & 0 & p^B\\
1 & 0 & 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t}=A \\ z_{t}=B \\ z_{t}=D
\end{matrix}
\end{matrix}$$

From here, how to come up with a HMM formulation of the memory model? We need to keep track of the sites previously visited, and to do so, the trick is to consider states as being pairs of sites occupied:

- States  
    - AA is for alive in site A at $t$ and alive in site A at $t-1$   
    - AB is for alive in site A at $t$ and alive in site B at $t-1$  
    - BA is for alive in site B at $t$ and alive in site A at $t-1$  
    - BB is for alive in site B at $t$ and alive in site B at $t-1$  
    - D is for dead  

- Observations  
    - 1 not captured  
    - 2 captured at site A  
    - 3 captured at site B  

Now we turn to writing our model. We start with the vector of initial states. Individuals enter the study with probabilities:


$$\begin{matrix}
& \\
\delta =
\left ( \vphantom{ \begin{matrix} 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
z_t=AA & z_t=AB & z_t=BA & z_t=BB &z_t=D \\[0.3em] \hdashline
\pi^{AA} & \pi^{AB} & \pi^{BA} & \pi^{BB} & 0\\
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \end{matrix} } \right )
\begin{matrix}
\end{matrix}
\end{matrix}$$

where $\pi^{ij}$ is the probability of being alive at site $j$ when first captured and site $i$ before, and $\pi^{BB} = 1 - (\pi^{AA} + \pi^{AB} + \pi^{BA})$.

We proceed with the transition matrix that contains the survival and movement probabilities: 


$$\begin{matrix}
& \\
\Gamma =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12\end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
z_t=AA & z_t=AB & z_t=BA & z_t=BB & z_t=D \\[0.3em] \hdashline
\phi^{AAA} & \phi^{AAB} & 0 & 0 & 1 - \phi^{AAA} - \phi^{AAB}\\
0 & 0 & \phi^{ABA} & \phi^{ABB} & 1 - \phi^{ABA} - \phi^{ABB}\\
\phi^{BAA} & \phi^{BAB} & 0 & 0 & 1 - \phi^{BAA} - \phi^{BAB}\\
0 & 0 & \phi^{BBA} & \phi^{BBB} & 1 - \phi^{BBA} - \phi^{BBB}\\
0 & 0 & 0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12\end{matrix} } \right )
\begin{matrix}
z_{t-1}=AA \\ z_{t-1}=AB \\ z_{t-1}=BA \\ z_{t-1}=BB \\ z_{t-1}=D 
\end{matrix}
\end{matrix}$$

where $\phi^{ijk}$ is the probability to be in site $k$ at time $t + 1$ for an individual
present in site $j$ at $t$ and in site $i$ at $t - 1$. 

An alternate parameterization for $\Gamma$ is: 


$$\begin{matrix}
& \\
\Gamma =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12\end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
z_t=AA & z_t=AB & z_t=BA & z_t=BB & z_t=D \\[0.3em] \hdashline
\phi \psi^{AAA} & \phi (1 - \psi^{AAA}) & 0 & 0 & 1 - \phi\\
0 & 0 & \phi (1 - \psi^{ABB}) & \phi \psi^{ABB} & 1 - \phi\\
\phi \psi^{BAA} & \phi (1 - \psi^{BAA}) & 0 & 0 & 1 - \phi\\
0 & 0 & \phi (1-\psi^{BBB}) & \phi \psi^{BBB} & 1 - \phi\\
0 & 0 & 0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12\end{matrix} } \right )
\begin{matrix}
z_{t-1}=AA \\ z_{t-1}=AB \\ z_{t-1}=BA \\ z_{t-1}=BB \\ z_{t-1}=D
\end{matrix}
\end{matrix}$$

in which $\phi$ is the probability of surviving from one occasion to the next, and $\psi_{ijj}$ is the probability an animal stays at the same site $j$ given that it was at site $i$ on the previous occasion.

Last step is the observation matrix, which we write as follows:


$$\begin{matrix}
& \\
\Omega =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12\end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
y_t=1 & y_t=2 & y_t=3 \\[0.3em] \hdashline
1 - p^A & p^A & 0\\
1 - p^B & 0 & p^B\\
1 - p^A & p^A & 0\\
1 - p^B & 0 & p^B\\
1 & 0 & 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12\end{matrix} } \right )
\begin{matrix}
z_t=AA \\ z_t=AB \\ z_t=BA \\ z_t=BB \\ z_t=D
\end{matrix}
\end{matrix}$$

To implement this model in NIMBLE, we're going to use `nimbleEcology`, which makes our life much easier as we do not have to initialize the latent states $z$ -- remember the likelihood is marginalized, see Sections \@ref(marginalization) and \@ref(nimbleecologyintro). Specifically, we use the function `dHMM()` that implements the distribution of a HMM with constant parameters. We also use a Dirichlet prior to ensure that the initial state probabilities and the survival-movement probabilities sum up to 1 and lie between 0 and 1, see Section \@ref(dirichletprior). The code is as follows: 
```{r eval = FALSE}
multisite.marginalized <- nimbleCode({
  
  # -------------------------------------------------
  # Parameters:
  # phi111: survival-mov probability from state 11 to state 11
  # phi112: survival-mov probability from state 11 to state 12
  # phi121: survival-mov probability from state 12 to state 21
  # phi122: survival-mov probability from state 12 to state 22
  # phi211: survival-mov probability from state 21 to state 11
  # phi212: survival-mov probability from state 21 to state 12
  # phi221: survival-mov probability from state 22 to state 21
  # phi222: survival-mov probability from state 22 to state 22
  # det1: detection probability site 1
  # det2: detection probability site 2
  # pi11: init stat prob 11
  # pi12: init stat prob 12
  # pi21: init stat prob 21
  # pi22: init stat prob 22
  # -------------------------------------------------
  # States (S):
  # 1 alive 11
  # 2 alive 12
  # 3 alive 21
  # 4 alive 22
  # 5 dead
  # Observations (O):  
  # 1 not seen
  # 2 seen at site 1 
  # 3 seen at site 2
  # -------------------------------------------------
  
  # priors
  det1 ~ dunif(0, 1)
  det2 ~ dunif(0, 1)
  phi11[1:3] ~ ddirch(alpha[1:3]) # phi111, phi112, 1-sum
  phi12[1:3] ~ ddirch(alpha[1:3]) # phi121, phi122, 1-sum
  phi21[1:3] ~ ddirch(alpha[1:3]) # phi211, phi212, 1-sum
  phi22[1:3] ~ ddirch(alpha[1:3]) # phi221, phi222, 1-sum
  
  # probabilities of state z(t+1) given z(t)
  gamma[1,1] <- phi11[1]
  gamma[1,2] <- phi11[2]
  gamma[1,3] <- 0
  gamma[1,4] <- 0
  gamma[1,5] <- phi11[3]
  gamma[2,1] <- 0
  gamma[2,2] <- 0
  gamma[2,3] <- phi12[1]
  gamma[2,4] <- phi12[2]
  gamma[2,5] <- phi12[3]
  gamma[3,1] <- phi21[1]
  gamma[3,2] <- phi21[2]
  gamma[3,3] <- 0
  gamma[3,4] <- 0
  gamma[3,5] <- phi21[3]
  gamma[4,1] <- 0
  gamma[4,2] <- 0
  gamma[4,3] <- phi22[1]
  gamma[4,4] <- phi22[2]
  gamma[4,5] <- phi22[3]
  gamma[5,1] <- 0
  gamma[5,2] <- 0
  gamma[5,3] <- 0
  gamma[5,4] <- 0
  gamma[5,5] <- 1
  
  # probabilities of y(t) given z(t)
  omega[1,1] <- 1 - det1
  omega[1,2] <- det1
  omega[1,3] <- 0
  omega[2,1] <- 1 - det2
  omega[2,2] <- 0
  omega[2,3] <- det2
  omega[3,1] <- 1 - det1
  omega[3,2] <- det1
  omega[3,3] <- 0
  omega[4,1] <- 1 - det2
  omega[4,2] <- 0
  omega[4,3] <- det2
  omega[5,1] <- 1
  omega[5,2] <- 0
  omega[5,3] <- 0
  
  # initial state probs
  for(i in 1:N) {
    # first state propagation
    init[i, 1:5] <- gamma[ y[i, first[i] ] - 1, 1:5 ] 
  }
  
  # likelihood 
  for (i in 1:N){
    y[i,(first[i]+1):K] ~ dHMM(init = init[i,1:5],# data first[i]+1
                               probObs = omega[1:5,1:3], # obs
                               probTrans = gamma[1:5,1:5], # trans
                               len = K - first[i], # nb of occasions
                               checkRowSums = 0) # do not check 
                                                 # whether elements 
                                                 # in a row sum 
                                                 # to 1
  }
})
```

### Results and interpretation

The raw results are: 
```{r echo = FALSE}
library(MCMCvis)
load(here::here("dat","memory.RData"))
MCMCsummary(out, round = 2)
```

which we can reaarange as in Table \@ref(tab:memoryres) to the results obtained by @pradel_multievent_2005 in his Table 1: 
```{r memoryres, results='asis', echo=FALSE, message=FALSE}
library(dplyr)
library(tibble)
library(knitr)

pradel_avg <- tribble(
  ~Transition, ~Condition,              ~Pradel_avg,
  "MM",        "Equal to t-1",           0.57,
  "MM",        "Not equal to t-1",       0.33,
  "MC",        "Equal to t-1",           0.27,
  "MC",        "Not equal to t-1",       0.09,
  "CM",        "Equal to t-1",           0.21,
  "CM",        "Not equal to t-1",       0.05,
  "CC",        "Equal to t-1",           0.63,
  "CC",        "Not equal to t-1",       0.48
)

# ---  NIMBLE results (means and 95% CrIs) ---
ours <- tribble(
  ~Transition, ~Condition,              ~mean, ~lo,  ~hi,
  "MM",        "Equal to t-1",           0.50, 0.49, 0.52,  # phi11[1]
  "MM",        "Not equal to t-1",       0.36, 0.31, 0.42,  # phi21[1]
  "MC",        "Equal to t-1",           0.33, 0.27, 0.38,  # phi21[2]
  "MC",        "Not equal to t-1",       0.16, 0.15, 0.17,  # phi11[2]
  "CM",        "Equal to t-1",           0.10, 0.09, 0.11,  # phi12[1]
  "CM",        "Not equal to t-1",       0.06, 0.05, 0.07,  # phi22[1]
  "CC",        "Equal to t-1",           0.63, 0.61, 0.64,  # phi22[2]
  "CC",        "Not equal to t-1",       0.57, 0.55, 0.59   # phi12[2]
) |>
  mutate(NIMBLE = sprintf("%.2f (%.2f–%.2f)", mean, lo, hi)) |>
  select(Transition, Condition, NIMBLE)

tab <- pradel_avg |>
  mutate(`Pradel (avg 1985–88)` = sprintf("%.2f", Pradel_avg)) |>
  select(-Pradel_avg) |>
  inner_join(ours, by = c("Transition","Condition")) |>
  arrange(factor(Transition, levels = c("MM","MC","CM","CC")),
          factor(Condition, levels = c("Equal to t-1","Not equal to t-1")))

library(kableExtra)

kableExtra::kable(
  tab,
  align = c("l","l","c","c"),
  escape = FALSE,
  booktabs = TRUE,
  caption = "Second-order (memory) estimates of transition probabilities."#,
#  format = "latex",
#  longtable = TRUE
) %>%
  kableExtra::kable_styling(latex_options = c("repeat_header", "striped"), 
                position = "center", 
                full_width = FALSE)
```

\justifying

In Table \@ref(tab:memoryres), the first column gives the Transition made in $t$ to $t+1$ where M is for mid--Atlantic and C for Chesapeake. The second column gives the Condition that is whether the location at $t+1$ is Equal or Not equal to the location at $t-1$. The @pradel_multievent_2005 time-averaged estimates are given in the third column. Our NIMBLE estimates (mean and 95% credible interval) are given in the fourth column.

In both analyses, memory is real: for each transition, the probability is higher when the destination at $t+1$ matches where the bird was at $t−1$ ('Equal to $t-1$' rows) than when it doesn't ('Not equal to $t-1$' rows). That's site fidelity or directional return. Our fit mirrors Pradel's fit especially well for staying in Chesapeake (CC, equal: 0.63 in both) and still shows a clear memory signal for staying in mid-Atlantic (MM, 0.50 vs 0.57 when equal). Moves also carry memory: MC is more likely when the bird was in C two steps back (0.33 vs 0.16), and CM shows a weaker but similar pattern (0.10 vs 0.06).

Where we differ is in the directional balance. Relative to Pradel's averages, our model leans more toward Chesapeake: we estimate higher MC probabilities (both equal and not equal; e.g., 0.33 vs 0.27 and 0.16 vs 0.09) and lower CM (equal) (0.10 vs 0.21). We also find a higher chance of staying in C (CC, not equal: 0.57 vs 0.48). Several of these differences are well outside our 95% credible intervals (e.g., CM equal 0.09-0.11 vs 0.21, MC not equal 0.15-0.17 vs 0.09). These discrepancies are likely explained by the difference in model structures: ours assumes constant parameters, whereas Pradel’s allows them to vary over time. The big picture remains the same, though: movements are second--order and that memory is asymmetric, being strongest for persistence in Chesapeake and for moves toward it.

## Accomodating individual heterogeneity {#indhet}

### Motivation

I've worked with large carnivores for almost two decades, and they're what pulled me into HMMs -- especially gray wolves. Wolves are social, live in hierarchical packs, and that structure shows up in demography. It also shows up in how we detect them: dominant individuals use trails and roads more often, and that's pretty much where we search for scats for DNA-based identification. The result is individual heterogeneity in detection, with some wolves being more detectable (via DNA) than others.

Shirley Pledger in a series of papers developed so--called mixture models in which individuals are assigned in two or more classes with class-specific survival/detection probabilities. If we ignore that variation, estimates can be biased and lack-of-fit tests light up. In @cubaynes_importance_2010, we used an HMM formulation to capture heterogeneity in detection [see also @pradel2009].

In what follows, I'll show how to build and fit these finite--mixture HMMs using simulated data so we control the truth. This gives a practical template for dealing with heterogeneity whenever behavior or status makes some individuals easier (or more difficult) to find than others.

<!-- ```{r pixwolf, echo=FALSE, fig.cap="Dominance in wolves.", fig.align='center'} -->
<!-- knitr::include_graphics("images/wolfdominance.jpg") -->
<!-- ``` -->

### Model and NIMBLE implementation

To build up our model, we first define the states and observations:

- States
     - alive in class 1 (A1)
     - alive in class 2 (A2)
     - dead (D)

- Observations
     - not detected (1)
     - detected (2)

Now we turn to writing our model. We start with the vector of initial states. Individuals enter as a mixture of A1 and A2: 


$$\begin{matrix}
& \\
\delta =
  \left ( \vphantom{ \begin{matrix} 12 \end{matrix} } \right .
          \end{matrix}
          \hspace{-1.2em}
          \begin{matrix}
          z_t=A1 & z_t=A2 & z_t=D \\[0.3em] \hdashline
          \pi & 1 - \pi & 0\\
          \end{matrix}
          \hspace{-0.2em}
          \begin{matrix}
          & \\
          \left . \vphantom{ \begin{matrix} 12 \end{matrix} } \right )
\begin{matrix}
\end{matrix}
\end{matrix}$$

where $\pi$ is the probability of being alive in A1, and $1 - \pi$ is the probability of being in A2.

We proceed with the transition matrix that contains the survival probabilities:


$$\begin{matrix}
& \\
\Gamma =
  \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
          \end{matrix}
          \hspace{-1.2em}
          \begin{matrix}
          z_t=A1 & z_t=A2 & z_t=D \\[0.3em] \hdashline
          \phi  & 0 & 1 - \phi\\
          0 & \phi & 1 - \phi\\
          0 & 0 & 1
          \end{matrix}
          \hspace{-0.2em}
          \begin{matrix}
          & \\
          \left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t-1}=A1 \\ z_{t-1}=A2 \\ z_{t-1}=D
\end{matrix}
\end{matrix}$$
  
where $\phi$ is the survival probability. In NIMBLE, we write:
```{r eval = FALSE}
# Transition matrix
gamma[1,1] <- phi      # A1(t)->A1(t+1)
gamma[1,2] <- 0        # A1(t)->A2(t+1)
gamma[1,3] <- 1 - phi  # A1(t)->D(t+1)
gamma[2,1] <- 0        # A2(t)->A1(t+1)
gamma[2,2] <- phi      # A2(t)->A2(t+1)
gamma[2,3] <- 1 - phi  # A2(t)->D(t+1)
gamma[3,1] <- 0        # D(t)->A1(t+1)
gamma[3,2] <- 0        # D(t)->A2(t+1)
gamma[3,3] <- 1        # D(t)->D(t+1)
```

Survival could be made heterogeneous; to do so, we'd need to amend the transition matrix as follows:


$$\begin{matrix}
& \\
\Gamma =
  \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
          \end{matrix}
          \hspace{-1.2em}
          \begin{matrix}
          z_t=A1 & z_t=A2 & z_t=D \\[0.3em] \hdashline
          \phi (1-\psi^{12}) & \phi \psi^{12} & 1 - \phi\\
          \phi \psi^{21} & \phi (1-\psi^{21}) & 1 - \phi\\
          0 & 0 & 1
          \end{matrix}
          \hspace{-0.2em}
          \begin{matrix}
          & \\
          \left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t-1}=A1 \\ z_{t-1}=A2 \\ z_{t-1}=D
\end{matrix}
\end{matrix}$$
  
where the $\psi$'s are the probabilities for an individual to change class of heterogeneity, with $\psi^{12}$ from A1 to A2, and $\psi^{21}$ from A2 to A1.

Last step is the observation matrix, which we write as follows:


$$\begin{matrix}
& \\
\Omega =
  \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right .
          \end{matrix}
          \hspace{-1.2em}
          \begin{matrix}
          y_t=1 & y_t=2 \\[0.3em] \hdashline
          1 - p^1 & p^1\\
          1 - p^2 & p^2\\
          1 & 0
          \end{matrix}
          \hspace{-0.2em}
          \begin{matrix}
          & \\
          \left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right )
\begin{matrix}
z_{t}=A1 \\ z_{t}=A2 \\ z_{t}=D
\end{matrix}
\end{matrix}$$
  
where $p^1$ is detection for individuals in A1, and $p^2$ that of individuals in A2. In NIMBLE, this translates into:
```{r eval = FALSE}
# Observation matrix
omega[1,1] <- 1 - p1 # A1(t)->1(t) (non-detected)
omega[1,2] <- p1 # A1(t)->2(t) (detected)
omega[2,1] <- 1 - p2 # A2(t)->1(t)
omega[2,2] <- p2 # A2(t)->2(t)
omega[3,1] <- 1 # D(t)->1(t)
omega[3,2] <- 0 # D(t)->2(t)
```

At first detection, the observation 'not detected' is impossible by construction (we condition on the first detection). We therefore use an initial observation matrix $\Omega_{\text{init}}$ with $p_1 = p_2$ set to 1 (not shown). 

Instead of real data, we will use simulated data, which is useful to identify problems in our analysis as we will illustrate below. We simulate a finite--mixture scenario where individuals differ in detection but share the same survival. Each animal is assigned to one of two latent classes: a small, highly detectable group (class A1; proportion $\pi = 0.2$, $p_1=0.8$) and a larger, less detectable group (class A2; proportion $1-\pi = 0.8$, $p_2=0.3$). Everyone starts captured at the first occasion (this mimics the CJS conditioning on first capture), then the latent alive state $z_{i,t}$ evolves with constant survival $\phi = 0.7$. If an individual $i$ is alive at time $t$, it's observed with its own detection probability $p_i$ (either $p_1$ or $p_2$ depending on class). The result is a matrix of 0/1 encounter histories $y$ with built-in individual heterogeneity in detection, plus bookkeeping objects: `which_mixture` (true class), `detection` (each animal's $p_i$), and `z` (true alive states). We simulate the fate of 400 animals over 10 years. 

```{r}
# Simulate encounter histories w ind het (finite mixture)

set.seed(1234)           # for reproducibility

# Parameters
phi <- 0.7               # apparent survival (same for all)
prop_class1 <- 0.2       # mixture proportion pi: Pr(class 1)
p_class1 <- 0.8          # detection if in class 1 (high)
p_class2 <- 0.3          # detection if in class 2 (low)

nind <- 400              # number of individuals
nyear <- 10              # number of occasions

# Storage
z <- matrix(NA, nind, nyear)    # latent alive state
x <- matrix(NA, nind, nyear)    # observed detections
y <- matrix(NA, nind, nyear)    # final encounter histories (0/1)
first <- rep(1, nind)           # first-capture occasion
detection <- rep(NA, nind)      # each individual's p_i
which_mixture <- rep(NA, nind)  # latent class: 1 or 0 (class 2)

# Assign ind to classes, then give them class-specific detection
for (i in 1:nind) {
  which_mixture[i] <- rbinom(1, 1, prop_class1) # 1 w prob pi else 0
  detection[i] <- if (which_mixture[i] == 1) p_class1 else p_class2
}

# Generate latent states and observations
# Everyone is alive and detected at first capture (CJS conditioning)
for (i in 1:nind) {
  z[i, first[i]] <- 1
  x[i, first[i]] <- 1

  # From the second occasion on:
  for (j in (first[i] + 1):nyear) {
    # Alive state: survive from previous if alive; else remain 0
    z[i, j] <- rbinom(1, 1, phi * z[i, j - 1])

    # Observation: if alive, detect with p_i; if dead, 0
    x[i, j] <- rbinom(1, 1, z[i, j] * detection[i])
  }
}

# Final encounter histories: replace NAs (before first) with 0
y <- x
y[is.na(y)] <- 0
```

The simulated data look like:
```{r}
head(y)
```

Now when I fit the model above to these data, I get the following results:
```{r echo = FALSE}
library(MCMCvis)
load(here::here("dat","individual-heterogeneity-wolf.RData"))
MCMCsummary(mcmc.phipmix, round = 2)
```

These estimates diverge markedly from the values used to simulate the data, see Table \@ref(tab:simpar):
```{r simpar, results='asis', echo=FALSE, message=FALSE}
library(knitr)

# ---- Posterior summaries ----
post <- data.frame(
  param = c("phi","pi","pp1","pp2"),
  mean  = c(0.70, 0.70, 0.45, 0.49),
  lcl   = c(0.67, 0.63, 0.40, 0.43),   # 2.5%
  ucl   = c(0.73, 0.76, 0.49, 0.55)    # 97.5%
)

# ---- True values used in the simulation ----
pi_truth <- 0.20
truth <- c(
  phi = 0.70,   # survival
  pi  = pi_truth,  # mixture proportion (class 1)
  pp1 = 0.80,   # detection in class 1 (high detectability)
  pp2 = 0.30    # detection in class 2 (low detectability)
)

# ---- Build table ----
tab <- merge(post, data.frame(param = names(truth), truth = as.numeric(truth)), by = "param")
tab$`Posterior mean (95% CrI)` <- sprintf("%.2f (%.2f–%.2f)", tab$mean, tab$lcl, tab$ucl)
tab$Bias <- round(tab$mean - tab$truth, 2)
tab$`Abs % error` <- round(abs(tab$mean - tab$truth) / pmax(tab$truth, 1e-8) * 100, 1)

out <- tab[, c("param", "truth", "Posterior mean (95% CrI)")]
names(out) <- c("Parameter", "True value", "Posterior mean (95% credible interval)")

library(kableExtra)

kable(
  out[match(c("phi","pi","pp1","pp2"), out$Parameter), ],
  align = c("l","c","c","r","r"),
  booktabs= TRUE,
  caption = "Comparison of posterior estimates from NIMBLE with the data-generating values for a finite--mixture HMM."
) %>%
  kable_styling(latex_options = c("repeat_header", "striped"), 
                position = "center", 
                full_width = FALSE, 
                latex_table_env = "longtable")
```

\justifying

Why is that? The first issue is that the classes were permuted. In our model, nothing tells NIMBLE that the highly detectable individuals must belong to class A1 and the less detectable ones to class A2. The labeling of the classes is arbitrary. The interpretation only comes afterwards, by inspecting the parameter estimates. Now if we re-calculate $\pi$ as the proportion of individuals in A1 as follows: 
```{r}
samples <- rbind(mcmc.phipmix[[1]], mcmc.phipmix[[2]])
pi <- 1 - samples[,'pi']
mean(pi)
quantile(pi, probs = c(2.5, 97.5)/100)
```

We can get a sorted new Table \@ref(tab:simpar2):

```{r simpar2, results='asis', echo=FALSE, message=FALSE}
library(knitr)

# ---- Posterior summaries ----
post <- data.frame(
  param = c("phi","pi","pp1","pp2"),
  mean  = c(0.70, 0.30, 0.49, 0.45),
  lcl   = c(0.67, 0.24, 0.43, 0.40),   # 2.5%
  ucl   = c(0.73, 0.37, 0.55, 0.49)    # 97.5%
)

# ---- True values used in the simulation ----
pi_truth <- 0.20
truth <- c(
  phi = 0.70,   # survival
  pi  = pi_truth,  # mixture proportion (class 1)
  pp1 = 0.80,   # detection in class 1 (high detectability)
  pp2 = 0.30    # detection in class 2 (low detectability)
)

# ---- Build table ----
tab <- merge(post, data.frame(param = names(truth), truth = as.numeric(truth)), by = "param")
tab$`Posterior mean (95% CrI)` <- sprintf("%.2f (%.2f–%.2f)", tab$mean, tab$lcl, tab$ucl)
tab$Bias <- round(tab$mean - tab$truth, 2)
tab$`Abs % error` <- round(abs(tab$mean - tab$truth) / pmax(tab$truth, 1e-8) * 100, 1)

out <- tab[, c("param", "truth", "Posterior mean (95% CrI)")]
names(out) <- c("Parameter", "True value", "Posterior mean (95% credible interval)")

library(kableExtra)

kable(
  out[match(c("phi","pi","pp1","pp2"), out$Parameter), ],
  align = c("l","c","c","r","r"),
  booktabs = TRUE,
  caption = "Comparison of posterior estimates from NIMBLE with the data-generating values for a finite--mixture HMM."
) %>%
  kable_styling(latex_options = c("repeat_header", "striped"), 
                position = "center", 
                full_width = FALSE, 
                latex_table_env = "longtable")
```

\justifying

Still, the detection estimates are off. There's a deeper issue here. The HMM formulation we used for capturing heterogeneity creates a limitation: individuals are not allowed to switch between classes over time (e.g., from A1 to A2), because the transition matrix does not permit it. In other words, any individual seen > 1 time (it's detected after the first observation occasion) can *never* change class assignments away from their initial value class assignment. Why this formulation fails? The problem is subtle but fundamental: in a HMM, transitions between states are governed by a Markov process. If the transition matrix says an individual in A1 must stay in A1 (or die), then the individual is permanently locked in that class. As a result, once an individual is assigned to a class through its initial latent state (e.g., A1), it can never change class during sampling. Even worse, any individual seen on multiple occasions (say, years 1 and 4) must stay alive during those years, the latent state cannot 'jump' between classes without violating the transition constraints, therefore, the initial class assignment is fixed forever, and the MCMC sampler cannot explore the alternative class, no matter how much data supports it.

I must confess, I got stuck in that trap, and it was only because I used simulations that I could identify the problem. I then asked the NIMBLE team for help, and Daniel Turek came up with the explanation -- thanks, Daniel!

Fortunately, there are several solutions to this problem:

+ Marginalize over the latent states: Instead of sampling the latent states $z$, you can marginalize them out, which avoids the class-switching problem entirely. This is the principle behind the `nimbleEcology` package, see Section \@ref(nimbleecologyintro). 

+ Use a class-level latent variable: Rather than coding classes as HMM states, define a latent class assignment (e.g., `g[i] ~ dcat(pi[1:2])`) for each individual. The HMM then conditions on that fixed class, allowing for proper inference and switching during MCMC.

+ Custom block sampler: Design a custom MCMC sampler that updates the entire latent history of an individual (`z[i, 1:K]`) at once. This allows for class-switching in a consistent way, though it's more advanced and computationally heavier.

Here I will adopt the first solution and use some material we saw in Section \@ref(marginalization). In NIMBLE, we start by writing our own functions for the HMM likelihood, using the backward algorithm:
```{r eval = FALSE}
# Integrate out latent states using custom density (forward algo)
# speed things up by pooling identical histories w pooled lik

# Get rid of individuals for which first==K
# individuals that are not first encountered at last occasion
mask <- which(first!=ncol(y)) 
y <- y[mask, ] # keep only these
first <- first[mask]
# if first == K (first seen at last occasion), 
# no post-capture interval to inform phi/p; 
# removing them simplifies forward recursion and 
# avoids degenerate len=1 cases

# Pool encounter histories
y_weighted <- y %>% 
  as_tibble() %>% 
  group_by_all() %>% # group by entire history (all columns)
  summarise(size = n()) %>% # count how many inds share that history
  relocate(size) %>% # move "size" column to front
  as.matrix()
head(y_weighted)
size <- y_weighted[,1] # nb of inds w/ a particular history
y <- y_weighted[,-1] # pooled data: one row per unique history

# Assemble data and constants
# +1 because custom distribution expects categories 1/2 (not 0/1)
my.data <- list(y = y + 1)
my.constants <- list(N = nrow(y), 
                     K = ncol(y), 
                     first = first,
                     size = size,
                     one = 1)
# "one" is a dummy constant used in a dconstraint

# NIMBLE functions
# Custom HMM *density* for pooled histories via forward algorithm
dwolfHMM <- nimbleFunction(
  run = function(x = double(1), 
                 probInit = double(1), # initial states (delta)
                 probObs = double(2),  # obs (omega)
                 probObse = double(2), # obs used at first occasion
                 probTrans = double(2),# trans (gamma)
                 size = double(0),     # cardinal
                 len = double(0, default = 0), # nb sampling occ
                 log = integer(0, default = 0)) {
    # Initial forward probs:
    # multiply initial state probs by obs prob at first date x[1]
    # (probObs at t=first is 1 due to CJS conditioning; 
    # and handled via 'probObse').
    alpha <- probInit[1:3] * probObse[1:3,x[1]] 
    # * probObs[1:3,x[1]] == 1 due to conditioning on first detection
    for (t in 2:len) {
      # standard forward step: 
      # alpha_t = (alpha_{t-1} * Gamma) .* Omega(:, y_t)
      alpha[1:3] <- (alpha[1:3] %*% probTrans[1:3,1:3]) * 
        probObs[1:3,x[t]]
    }
    # Pooling: multiply the log-likelihood by 'size'
    logL <- size * log(sum(alpha[1:3]))
    returnType(double(0))
    if (log) return(logL)
    return(exp(logL))
  }
)

# Matching *random generator* 
# (required by NIMBLE for custom distributions)
# Generates one synthetic history consistent with the HMM; 
# not used in MCMC, but needed to register the dist.
rwolfHMM <- nimbleFunction(
  run = function(n = integer(),
                 probInit = double(1),
                 probObs = double(2),
                 probObse = double(2),
                 probTrans = double(2),
                 size = double(0),
                 len = double(0, default = 0)) {
    returnType(double(1))
    z <- numeric(len) # latent states
    # all individuals alive at t = 0 (by construction)
    z[1] <- rcat(n = 1, prob = probInit[1:3]) 
    y <- z
    y[1] <- 2 # all inds detected at t = 0 (CJS conditioning)
    for (t in 2:len){
      # state at t given state at t-1
      z[t] <- rcat(n = 1, prob = probTrans[z[t-1],1:3]) 
      # observation at t given state at t
      y[t] <- rcat(n = 1, prob = probObs[z[t],1:2]) 
    }
    return(y)
  })

# Register the custom density/generator in the global environment
assign('dwolfHMM', dwolfHMM, .GlobalEnv)
assign('rwolfHMM', rwolfHMM, .GlobalEnv)
```

Now the NIMBLE code for the model, at last:
```{r eval = FALSE}
# Model code
hmm.phipmix <- nimbleCode({
  
  # -------------------------------------------------
  # Parameters:
  # pi: initial state probability A1   (mixture weight for class 1)
  # phi: survival probability          (shared across classes)
  # pp1: recapture probability A1      (detection for class 1)
  # pp2: recapture probability A2      (detection for class 2)
  # -------------------------------------------------
  # States (S):
  # 1 alive (A1)  -> class 1
  # 2 alive (A2)  -> class 2
  # 3 dead (D)
  # Observations (O):
  # 1 neither seen nor recovered (0)
  # 2 seen alive (1)
  # -------------------------------------------------
  
  # priors
  phi ~ dunif(0, 1) # prior survival
  # to avoid label switching (enforces an ordering)
  one ~ dconstraint(pp1 < pp2) 
  pp1 ~ dunif(0, 1) # prior detection (class 1)
  pp2 ~ dunif(0, 1) # prior detection (class 2)
  pi ~ dunif(0, 1)  # prob init state 1 (mixture prop class 1)
  
  # transition matrix (classes are persistent; 
  # no switching between A1 and A2)
  gamma[1,1] <- phi      # A1(t)->A1(t+1)
  gamma[1,2] <- 0        # A1(t)->A2(t+1)
  gamma[1,3] <- 1 - phi  # A1(t)->D(t+1)
  gamma[2,1] <- 0        # A2(t)->A1(t+1)
  gamma[2,2] <- phi      # A2(t)->A2(t+1)
  gamma[2,3] <- 1 - phi  # A2(t)->D(t+1)
  gamma[3,1] <- 0        # D(t)->A1(t+1)
  gamma[3,2] <- 0        # D(t)->A2(t+1)
  gamma[3,3] <- 1        # D(t)->D(t+1)
  
  # vector of initial state probs (mixture at first capture)
  delta[1] <- pi         # A1(first)
  delta[2] <- 1 - pi     # A2(first)
  delta[3] <- 0          # D(first)
  
  # observation matrix (det differs by class; dead never seen)
  omega[1,1] <- 1 - pp1   # A1(t)->0(t)
  omega[1,2] <- pp1       # A1(t)->1(t)
  omega[2,1] <- 1 - pp2   # A2(t)->0(t)
  omega[2,2] <- pp2       # A2(t)->1(t)
  omega[3,1] <- 1         # D(t)->0(t)
  omega[3,2] <- 0         # D(t)->1(t)
  
  # 'omegae' is used only at first date inside custom density
  # to implement CJS cond (everyone detected at first capture)
  omegae[1,1] <- 0        # A1(t)->0(t)
  omegae[1,2] <- 1        # A1(t)->1(t)
  omegae[2,1] <- 0        # A2(t)->0(t)
  omegae[2,2] <- 1        # A2(t)->1(t)
  omegae[3,1] <- 1        # D(t)->0(t)
  omegae[3,2] <- 0        # D(t)->1(t)
  
  # likelihood
  for(i in 1:N) {
    # One weighted lik contrib per *unique* history,
    # using the forward algorithm implemented in dwolfHMM.
    y[i,first[i]:K] ~ dwolfHMM(probInit = delta[1:3],# initial states
                               probObs = omega[1:3,1:2], # obs
                               probObse=omegae[1:3,1:2],# obs first
                               probTrans = gamma[1:3,1:3], # trans
                               size = size[i], # weight
                               len = K - first[i] + 1) # nb occ
  }
})

# Initial values 
# (cool thing, we do not need inits for latent states anymore!!)
initial.values <- function() list(phi = runif(1,0,1),
                                  pp1 = 0.3,
                                  pp2 = 0.8,
                                  pi = runif(1,0,1))
# 'one' is provided in constants; no init needed
# The pp1<pp2 constraint prevents label switching 
# by fixing the class ordering

# Parameters to be monitored
parameters.to.save <- c("phi", "pp1", "pp2", "pi")

# Run NIMBLE
out <- nimbleMCMC(code = hmm.phipmix, 
                  constants = my.constants,
                  data = my.data,              
                  inits = initial.values,
                  monitors = parameters.to.save,
                  niter = n.iter,
                  nburnin = n.burnin, 
                  nchains = n.chains)
```

### Results and interpretation

The results in Table \@ref(tab:okidh) look fine now: 
```{r okidh, results='asis', echo=FALSE, message=FALSE}
library(knitr)

# Posterior summaries
load(here::here("dat","individual-heterogeneity-wolf.RData"))

post <- data.frame(
    param = c("phi","pi","pp1","pp2"),
    mean  = c(0.72, 0.27, 0.79, 0.27),
    lcl   = c(0.69, 0.10, 0.65, 0.17),
    ucl   = c(0.75, 0.46, 0.93, 0.35)
  )

#samples <- rbind(mcmc.phipmix.marginalized[[1]], mcmc.phipmix.marginalized[[2]])
#pi <- 1 - samples[,'pi']
#mean(pi)
#quantile(pi, probs = c(2/5, 97.5)/100)

# Data-generating values, remapped to the model's ordering constraint (pp1 < pp2)
truth <- c(phi = 0.70, pi = 0.20, pp1 = 0.80, pp2 = 0.30)

# Build table
tab <- merge(post, data.frame(param = names(truth), truth = as.numeric(truth)), by = "param")
tab$`Posterior mean (95% CrI)` <- sprintf("%.2f (%.2f–%.2f)", tab$mean, tab$lcl, tab$ucl)
tab$Bias <- round(tab$mean - tab$truth, 2)
tab$`Abs % error` <- round(100 * abs(tab$mean - tab$truth) / pmax(tab$truth, 1e-8), 1)

out <- tab[, c("param","truth","Posterior mean (95% CrI)")]
names(out) <- c("Parameter","True value","Posterior mean (95% credible interval)")

library(kableExtra)

kable(
  out[match(c("phi","pi","pp1","pp2"), out$Parameter), ],
  align = c("l","c","c","r","r"),
  booktabs = TRUE,
  caption = "Posterior estimates vs. data-generating values for a finite--mixture HMM, when a marginalized likelihood is used."
) %>%
  kable_styling(latex_options = c("repeat_header", "striped"), 
                position = "center", 
                full_width = FALSE, 
                latex_table_env = "longtable")
```

\justifying

In summary, when modeling unobservable individual heterogeneity (e.g., detection classes) in an HMM, avoid encoding class identity as a dynamic state. Instead, treat it as a fixed latent variable, or marginalize it out. Otherwise, the model is unable to explore the full posterior and will yield biased or unreliable estimates.

A question that remains is the number of classes we should use. In other words, why 2 classes and not 3 or 4? One option is to fit models with more classes and select among them [e.g., @cubaynes2012]. Alternatively, you can take a non-parametric route and let the data decide how many classes are needed; this is relatively easy in NIMBLE [see @turek_bayesian_2021]. 

For broader context on individual heterogeneity, see @gimenez2018ih. Finally, remember that these hidden classes were introduced by Pledger and colleagues primarily to correct bias in survival or abundance when heterogeneity is ignored; interpreting the classes biologically after fitting should be done with caution.

<!-- I'm not an expert on the BNP facilities offered in NIMBLE, but I think I can comment: the stick-breaking representation (as you're using), and the CRP distribution, are modelling the same Dirichlet process.  They differ in the MCMC sampling algorithms which are applied to each, automatically, by NIMBLE's MCMC.  Translating your code between these two (mathematically identical) representations is a relatively small and straight-forward exercise.  The relative performance of the different sampling algorithms, as applied to each representation, could differ, would depend on the model and the data, and is generally difficult to predict. -->

<!-- Changing between the stick-breaking representation and the CRP representation, the categorical distribution would persist in your model.  And Perry's comments are correct, that (in particular for a large number of categories, e.g. large values of H or HH in your code) the categorical sampler (which is applied to the categorical distribution) would become arbitrarily inefficient, in that it evaluates the posterior density for every category value (H or HH times), then samples directly from that posterior distribution.  And that you could hopefully reduce this inefficiency by writing a customized sampling strategy (a custom-written MCMC sampler), to update your categorical distributions, in a more efficient (less wasteful) manner. -->

<!-- ## Temporary emigration -->

<!-- Multistate treatment as in @schaub2004te. See example in @bancila2018te. -->

<!-- Transition matrix: -->

<!-- $$\begin{matrix} -->
<!-- & \\ -->
<!-- \mathbf{\Gamma} = -->
<!--   \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right . -->
<!--           \end{matrix} -->
<!--           \hspace{-1.2em} -->
<!--           \begin{matrix} -->
<!--           z_t=\text{in} & z_t=\text{out} & z_t=\text{D} \\ \hdashline -->
<!--           \phi (1-\psi^{\text{in} \rightarrow \text{out}}) & \phi \psi^{\text{in} \rightarrow \text{out}} & 1 - \phi\\ -->
<!--           \phi \psi^{\text{out} \rightarrow \text{in}} & \phi (1-\psi^{\text{out} \rightarrow \text{in}}) & 1 - \phi\\ -->
<!--           0 & 0 & 1 -->
<!--           \end{matrix} -->
<!--           \hspace{-0.2em} -->
<!--           \begin{matrix} -->
<!--           & \\ -->
<!--           \left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right ) -->
<!-- \begin{matrix} -->
<!-- z_{t-1}=\text{in} \\ z_{t-1}=\text{out} \\ z_{t-1}=\text{D} -->
<!-- \end{matrix} -->
<!-- \end{matrix}$$ -->

<!-- Observation matrix: -->

<!-- $$\begin{matrix} -->
<!-- & \\ -->
<!-- \mathbf{\Omega} = -->
<!--   \left ( \vphantom{ \begin{matrix} 12 \\ 12 \end{matrix} } \right . -->
<!--           \end{matrix} -->
<!--           \hspace{-1.2em} -->
<!--           \begin{matrix} -->
<!--           y_t=1 & y_t=2 \\ \hdashline -->
<!--           1 - p & p\\ -->
<!--           1 & 0\\ -->
<!--           1 & 0 -->
<!--           \end{matrix} -->
<!--           \hspace{-0.2em} -->
<!--           \begin{matrix} -->
<!--           & \\ -->
<!--           \left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right ) -->
<!-- \begin{matrix} -->
<!-- z_{t}=\text{in} \\ z_{t}=\text{out} \\ z_{t}=\text{D} -->
<!-- \end{matrix} -->
<!-- \end{matrix}$$ -->

<!--chapter:end:7-lackoffit.Rmd-->

```{r include=FALSE, cache=FALSE}
# packages
library(tidyverse)
theme_set(theme_light(base_size = 14))
library(nimble)
library(MCMCvis)
library(magick)
library(pdftools)
library(wesanderson)
library(RColorBrewer)
library(patchwork)
library(emo)
#library(nimbleEcology)
#library(basicMCMCplots)

# R options
options(width = 60)

# chunk options
knitr::opts_chunk$set(
  comment = "##",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE
  )
```
# Quantifying life history traits {#tradeoffs}

## Introduction

Capture-recapture models allow the estimation of key demographic parameters such as survival, recruitment, and dispersal. These parameters are central to life history theory, which seeks to explain how organisms allocate limited resources across survival, growth, and reproduction over their lifetime. Life-history traits, such as age at first breeding, breeding frequency, or lifespan, reflect trade-offs shaped by natural selection and environmental constraints.

Capture-recapture data are particularly suited to quantifying such traits in the wild, providing direct estimates that can be compared to theoretical predictions. As introduced in Section \@ref(states), states and transitions between them -- whether disease, developmental, or breeding states -- can be incorporated naturally into the HMM framework.

In this chapter, we focus on three examples: cause- and age-specific mortalities, age-specific breeding probabilities, and stopover duration. Together, they illustrate how capture-recapture HMMs can shed light on life-history strategies.

## Assessing age- and cause-specific mortality

### Motivation

Cause‐ and age-specific mortalities are key life-history traits, shaping population dynamics and informing management or conservation strategies. Yet in the wild, direct assignment of causes of death is challenging as field observations are often incomplete, and carcass recovery is biased towards certain causes of death or habitats. If we ignore this uncertainty, estimates of mortality rates by cause or age class can be biased, and our understanding of population processes compromised.

The fix is to treat cause of death as a latent state. Following @koons2014, we model survival and transitions to cause-specific death states jointly within a HMM capture-recapture framework. To do so, we combine data on recaptures of live and recoveries of dead animals. Individuals can either survive to the next occasion or die from one of several competing causes, with probabilities that may depend on age. 

Here, we use the case study on roe deer (*Capreolus capreolus*) in @koons2014. The authors show that failing to account for uncertain cause assignment underestimated mortality from hunting and overestimated natural mortality, particularly in younger age classes. 

Here, we define cause‐specific death states, let survival and cause‐specific mortality depend on age, and keep the rest of the HMM machinery unchanged in NIMBLE.

### Model and NIMBLE implementation

For our example, we will use data on roe deer from a population in the enclosed forest of the Territoire d'Etude et d'Expérimentation of Trois Fontaines, in eastern France. Here, we focus on 556 known-age females (marked as fawns), of which 217 were recaptured at least once and 41 were deadly injured during handling, victim of car collisions, or recovered and reported by hunters (human-related mortalities). These data were kindly provided by Marlène Gamelon. 

To build up our model, we first define the states and observations:

- States  
      - A for alive   
      - H for an individual that just died from human causes   
      - NH for an individual that just died from a natural (non-human) cause   
      - D for an individual that is already dead   

- Observations   
      - 1 for not seen   
      - 2 for captured for the first time or recaptured   
      - 3 for killed by human activities and reported      

Now we turn to writing our model. We start with the vector of initial states. Individuals enter alive the study with probability 1: 


$$\begin{matrix}
& \\
\delta =
\left ( \vphantom{ \begin{matrix} 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
z_t=A & z_t=H & z_t=NH & z_t=D \\[0.3em] \hdashline
1 & 0 & 0 & 0\\
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \end{matrix} } \right )
\begin{matrix}
\end{matrix}
\end{matrix}$$

We proceed with the transition matrix: 


$$\begin{matrix}
& \\
\Gamma =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
z_t=A & z_t=H & z_t=NH & z_t=D \\[0.3em] \hdashline
1 - \mu_H - \mu_{NH}  & \mu_H & \mu_{NH} & 0\\
0 & 0 & 0 &  1\\
0 & 0 & 0 &  1\\
0 & 0 & 0 &  1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t-1}=A \\ z_{t-1}=H \\ z_{t-1}=NH \\ z_{t-1}=D
\end{matrix}
\end{matrix}$$

where the transition probability from $A$ at $t$ to $H$ at $t + 1$ is the human-related mortality probability $\mu_H$ and the transition probability from $A$ at $t$ to $NH$ at $t + 1$ is the natural mortality probability $\mu_{NH}$. Because an individual could not return to state $A$ once dead, we fix these transitions to 0. 

Following the paper, adult survival is age-specific: $\mu_H$ is different for individuals in their first year of life after birth ([0,1[) vs. age 1 onwards, while $\mu_{NH}$ has two different parameters for ages [0,1[ and [1,2[ then a linear trend with age from age 2 onward. We use a multinomial logit link function to ensure that mortality probabilities are estimated between 0 and 1 and sum up to 1, see Section \@ref(multinomiallogit). In NIMBLE, we code:
```{r eval = FALSE}
# Transition matrix
# Age effects
etaH[i,t] <- (alpha_H_01 * age_lt1[i,t] + alpha_H_ge1 * age_ge1[i,t])

etaNH[i,t] <- (alpha_NH_01 * age_lt1[i,t] + # if age is [0,1[
              alpha_NH_12 * age_1to2[i,t] + # if age is [1,2[
              # linear trend if age >= 2
              (beta0_NH+beta1_NH*age_std_mu2[i,t])*age_ge2[i,t]) 

# Transitions from A
den[i,t] <- 1 + exp(etaH[i,t]) + exp(etaNH[i,t])  # denominator
gamma[i,t,1,1] <- 1 / den[i,t]                    # stay alive
gamma[i,t,1,2] <- exp(etaH[i,t]) / den[i,t]       # muH
gamma[i,t,1,3] <- exp(etaNH[i,t]) / den[i,t]      # muNH
gamma[i,t,1,4] <- 0                               # always 0

# From H, NH, D (always go to D)
gamma[i,t,2,1] <- 0
gamma[i,t,2,2] <- 0
gamma[i,t,2,3] <- 0
gamma[i,t,2,4] <- 1
gamma[i,t,3,1] <- 0
gamma[i,t,3,2] <- 0
gamma[i,t,3,3] <- 0
gamma[i,t,3,4] <- 1
gamma[i,t,4,1] <- 0
gamma[i,t,4,2] <- 0
gamma[i,t,4,3] <- 0
gamma[i,t,4,4] <- 1
```

In the code above, age is passed in the data and created as follows:
```{r eval = FALSE}
# Build an N x K age matrix
age <- matrix(0, nrow = nrow(obs_matrix), ncol = K)
for (i in 1:nrow(obs_matrix)) {
  for (t in first[i]:K) {
    age[i, t] <- t - first[i]   # age 0 at first capture
  }
}
# Define age [0,1[ and age >=1
for (i in 1:nrow(obs_matrix)) {
  for (t in first[i]:K) {
    age_val <- age[i, t]
    if (age_val == 0) { # age < 1
      age_lt1[i, t] <- 1
      age_ge1[i, t] <- 0
    } else {            # age >= 1
      age_lt1[i, t] <- 0  
      age_ge1[i, t] <- 1
    }
  }
}
# Define age >1 and age [1,2[
for (i in 1:nrow(obs_matrix)) {
  for (t in first[i]:K) {
    age_val <- age[i, t]
    age_ge2[i, t] <- as.integer(age_val > 1) # age > 1 or 2 onwards
    age_1to2[i, t] <- as.integer(age_val == 1) # age in [1,2[
  }
}
```

Last step is the observation matrix:


$$\begin{matrix}
& \\
\Omega =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
y_t=1 & y_t=2 & y_t=3 \\[0.3em] \hdashline
1 - p & p & 0 \\
1 - \lambda & 0 & \lambda\\
1 & 0 & 0\\
1 & 0 & 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t}=A \\ z_{t}=H \\ z_{t}=NH \\ z_{t}=D
\end{matrix}
\end{matrix}$$

where a live individual can be detected with probability $p$, or not with probability $1−p$. We include time-dependence and age on $p$, with a different parameter for 1 year-old individuals vs. individuals older than 1 year of age. In NIMBLE, we write:
```{r eval = FALSE}
pA[i,t] <- p_ageLE1[t] * age_lt1[i,t] + p_ageGT1[t] * age_ge1[i,t]
```

An individual that just died from human causes can be recovered and reported with probability $\lambda$, or not with probability $1-\lambda$. Because tag recovery protocols were constant over the course of the study, the authors considered that parameter to be constant over time and across age classes.

### Results and interpretation

```{r echo = FALSE}
library(MCMCvis)
load(here::here("dat","agemortalities.RData"))
#MCMCsummary(out, round = 2)
```

The results are given in Figure \@ref(fig:fig-mortality-age). We see senescence in natural mortality from age 2 onwards, as well as well as a slightly higher human-related mortality in the first year of life after birth. These patterns are similar to those obtained by @koons2014, check out their Figure 4. 

```{r fig-mortality-age, fig.cap="Age‐specific mortality probabilities for human‐related (solid line) and natural (dashed line) causes in female roe deer at Trois‐Fontaines, France, from 1985 to 2013. Shaded polygons represent 95\\% credible intervals.", echo=FALSE}
# ----- Posterior curves vs age -----
library(tidyverse)

# Récupère les échantillons MCMC en matrice (toutes chaînes empilées)
draws <- if (is.list(out) && !is.matrix(out)) do.call(rbind, out) else as.matrix(out)

# Colonnes nécessaires
pars <- c("alpha_H_01","alpha_H_ge1","alpha_NH_01","alpha_NH_12","beta0_NH","beta1_NH")

# Plage d’âges entiers
ages_plot <- 1:max(age)           
ages_plot <- 1:18

# Standardization as in your script
age_std_grid     <- (ages_plot - age_mean) / age_sd
age_std_mu2_grid <- ifelse(ages_plot >= 3, age_std_grid, 0)

# Extract draw vectors
aH01  <- draws[, "alpha_H_01"]
aHge1 <- draws[, "alpha_H_ge1"]
aNH01 <- draws[, "alpha_NH_01"]
aNH12 <- draws[, "alpha_NH_12"]
b0    <- draws[, "beta0_NH"]
b1    <- draws[, "beta1_NH"]

# Prepare empty tibble to store results
df_results <- tibble(
  age = numeric(),
  metric = character(),
  median = numeric(),
  l95 = numeric(),
  u95 = numeric()
)

# Loop over ages
for (k in seq_along(ages_plot)) {
  a <- ages_plot[k]
  
  # eta_H(age): with your age definition (≥1), this is alpha_H_ge1
  etaH <- aHge1
  
  # eta_NH(age): piecewise
  if (a < 1) {
    etaNH <- aNH01
  } else if (a == 2) {
    etaNH <- aNH12
  } else if (a >= 3) {
    etaNH <- b0 + b1 * age_std_mu2_grid[k]
  } else {
    # a == 1 → treat like 1–2 piece
    etaNH <- aNH12
  }
  
  # Probabilities
  den  <- 1 + exp(etaH) + exp(etaNH)
  muA  <- 1 / den
  muH  <- exp(etaH)  / den
  muNH <- exp(etaNH) / den
  
  # Summary function
  qfun <- function(x) c(median = median(x), l95 = quantile(x, 0.025), u95 = quantile(x, 0.975))
  sH   <- qfun(muH)
  sNH  <- qfun(muNH)
  
  # Append rows for this age
  df_results <- bind_rows(
    df_results,
    tibble(
      age = a,
      metric = "Mortality: human",
      median = sH[1], l95 = sH[2], u95 = sH[3]
    ),
    tibble(
      age = a,
      metric = "Mortality: natural",
      median = sNH[1], l95 = sNH[2], u95 = sNH[3]
    )
  )
}

if (params$bw) {
  ggplot(df_results, aes(age, median)) +
    geom_ribbon(aes(ymin = l95, ymax = u95, fill = metric), alpha = 0.2) +
    geom_line(aes(linetype = metric), linewidth = 1) +
    scale_y_continuous(limits = c(0, 1), name = "Estimated mortality probability") +
    scale_x_continuous(breaks = pretty(ages_plot)) +
    labs(x = "Age (years)", linetype = NULL, fill = NULL,
         title = "") +
    scale_fill_manual(values = c("grey70", "grey20")) +
    scale_linetype_manual(values = c("solid", "dotted")) +
    theme_bw()
} else {
  ggplot(df_results, aes(age, median)) +
    geom_ribbon(aes(ymin = l95, ymax = u95, fill = metric), alpha = 0.2) +
    geom_line(aes(linetype = metric)) +
    scale_y_continuous(limits = c(0,1), name = "Estimated mortality probability") +
    scale_x_continuous(breaks = pretty(ages_plot)) +
    labs(x = "Age (years)", linetype = NULL, fill = NULL,
         title = "") +
    theme_bw()
}


```


## Quantifying age-specific breeding

### Motivation

Breeding is not a simple yes/no coin flip. Who breeds this year depends on what happened last year. In long-lived mammals, adult survival is high and fairly stable, but breeding probability can differ according to recent reproductive history and with how reliably we detect mothers and their offspring. If we blur these pieces and treat breeding status as perfectly known we risk biasing both survival and breeding estimates.

@couet2019 give a clear template with female bottlenose dolphins. They show that calf detectability differs by age and a female's breeding probability depends on the outcome of her previous calf. Rather than assuming states are observed without error, they use a HMM to keep true breeding state hidden, model misclassification/detection explicitly, and tie breeding this year to last year's outcome. That way, uncertainty about calf presence and age feeds correctly into demographic estimates.

Here, we follow that logic: we define hidden female states (nonbreeder vs. breeder with calf age classes), let detection vary by calf age, and make breeding probability state-dependent on the previous year's result. 

### Model and NIMBLE implementation

For our example, we'll work with data from a population of bottlenose dolphins (*Tursiops truncatus*) inhabiting the French waters of the Normano-Breton Gulf in the English Channel. We have 106 encounter histories between 2004 and 2016, made of photographs taken from a boat between July and November, which corresponds to the birth peak and the best weather conditions for monitoring. These data were shared by Pauline Couet.

To build up our model, we first define the states and observations:

- States   
      - NB for a non-breeding adult female   
      - Byoy for a breeding adult female with a young of the year   
      - Bc1 for a breeding adult female with a 1‐year‐old calf   
      - Bc3 for a breeding adult female with a 3‐year‐old calf   
      - Bc2 for a breeding adult female with a 2‐year‐old calf   
      - D for a dead female

- Observations   
      - 1 for not seen   
      - 2 for seen alone   
      - 3 for seen with a young of the year   
      - 4 for seen with a calf (1 to 3 years old)   

Now we turn to writing our model. We start with the vector of initial states:


$$
\begin{matrix}
& \\
\boldsymbol{\delta} =
\left ( \vphantom{ \begin{matrix} 1 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
\text{NB} & \text{Byoy} & \text{Bc1} & \text{Bc2} & \text{Bc3} & \text{D} \\[0.3em] \hdashline
\pi_1 & \pi_2 & \pi_3 & \pi_4 & \pi_5 & 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 1 \end{matrix} } \right )
\end{matrix}
$$
where $\displaystyle \pi_5 = 1 - \sum_{j=1}^4\pi_j$.

<!-- To write the transition matrix, we can make a diagram of the life cycle: -->

<!-- ```{r, engine = 'tikz', echo = FALSE} -->
<!-- \usetikzlibrary{arrows.meta, fit, positioning, automata} -->
<!-- \begin{tikzpicture}[ -->
<!--   >=Latex, node distance=24mm, -->
<!--   state/.style = {circle, draw, minimum size=8mm, font=\small, align=center} -->
<!-- ] -->
<!-- % Nodes -->
<!-- \node[state] (NB)   {NB}; -->
<!-- \node[state, right=of NB] (Byoy) {Byoy}; -->
<!-- \node[state, right=of Byoy] (Bc1)  {Bc1}; -->
<!-- \node[state, right=of Bc1] (Bc2)  {Bc2}; -->
<!-- \node[state, right=of Bc2] (Bc3)  {Bc3}; -->
<!-- \node[state, below=12mm of Bc2] (D) {D}; -->

<!-- % Adult survival (loops) -->
<!-- \draw[->] (NB)   edge[loop above] node[above] {$\phi_A$} (); -->
<!-- \draw[->] (Byoy) edge[loop above] node[above] {$\phi_A$} (); -->
<!-- \draw[->] (Bc1)  edge[loop above] node[above] {$\phi_A$} (); -->
<!-- \draw[->] (Bc2)  edge[loop above] node[above] {$\phi_A$} (); -->
<!-- \draw[->] (Bc3)  edge[loop above] node[above] {$\phi_A$} (); -->

<!-- % Death (to D) with labels under the arrows, slightly bent & shortened -->
<!-- \draw[->, shorten >=1.5pt, shorten <=2pt] -->
<!--   (NB)   to[out=-80, in=180] node[pos=0.55, sloped, below] {$1-\phi_A$} (D); -->
<!-- \draw[->, shorten >=1.5pt, shorten <=2pt] -->
<!--   (Byoy) to[out=-70, in=160] node[pos=0.55, sloped, below] {$1-\phi_A$} (D); -->

<!-- % --- tweaked placements --- -->
<!-- \draw[->, shorten >=1.5pt, shorten <=2pt] -->
<!--   (Bc1)  to[out=-55, in=145] node[pos=0.35, sloped, below] {$1-\phi_A$} (D); % label earlier to avoid crossing -->
<!-- \draw[->, shorten >=1.5pt, shorten <=4pt] -->
<!--   (Bc2) to[out=-30, in=110] -->
<!--   node[pos=0.30, sloped, below] {$1-\phi_A$} (D); % -------------------------------- -->

<!-- \draw[->, shorten >=1.5pt, shorten <=2pt] -->
<!--   (Bc3)  to[out=-60, in=60 ] node[pos=0.55, sloped, below] {$1-\phi_A$} (D); -->

<!-- % D absorbing -->
<!-- \draw[->] (D) edge[loop below] node[below] {$1$} (); -->

<!-- % Breeding switch -->
<!-- \draw[->] (NB) -- node[pos=0.5, above] {$\beta_1$} (Byoy); -->

<!-- % YOY survival -->
<!-- \draw[->] (Byoy) -- node[pos=0.5, above] {$\phi_{Y1}$} (Bc1); -->

<!-- % Aging with labels below the arrows -->
<!-- \draw[->] (Bc1) -- node[pos=0.5, below] {$1$} (Bc2); -->
<!-- \draw[->] (Bc2) -- node[pos=0.5, below] {$1$} (Bc3); -->

<!-- % Emancipation Bc3 -> NB (arc above to avoid crossing) -->
<!-- \draw[->] (Bc3) to[out=120, in=60, looseness=1.0] -->
<!--   node[pos=0.5, above] {$1$} (NB); -->
<!-- \end{tikzpicture} -->
<!-- ``` -->

We proceed with the transition matrix given by @couet2019: 


$$
\begin{matrix}
& \\
\Gamma =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
z_t=NB & z_t = Byoy & z_t = Bc1 & z_t = Bc2 & z_t = Bc3 & z_t = D \\[0.3em] \hdashline
\phi_A (1 - \beta_1) & \phi_A \beta_1 & 0 & 0 & 0 & 1 - \phi_A \\
0 & 0 & \phi_A \phi_Y & \phi_A (1-\phi_Y) & 0 & 1-\phi_A \\
\phi_A (1 - \beta_1) & \phi_A \beta_1 & 0 & 0 & 0 & 1-\phi_A \\
\phi_A (1 - \beta_2) & \phi_A \beta_2 & 0 & 0 & 0 & 1-\phi_A \\
\phi_A (1 - \beta_2) & \phi_A \beta_2 & 0 & 0 & 0 & 1-\phi_A \\
0 & 0 & 0 & 0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t-1} = NB \\
z_{t-1} = Byoy \\
z_{t-1} = Bc1 \\
z_{t-1} = Bc2 \\
z_{t-1} = Bc3 \\
z_{t-1} = D
\end{matrix}
\end{matrix}
$$

Rather than attempting to explain the full complexity of this matrix at once, I will follow the authors' suggestion and break it down into four steps, each corresponding to a biological event in the life cycle of female bottlenose dolphins: (1) female survival $\Phi_A$, (2) young survival $\Phi_Y$, (3) young aging $AGING$, and (4) breeding $BREED$, each step being conditional on the previous ones. To do so, we introduce some intermediate states: 

- Intermediate states   
       - Byoy‐D for a breeding adult female that had lost her young of the year   
       - Bc1‐D for a breeding adult female that had lost her 1‐year‐old calf   
       - Bc2‐D for a breeding adult female that had lost her 2‐year‐old calf   
       - Bc3‐leave Breeding adult female that raised her calf to the age of 3   

The four corresponding matrices are given below, starting with the female survival matrix: 


$$
\begin{matrix}
& \\
\Phi_A =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
\text{NB} & \text{Byoy} & \text{Bc1} & \text{Bc2} & \text{Bc3} & \text{D} \\[0.3em] \hdashline
\phi_A & 0      & 0      & 0      & 0      & 1 - \phi_A \\
0      & \phi_A & 0      & 0      & 0      & 1 - \phi_A \\
0      & 0      & \phi_A & 0      & 0      & 1 - \phi_A \\
0      & 0      & 0      & \phi_A & 0      & 1 - \phi_A \\
0      & 0      & 0      & 0      & \phi_A & 1 - \phi_A \\
0      & 0      & 0      & 0      & 0      & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
\text{NB} \\
\text{Byoy} \\
\text{Bc1} \\
\text{Bc2} \\
\text{Bc3} \\
\text{D}
\end{matrix}
\end{matrix}
$$

An adult female survives from $t$ to $t+1$ with probability $\phi_A$ or dies with $1−\phi_A$. We go on with the young survival matrix:


$$
\begin{matrix}
& \\
\Phi_Y =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
\text{NB} & \text{Byoy} & \text{Byoy-D} & \text{Bc1} & \text{Bc1-D} & \text{Bc2} & \text{Bc2-D} & \text{Bc3-leave} & \text{D} \\[0.3em] \hdashline
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & \phi_{Y} & 1 - \phi_{Y} & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & \phi_{Y} & 1 - \phi_{Y} & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & \phi_{Y} & 1 - \phi_{Y} & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
\text{NB} \\
\text{Byoy} \\
\text{Bc1} \\
\text{Bc2} \\
\text{Bc3} \\
\text{D}
\end{matrix}
\end{matrix}
$$


Offspring survive with probability $\phi_Y$ or die with $1-\phi_Y$. If the calf survives, the female remains in the same breeding state. If it dies, she moves to an intermediate 'dead-offspring' state (BYOY-D, Bc1-D, or Bc2-D) so that later steps can condition on that loss. For 3-year-old calves, mortality cannot be distinguished from emancipation (leaving the mother), so we add an intermediate Bc3-leave state and fix survival to 1 there (this parameter is otherwise unidentifiable). As in the paper, I distinguish young‐of‐the‐year and 1‐year‐old calf survival from 2‐year‐old calf survival. We go on with the young aging matrix:


$$
\begin{matrix}
& \\
AGING =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
\text{NB} & \text{Byoy} & \text{Byoy-D} & \text{Bc1} & \text{Bc1-D} & \text{Bc2} & \text{Bc2-D} & \text{Bc3-leave} & \text{D} \\[0.3em] \hdashline
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
\text{NB} \\
\text{Byoy} \\
\text{Byoy-D} \\
\text{Bc1} \\
\text{Bc1-D} \\
\text{Bc2} \\
\text{Bc2-D} \\
\text{Bc3-leave} \\
\text{D}
\end{matrix}
\end{matrix}
$$
The progression of calf age classes between $t$ and $t+1$ is deterministic, all relevant age-advancing transitions are set to 1, and there are no parameters estimated in this matrix. Last, here is the breeding matrix: 


$$
\begin{matrix}
& \\
BREED =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
\text{NB} & \text{Byoy} & \text{Bc1} & \text{Bc2} & \text{Bc3} & \text{D} \\[0.3em] \hdashline
1 - \beta_1 & \beta_1 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 \\
1 - \beta_1 & \beta_1 & 0 & 0 & 0 & 0 \\
1 - \beta_1 & \beta_1 & 0 & 0 & 0 & 0 \\
1 - \beta_2 & \beta_2 & 0 & 0 & 0 & 0 \\
1 - \beta_2 & \beta_2 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
\text{NB} \\
\text{Byoy} \\
\text{Bc1} \\
\text{Bc2} \\
\text{Byoy-D} \\
\text{Bc1-D} \\
\text{Bc2-D} \\
\text{Bc3-leave} \\
\text{D}
\end{matrix}
\end{matrix}
$$

Breeding at $t+1$ occurs with probability $\beta$ (otherwise $1−\beta$). Breeding can depend on the female's state, namely non-breeding females and females that had just lost their young of the year or 1‐year‐old calf ($\beta_1$) vs. females that had lost their 2‐year‐old calf or raised it until the age of 3 ($\beta_2$).

Overall, the transition matrix is the product of all four matrices. In NIMBLE, we could code directly the full matrix, but I take this opportunity to illustrate how to code the splitting in several ecological processes:
```{r eval = FALSE}
# Transition matrix

# PHIA is 6x6
for (i in 1:5) {
  PHIA[i, i] <- adultsurvival
  PHIA[i, 6] <- 1 - adultsurvival
}
PHIA[6, 6] <- 1

# PHIY is 6x9
# Row 1: NB stays NB
PHIY[1, 1] <- 1
# Row 2: Byoy
PHIY[2, 2] <- youngsurvival[1] # YOY survives → becomes Bc1
PHIY[2, 3] <- 1 - youngsurvival[1] # YOY dies → becomes Byoy-D
# Row 3: Bc1
PHIY[3, 4] <- youngsurvival[1] # 1-year-old survives → Bc2
PHIY[3, 5] <- 1 - youngsurvival[1] # dies → Bc1-D
# Row 4: Bc2
PHIY[4, 6] <- youngsurvival[2] # 2-year-old survives → Bc3-L
PHIY[4, 7] <- 1 - youngsurvival[2] # dies → Bc2-D
# Row 5: Bc3 always emancipates
PHIY[5, 8] <- 1
# Row 6: dead female stays dead
PHIY[6, 9] <- 1

# AGING is 9x9
AGING[1, 1] <- 1   # NB → NB
AGING[2, 2] <- 1   # Byoy → Bc1
AGING[3, 5] <- 1   # Byoy-D → Byoy-D
AGING[4, 3] <- 1   # Bc1 → Bc2
AGING[5, 6] <- 1   # Bc1-D → Bc1-D
AGING[6, 4] <- 1   # Bc2 → Bc3
AGING[7, 7] <- 1   # Bc2-D → Bc2-D
AGING[8, 8] <- 1   # Bc3-L → Bc3-L
AGING[9, 9] <- 1   # D → D

# BREED is 9x6
# Row 1: NB → Byoy or NB
BREED[1, 2] <- beta[1]
BREED[1, 1] <- 1 - beta[1]
# Row 2: Bc1 → Bc1
BREED[2, 3] <- 1
# Row 3: Bc2 → Bc2
BREED[3, 4] <- 1
# Row 4: Bc3 → Bc3
BREED[4, 5] <- 1
# Row 5: Byoy-D → Byoy or NB
BREED[5, 2] <- beta[1]
BREED[5, 1] <- 1 - beta[1]
# Row 6: Bc1-D → Byoy or NB
BREED[6, 2] <- beta[1]
BREED[6, 1] <- 1 - beta[1]
# Row 7: Bc2-D → Byoy or NB
BREED[7, 2] <- beta[2]
BREED[7, 1] <- 1 - beta[2]
# Row 8: Bc3-L → Byoy or NB
BREED[8, 2] <- beta[2]
BREED[8, 1] <- 1 - beta[2]
# Row 9: D → D
BREED[9, 6] <- 1

gamma[1:6,1:6] <- PHIA[1:6,1:6] %*% PHIY[1:6,1:9] %*% 
  AGING[1:9,1:9] %*% BREED[1:9,1:6]
```

Last step is the observation matrix that we can also split in two steps, given these intermediate observations:    
- ND: for not detected     
- DNB: for a non-breeding female detected at time $t$    
- DByoy: for a breeding female with a young of the year detected at time $t$    
- DBc: for a breeding female with a 1-year-old calf detected at time $t$    
- DBc2: for a breeding female with a 2-year-old calf detected at time $t$    
- DBc3: for a breeding female with a 3-year-old calf detected at time $t$    

First, the detection step: 


$$
\begin{matrix}
& \\
DETECTION =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
\text{ND} & \text{DNB} & \text{DByoy} & \text{DBc} & \text{DBc2} & \text{DBc3} \\[0.3em] \hdashline
1 - p_1 & p_1 & 0 & 0 & 0 & 0 \\
1 - p_2 & 0 & p_2 & 0 & 0 & 0 \\
1 - p_2 & 0 & 0 & p_2 & 0 & 0 \\
1 - p_1 & 0 & 0 & 0 & p_1 & 0 \\
1 - p_1 & 0 & 0 & 0 & p_1 & 0 \\
1 & 0 & 0 & 0 & 0 & 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
\text{NB} \\
\text{Byoy} \\
\text{Bc1} \\
\text{Bc2} \\
\text{Bc3} \\
\text{D}
\end{matrix}
\end{matrix}
$$

which contains the probability $p$ of detecting the female given her latent state at $t$: $p_2$ is for females with a young of the year or a 1‐year‐old calf and $p_1$ for non-breeding females or those with an older calf. Then the observation matrix: 


$$
\begin{matrix}
& \\
OBS =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
1 & 2 & 3 & 4 \\[0.3em] \hdashline
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 1 - q_1 & q_1 & 0 \\
0 & 1 - q_2 & 0 & q_2 \\
0 & 1 - q_2 & 0 & q_2 \\
0 & 1 - q_2 & 0 & q_2
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \\ 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
\text{ND} \\
\text{DNB} \\
\text{DByoy} \\
\text{DBc} \\
\text{DBc2} \\
\text{DBc3}
\end{matrix}
\end{matrix}
$$

where, conditional on being in a breeding state, there is a probability $q$ that a calf is seen vs. not seen. Calf age is not identifiable from photographs, so observations are seen or not seen, but $q$ may still vary by calf age (here young of the year vs. older). This is coded in NIMBLE as follows:
```{r eval = FALSE}
# Observation matrix

# Detection probabilities
DETECTION[1, 1] <- 1 - p[1]     # NB not detected
DETECTION[1, 2] <- p[1]         # NB detected
DETECTION[2, 1] <- 1 - p[2]
DETECTION[2, 3] <- p[2]        # Byoy detected
DETECTION[3, 1] <- 1 - p[2]
DETECTION[3, 4] <- p[2]         # Bc1 detected
DETECTION[4, 1] <- 1 - p[1]
DETECTION[4, 5] <- p[1]         # Bc2 detected
DETECTION[5, 1] <- 1 - p[1]
DETECTION[5, 6] <- p[1]         # Bc3 detected
DETECTION[6, 1] <- 1           # Dead never detected

# OBS is 6x4
# Not detected → not sighted
OBS[1, 1] <- 1
# Detected NB → alone
OBS[2, 2] <- 1
# Detected Byoy → YOY visible or not
OBS[3, 2] <- 1 - q[1]    # alone
OBS[3, 3] <- q[1]        # with YOY
# Detected Bc1 → calf visible or not
OBS[4, 2] <- 1 - q[2]
OBS[4, 4] <- q[2]
# Detected Bc2
OBS[5, 2] <- 1 - q[2]
OBS[5, 4] <- q[2]
# Detected Bc3
OBS[6, 2] <- 1 - q[2]
OBS[6, 4] <- q[2]

omega[1:6,1:4] <- DETECTION[1:6,1:6] %*% OBS[1:6,1:4]
```

### Results and interpretation

The raw results are:
```{r echo = FALSE}
library(MCMCvis)
load(here::here("dat","agebreeding.RData"))
MCMCsummary(out, round = 2)
```

which we can re-arrange as in Table \@ref(tab:dolphin) to compare them to the estimates obtained by @couet2019: 
```{r dolphin, results='asis', echo=FALSE, message=FALSE}
library(knitr)

# ---- 1) Rough, by-eye digitization from Couet et al. (2019) Fig. 3 ----
# Black line: nonbreeding females OR breeding with 2–3 y calf
rho_nb_older <- c(0.40, 0.50, 0.52, 0.32, 0.55, 0.64, 0.46, 0.49, 0.45, 0.49, 0.44, 0.42)

# Gray line: breeding females with YOY or 1-year calf
rho_yoy_1yr <- c(0.55, 0.60, 0.62, 0.45, 0.60, 0.72, 0.65, 0.58, 0.65, 0.68, 0.58, 0.62)

rho_nb_older_avg <- mean(rho_nb_older)   # ≈ 0.47
rho_yoy_1yr_avg  <- mean(rho_yoy_1yr)    # ≈ 0.61

# ---- 2) Your posterior summaries (as you reported) ----
fmt <- function(m,l,u) sprintf("%.2f (%.2f–%.2f)", m,l,u)
ours <- list(
  adultsurvival        = list(mean=0.96, l=0.94, u=0.98),
  # calf observation (delta) by calf age (YOY vs older)
  q_yoy                = list(mean=0.59, l=0.49, u=0.69),
  q_older              = list(mean=0.80, l=0.70, u=0.89),
  youngsurv_yoy        = list(mean=0.63, l=0.55, u=0.73),
  youngsurv_1yr        = list(mean=0.69, l=0.53, u=0.83),
  # adult female detection (rho) by breeding state class
  p_nb_older           = list(mean=0.63, l=0.58, u=0.69),  # your p[1]
  p_yoy_1yr            = list(mean=0.79, l=0.72, u=0.86),  # your p[2]
  # initial state mix (pi_1:pi_5)
  pi1                  = list(mean=0.49, l=0.37, u=0.60),  # NB
  pi2                  = list(mean=0.26, l=0.17, u=0.37),  # Byoy
  pi3                  = list(mean=0.08, l=0.03, u=0.16),  # Bc1
  pi4                  = list(mean=0.14, l=0.07, u=0.23),  # Bc2
  pi5                  = list(mean=0.03, l=0.00, u=0.10)   # Bc3
)

# ---- 3) Paper side: use time-averaged rho from Fig. 3; delta & survivals from text ----
paper <- list(
  adultsurvival        = "0.97 (0.96-0.98)",
  q_yoy                = "0.58 (0.46-0.68)",  # calf seen (YOY)
  q_older              = "0.79 (0.59-0.90)",  # calf seen (1–3 y)
  youngsurv_yoy        = "0.66 (0.50-0.78)",
  youngsurv_1yr        = "0.45 (0.29-0.61)",
  # adult female detection (averages from Fig. 3)
  p_nb_older           = sprintf("≈%.2f", rho_nb_older_avg),
  p_yoy_1yr            = sprintf("≈%.2f", rho_yoy_1yr_avg),
  # initial mix not reported explicitly
  pi1                  = "NR",
  pi2                  = "NR",
  pi3                  = "NR",
  pi4                  = "NR",
  pi5                  = "NR"
)

labels <- c(
  adultsurvival        = "Adult female survival",
  q_yoy                = "Calf observation, yoy",
  q_older              = "Calf observation, 1-3y",
  youngsurv_yoy        = "Calf survival (yoy)",
  youngsurv_1yr        = "Calf survival (1y)",
  p_nb_older           = "Female detection: NB or calf 2-3y",
  p_yoy_1yr            = "Female detection: yoy or 1-year calf",
  pi1                  = "Initial state NB",
  pi2                  = "Initial state Byoy",
  pi3                  = "Initial state Bc1",
  pi4                  = "Initial state Bc2",
  pi5                  = "Initial state Bc3"
)

order_keys <- names(labels)

tab <- data.frame(
  Parameter = unname(labels[order_keys]),
  `NIMBLE` =
    sapply(ours[order_keys], function(x) fmt(x$mean, x$l, x$u)),
  `Couet` =
    unname(unlist(paper[order_keys])),
  check.names = FALSE,
    row.names = NULL   
)

library(kableExtra)

kable(
  tab,
  align = c("l","c","c"),
  booktabs = TRUE,
  caption = "Age-specific estimates of breeding probabilities. Comparison of our NIMBLE estimates with Couet et al. (2019). 'NR' denotes quantities not reported in the paper. 'NB' is for non-breeding and 'yoy' for young-of-the-year. Adult female detection on the paper side is a rough time-average read by eye from the authors' Figure 3 (2005–2016)."
) %>%
  kable_styling(latex_options = c("repeat_header", "striped"), 
                position = "center", 
                full_width = FALSE, 
                latex_table_env = "longtable")
```

\justifying

Our NIMBLE estimates track the published values closely. Calf survival shows some discrepancies, but credible and confidence intervals overlap, so I would not worry too much. Note also that our model differs slightly: we held adult female detection constant in time, whereas the paper models it as time‐dependent.

Offspring are often missed even when a female is breeding, especially young of the year, which are harder to see than older calves. Offspring detection is well below 1. Adult detection also depends on the female's state: females with a young of the year or 1-year calf are more detectable than non-breeders or those with older calves.

Adult female survival is high. Calf survival ranks young-of-the-year ≥ 1-year. Breeding probability depends on recent history: it's lower after non-breeding or losing a young-of-the-year/1-year calf, and higher after losing a 2-year calf or successfully raising a calf to age 3.

## Estimating stopover duration

### Motivation 

Stopover is not just a logistical pause; it's a stage-specific timing trait in a migratory life cycle. Like age at first reproduction or length of a breeding attempt, the duration of stopover shapes exposure to predators, energy balance, and downstream reproductive timing. Two core questions in migration ecology are: (1) how long individuals stop over, and (2) whether groups differ in their stopover behaviour. Treating stopover as a life-history trait puts those questions center stage.

The catch is that arrivals and departures are hidden and detection is imperfect. If we only look at when individuals are seen, we bias both the entry curve and the distribution of stay lengths. As reviewed in @guerin_advances_2017, a HMM fixes this by keeping states hidden and observations separate: for example, we may use three latent states: not yet arrived, arrived (present), departed; and let two transition probabilities drive dynamics: recruitment (from not yet arrived to arrived) and staying (from arrived to arrived). Detection operates only in state arrived. This so-called time-effect parameterization assumes staying depends on calendar date, not time since arrival, which is often the right first step.

With this setup we can estimate daily entry and staying probabilities, derive expected stopover duration for an arrival date, and test for group differences in behaviour. 

### Model and NIMBLE implementation

We illustrate the model with marbled newts (*Triturus marmoratus*) monitored in 2013 at a permanent pond near Vigneux-de-Bretagne (Loire-Atlantique, western France). Intensive capture-recapture yielded 713 PIT-tagged newts (412 males, 301 females). Captures within the same week were pooled to create 12 equally spaced occasions (11 weekly samples plus a leading 'empty' occasion), so all individuals start in the 'not yet arrived' state. These data were shared by Sandra Guérin.

To build up our model, we first define the states and observations:

- States   
      - NYA for not yet arrived in the pond   
      - ARR for arrived in the pond   
      - DEP departed from the pond   

- Observations   
      - 1 for not captured      
      - 2 for captured      
      
Now we turn to writing our model. We start with the vector of initial states. At the start of the study, everyone is in $NYA$, so the initial state vector is: 


$$
\begin{matrix}
& \\
\boldsymbol{\delta} =
\left ( \vphantom{ \begin{matrix} 1 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
\text{NYA} & \text{ARR} & \text{DEP} \\[0.3em] \hdashline
1 & 0 & 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 1 \end{matrix} } \right )
\end{matrix}
$$

We proceed with the transition matrix, which is governed by two processes: recruitment $r$ is the probability that an individual in $NYA$ enters the pond and staying $s$ is the probability that an individual in $ARR$ remains in the pond. State $DEP$ is absorbing. We have: 


$$\begin{matrix}
& \\
\Gamma =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
z_t=NYA & z_t=ARR & z_t=DEP \\[0.3em] \hdashline
1 - r & r & 0 \\
0 & s & 1 - s \\
0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t-1}=NYA \\ z_{t-1}=ARR \\ z_{t-1}=DEP
\end{matrix}
\end{matrix}$$

We make both parameters $r$ and $s$ sex and time-dependent, which we code in NIMBLE:
```{r eval = FALSE}
for (j in 1:(K-1)){
  # prior probability of arriving in the pond / 1 = female
  logit(r[1,j]) <- beta[1,1] + beta[1,2] * (j-4.5)/2.45 
  # prior probability of arriving in the pond / 2 = male
  logit(r[2,j]) <- beta[2,1] + beta[2,2] * (j-4.5)/2.45 
  # prior retention probability (staying) / 1 = female
  s[1,j] ~ dunif(0, 1) 
  # prior retention probability (staying) / 2 = male
  s[2,j] ~ dunif(0, 1) 
}
for (i in 1:N){
  for (j in 1:(K-1)){
    gamma[1,1,i,j] <- 1 - r[sex[i],j] 
    gamma[1,2,i,j] <- r[sex[i],j] 
    gamma[1,3,i,j] <- 0 
    gamma[2,1,i,j] <- 0
    gamma[2,2,i,j] <- s[sex[i],j]
    gamma[2,3,i,j] <- 1 - s[sex[i],j]
    gamma[3,1,i,j] <- 0 
    gamma[3,2,i,j] <- 0 
    gamma[3,3,i,j] <- 1
  }
}
```

Graphically, this corresponds to:

```{r diagram-stopover, engine = 'tikz', echo = FALSE}
\usetikzlibrary{arrows.meta, fit, positioning, automata}
\begin{tikzpicture}[>=Latex, node distance=28mm, state/.style={circle,draw,minimum size=8mm}]
\node[state] (NYA) {NYA};
\node[state, right=of NYA] (ARR) {ARR};
\node[state, right=of ARR] (DEP) {DEP};

\draw[->] (NYA) edge[bend left] node[above] {$r_{g,j}$} (ARR);
\draw[->] (NYA) edge[loop above] node {$1 - r_{g,j}$} ();
\draw[->] (ARR) edge[bend left] node[above] {$1 - s_{g,j}$} (DEP);
\draw[->] (ARR) edge[loop above] node {$s_{g,j}$} ();
\draw[->] (DEP) edge[loop above] node {$1$} ();
\end{tikzpicture}
```

Last step is the observation matrix:


$$\begin{matrix}
& \\
\Omega =
\left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
y_t=1 & y_t=2 \\[0.3em] \hdashline
1 & 0 \\
1-p & p \\
1 & 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
\begin{matrix}
z_{t}=NYA \\ z_{t}=ARR \\ z_{t}=DEP
\end{matrix}
\end{matrix}$$

where only individuals in state $ARR$ are observable with probability $p$.

The likelihood and priors are handled as usual. 

Using MCMC draws from the posterior distribution of the staying probability $s$, we can calculate the expected stopover duration $\mathbb{E}[D]$ which is the number of occasions present after arrival. With constant $s$, this is given by:
\[
\mathbb{E}[D] \;=\; \frac{1}{\,1 - s\,}.
\]

Why is that? Because the length of stay (counting the arrival occasion) is geometric. After arriving, you are present this week with probability 1 (that's 1 week). You are still present next week with probability $s$. You are still present the week after with probability $s^2$. And so on. So the expected number of occasions present is the sum of those probabilities: 

\[
\mathbb{E}[D] \;=\; 1+s+s^2+\cdots \;=\; \frac{1}{\,1 - s\,}.
\]

When $s$ varies with date, the 'length of stay' after arrival is no longer geometric with a single parameter, it's a non-homogeneous geometric process with week-specific stay probabilities $s_t$. If an individual arrives on date $\tau$, the chance it is still present $k$ occasions later is the product of the stay probabilities along that run:

\[
Pr(D > k \mid \text{arrive at } \tau) \;=\; \prod_{j=0}^{k-1} s_{\tau + j}.
\]

Therefore, the expected number of occasions present (counting the arrival occasion) is the sum of those tail probabilities:

\[
\mathbb{E}[D \mid \text{arrive at } \tau]
\;=\;
\sum_{k=0}^{\infty} \prod_{j=0}^{k-1} s_{\tau + j}.
\]

with the empty product for $k=0$ equal to 1, or in other words the sum of the probabilities of 'surviving' each additional week in $ARR$ under the calendar-date effects.

### Results and interpretation

```{r echo = FALSE}
library(MCMCvis)
load(here::here("dat","stopover.RData"))
```

Our NIMBLE estimates match pretty closely those obtained by @guerin_advances_2017, compare our Figure \@ref(fig:fig-arrival-prob) with the authors' Figure 2.  

```{r echo = FALSE}
samps <- rbind(out[[1]], out[[2]])

library(tidyverse)

# samps: matrix from rbind(out[[1]], out[[2]])
df <- as.data.frame(samps) %>% mutate(iter = row_number())

# Helpers to tidy blocks like r[i,j] and s[i,j]
tidy_block <- function(df, prefix){
  df %>%
    select(iter, matches(paste0("^", prefix, "\\["))) %>%
    pivot_longer(-iter, names_to = "param", values_to = "value") %>%
    mutate(
      i = as.integer(str_match(param, paste0(prefix, "\\[(\\d+),"))[,2]),
      j = as.integer(str_match(param, ",\\s*(\\d+)\\]")[,2]),
      sex = ifelse(i == 1, "Female", "Male"),
      week = j
    ) %>%
    select(iter, sex, week, value)
}

r_long <- tidy_block(df, "r")
s_long <- tidy_block(df, "s")
```

Early in the season, females arrive first: during the first three capture occasions their arrival probability exceeds that of males (Figure \@ref(fig:fig-arrival-prob)). By occasion 7, essentially all individuals have entered the pond.

```{r fig-arrival-prob, echo = FALSE, fig.align='center', out.width='85%', fig.cap="Arrival probability by sex and week. Means and 95\\% credible intervals (shaded areas) are provided."}
r_sum <- r_long %>%
  group_by(sex, week) %>%
  summarise(
    mean = mean(value),
    median = median(value),
    l95 = quantile(value, 0.025),
    u95 = quantile(value, 0.975),
    .groups = "drop"
  )

if (params$bw) {
  ggplot(r_sum, aes(x = week, y = mean, color = sex, fill = sex, group = sex)) +
    geom_ribbon(aes(ymin = l95, ymax = u95), alpha = 0.2, linewidth = 0) +
    geom_line(aes(linetype = sex), size = 1) +
    labs(x = "Week", y = "Estimated arrival probability",
         title = "", color = "", fill = "", linetype = "") +
    scale_color_manual(values = c("black", "grey20")) +
    scale_fill_manual(values  = c("grey70", "grey20")) +
    scale_linetype_manual(values = c("solid", "dotted")) +
    theme_bw() +
    theme(legend.position = "top")
} else {
  ggplot(r_sum, aes(x = week, y = mean, color = sex, fill = sex, group = sex)) +
    geom_ribbon(aes(ymin = l95, ymax = u95), alpha = 0.20, linewidth = 0) +
    geom_line(size = 1) +
    labs(x = "Week", y = "Estimated arrival probability",
         title = "") +
    theme_bw() +
    theme(legend.position = "top")
}




```

Females show longer stopovers than males for most of the season; near the end, the pattern reverses (Figure \@ref(fig:fig-stopover-duration)). Individuals arriving early in the breeding season stay longer than those arriving later.

```{r fig-stopover-duration, echo = FALSE, fig.align='center', out.width='85%', fig.cap="Stopover duration by sex and arrival week. Means and 95\\% credible intervals (shaded areas) are provided."}
compute_duration_curve <- function(s_vec){
  s_vec <- pmin(s_vec, 0.999999)        # guard against s=1 exactly
  K <- length(s_vec)
  dur <- numeric(K)
  for(w in 1:K){
    if(w == K){
      dur[w] <- 1
    } else {
      dur[w] <- 1 + sum(cumprod(s_vec[w:(K-1)]))
    }
  }
  dur
}

K_weeks <- max(s_long$week)

duration_draws <- s_long %>%
  arrange(iter, sex, week) %>%
  group_by(iter, sex) %>%
  summarise(
    duration = list(compute_duration_curve(value)),
    .groups = "drop"
  ) %>%
  mutate(week = list(seq_len(K_weeks))) %>%
  unnest(c(week, duration))

duration_sum <- duration_draws %>%
  group_by(sex, week) %>%
  summarise(
    mean = mean(duration),
    median = median(duration),
    l95 = quantile(duration, 0.025),
    u95 = quantile(duration, 0.975),
    .groups = "drop"
  )

if (params$bw) {
  ggplot(duration_sum, aes(x = week, y = mean, color = sex, fill = sex, group = sex)) +
    geom_ribbon(aes(ymin = l95, ymax = u95), alpha = 0.2, linewidth = 0) +
    geom_line(aes(linetype = sex), size = 1) +
    labs(x = "Week", y = "Estimated stopover duration (weeks)",
         title = "", color = "", fill = "", linetype = "") +
    scale_color_manual(values = c("black", "grey20")) +
    scale_fill_manual(values  = c("grey70", "grey20")) +
    scale_linetype_manual(values = c("solid", "dotted")) +
    theme_bw() +
    theme(legend.position = "top")
} else {
  ggplot(duration_sum, aes(x = week, y = mean, color = sex, fill = sex, group = sex)) +
    geom_ribbon(aes(ymin = l95, ymax = u95), alpha = 0.20, linewidth = 0) +
    geom_line(size = 1) +
    labs(x = "Week", y = "Estimated stopover duration (weeks)",
         title = "") +
    theme_bw() +
    theme(legend.position = "top")
}

```



<!--chapter:end:8-lifehistory.Rmd-->

```{r include=FALSE, cache=FALSE}
# packages
library(tidyverse)
theme_set(theme_light(base_size = 14))
library(nimble)
library(MCMCvis)
library(magick)
library(pdftools)
library(wesanderson)
library(RColorBrewer)
library(patchwork)
library(emo)
#library(nimbleEcology)
#library(basicMCMCplots)

# R options
options(width = 60)

# chunk options
knitr::opts_chunk$set(
  comment = "##",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE
  )
```
# Conclusion {-}

To wrap up this book, let me share a few pieces of advice. This is not rocket science, just some lessons I've picked up along the way from building hidden Markov models and analysing data with Bayesian statistics.

+ Make your ecological question explicit. First things first. Make sure you've spent some to time to make your ecological question explicit. This step will help you to stay on course, and make the right choices. For example, it's fine to use subsets of your data to address different questions.

+ Now in terms of modeling. Think of observations and states first. Don't jump on your keyboard right away. Spend some time thinking about your model with pen and paper. In particular make sure you have the observations and the states of your HMM. Then write down the observation and transition matrices on paper. Write down the transition matrix first. You may act as if you had no imperfect detection. This is really what you're after, the ecological process (survival, dispersal, etc). Then proceed with the observation matrix.

+ When it comes to model fitting with NIMBLE, start simple, with all parameters constant for example. Make sure convergence is reached. Then add complexity one step at a time. Time effect for example, or random effects, or uncertainty in the assignment of states.

+ Consider doing simulations to better understand your model. When it comes to model building, consider simulating data to better understand your model. You will always learn something on your model by seeing it an engine to generate data, instead of estimating its parameters. The nice thing with NIMBLE is that you can use your model to simulate data.

+ Another advice, quite general in programming, is to not try to optimize your code or to try to make it elegant right away. Make your model work first, then think of optimization.

I hope to have convinced you that hidden Markov models combined with the Bayesian framework are very flexible to analyse capture-recapture data. With your data, you may ask a myriad of questions. The limit is your imagination (and CPU time). 

To stimulate your imagination, I have assembled a searchable list at <https://oliviergimenez.github.io/curated-list-of-HMM-CR-papers/> with HMM analyses of capture-recapture data for you to get inspiration. This list is not exhaustive, please get in touch with me if you'd like to add a reference.


<!-- See you with the second edition of the book, hopefully, with more HMMs and batch marking, continuous-time models, semi-Markov models (e.g. for senescence or stopover duration, @choquet_semi-markov_2011), spatial capture-recapture models, integrated population models, and a proper multievent function implemented in the `nimbleEcology` package.  -->

<!--chapter:end:999-conclusions.Rmd-->

```{r include=FALSE, cache=FALSE}
# packages
library(tidyverse)
theme_set(theme_light(base_size = 14))
library(nimble)
library(MCMCvis)
library(magick)
library(pdftools)
library(wesanderson)
library(RColorBrewer)
library(patchwork)
library(emo)
#library(nimbleEcology)
#library(basicMCMCplots)

# R options
options(width = 60)

# chunk options
knitr::opts_chunk$set(
  comment = "##",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE
  )
```
\backmatter

`r if (knitr:::is_html_output()) '
# References {-}
'`

<!--chapter:end:references.Rmd-->

