# Sites and states {#dispersal}

WORK IN PROGRESS.

## Introduction

In this fifth chapter, you will learn about the Arnason-Schwarz model that allows estimating transitions between sites and states based on capture-recapture data. You will also see how to deal with uncertainty in the assignment of states to individuals.  

## The Arnason-Schwarz (AS) model {#ASmodel}

In Chapter \@ref(survival), we got acquainted with Cormack-Jolly-Seber (CJS) model which accommodates transitions between the states alive and dead while accounting for imperfect detection. It is often the case that besides being alive, more detailed information is collected on the state of animals when they are detected. For example, if the study area is split into several discrete sites, you may record where an animal is detected, the state being now alive in this particular site. The Arnason-Schwarz (AS) model can be viewed as an extension to the CJS model in which we estimate movements between sites on top of survival. The AS model is named after the two statisticians -- Neil Arnason and Carl Schwarz -- who came up with the idea. 

Let's assume for now that we have two sites, say A and B. The way we usually think of analyzing the data is to start from the detections and non-detections and infer the transitions between sites and movements. Schematically, when a bird is detected in site A or site B, it obviously means that it is alive in that site, whereas when it is not detected, it may be dead or alive in either site. Schematically, we have:

```{r, echo = FALSE}
ggplot() +
  geom_point(aes(1, 1), size = 2.5, alpha = .7) +
  geom_point(aes(1, 1.5), size = 2.5, alpha = .7) +
  geom_point(aes(1, 2), size = 2.5, alpha = .7) +
  geom_text(aes(1, 2, label = 'non-detection'), nudge_x = -0.6, size = 7) +
  geom_text(aes(1, 1.5, label = 'detection in site A'), nudge_x = -0.6, size = 7) +
  geom_text(aes(1, 1, label = 'detection in site B'), nudge_x = -0.6, size = 7) +
  geom_point(aes(2, 1), size = 2.5, alpha = .7) +
  geom_point(aes(2, 1.5), size = 2.5, alpha = .7) +
  geom_point(aes(2, 2), size = 2.5, alpha = .7) +
  geom_text(aes(2, 2, label = 'alive in site A'), nudge_x = 0.5, size = 7) +
  geom_text(aes(2, 1.5, label = 'alive in site B'), nudge_x = 0.5, size = 7) +
  geom_text(aes(2, 1, label = 'dead'), nudge_x = 0.5, size = 7) +
  xlim(0, 3) +
  ylim(0.5, 3) +
  annotate('text', x = 1, y = 2.6, label = 'Observations', size = 10) +
  annotate('text', x = 2, y = 2.6, label = 'States', size = 10) +
  geom_segment(aes(x = 1, y = 2, xend = 2, yend = 2), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 2, xend = 2, yend = 1.5), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 2, xend = 2, yend = 1), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 1.5, xend = 2, yend = 2), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 1, xend = 2, yend = 1.5), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  theme_void()
```

Therefore observations and states are indeed closely related, but not entirely, and the HMM framework will help you make the distinction clear, which in turn will make the modelling easier. When we are to build the model, we should think the other way around, and think of the states as generating the observations. When a bird is alive in either site, it may get detected in that site or go undetected. When a bird is dead, then it goes undetected for sure. Schematically, we obtain:

```{r, echo = FALSE}
ggplot() +
  geom_point(aes(1, 1), size = 2.5, alpha = .7) +
  geom_point(aes(1, 1.5), size = 2.5, alpha = .7) +
  geom_point(aes(1, 2), size = 2.5, alpha = .7) +
  geom_text(aes(2, 2, label = 'non-detection'), nudge_x = 0.5, size = 7) +
  geom_text(aes(2, 1.5, label = 'detection in site A'), nudge_x = 0.6, size = 7) +
  geom_text(aes(2, 1, label = 'detection in site B'), nudge_x = 0.6, size = 7) +
  geom_point(aes(2, 1), size = 2.5, alpha = .7) +
  geom_point(aes(2, 1.5), size = 2.5, alpha = .7) +
  geom_point(aes(2, 2), size = 2.5, alpha = .7) +
  geom_text(aes(1, 2, label = 'alive in site A'), nudge_x = -0.6, size = 7) +
  geom_text(aes(1, 1.5, label = 'alive in site B'), nudge_x = -0.6, size = 7) +
  geom_text(aes(1, 1, label = 'dead'), nudge_x = -0.6, size = 7) +
  xlim(0, 3) +
  ylim(0.5, 3) +
  annotate('text', x = 1, y = 2.6, label = 'States', size = 10) +
  annotate('text', x = 2, y = 2.6, label = 'Observations', size = 10) +
    geom_segment(aes(x = 1, y = 2, xend = 2, yend = 2), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 2, xend = 2, yend = 1.5), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 1.5, xend = 2, yend = 2), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 1.5, xend = 2, yend = 1), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 1, xend = 2, yend = 2), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  theme_void()
```

We have $z = 1$ for alive in site A, $z = 2$ for alive in site B and $z = 3$ for dead. We will code $y = 1$ for non-detected, $y = 2$ for detected in site A and $y = 3$ for detected is site B. The parameters are:  
- $p_t^r$ is the probability of detection at $t$ for a bird in site $r$ at $t$;  
- $\phi_t^r$ is the survival probability for birds in site $r$ at between $t$ and $t+1$;  
- $\psi_t^{rs}$ is the probability of being in site $s$ at time $t+1$ for animals that were in site $r$ at $t$ and have survived to $t+1$, in short movement conditional on survival.

**Add HMM representation? Make link with observations and latent states. I'm hesitating between using letters for states, which is probably more intuitive, or numbers which would be more rigorous.**

Transition matrix

$$
\begin{matrix}
& \\
\mathbf{\Gamma} =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    z_{t}=A & z_{t}=B & z_{t}=D \\ \hdashline
\phi_A (1-\psi_{AB}) & \phi_A \psi_{AB} & 1 - \phi_A\\
\phi_B \psi_{BA} & \phi_B (1-\psi_{BA}) & 1 - \phi_B\\
0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
    \begin{matrix}
    z_{t-1}=A \\ z_{t-1}=B \\ z_{t-1}=D
    \end{matrix}
\end{matrix}
$$

Observation matrix

$$
\begin{matrix}
& \\
\mathbf{\Omega} =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    y_t=0 & y_t=1 & y_t=2 \\ \hdashline
1 - p_A & p_A & 0\\
1 - p_B & 0 & p_B\\
1 & 0 & 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
    \begin{matrix}
    z_{t}=A \\ z_{t}=B \\ z_{t}=D
    \end{matrix}
\end{matrix}
$$

Vector of initial states

$$
\begin{matrix}
& \\
\mathbf{\delta} =
    \left ( \vphantom{ \begin{matrix} 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    z_t=A & z_t=B & z_t=D \\ \hdashline
\pi_A & 1 - \pi_{A} & 0\\
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \end{matrix} } \right )
    \begin{matrix}
    \end{matrix}
\end{matrix}
$$

## Fitting the AS model to data {#ASmodelfitting}

### Geese data

To introduce this chapter, we will use data on the Canada goose (*Cinclus cinclus*; geese hereafter) kindly provided by Jay Hestbeck (**add pix of a goose?**). In total, 21277 geese were captured, marked with coded neck bands and recaptured between 1984 and 1989 in their wintering locations. Specifically, geese were monitored in the Atlantic flyway, in large areas along the East coast of the USA, namely 3 sites in the mid--Atlantic (New York, Pennsylvania, New Jersey), Chesapeake (Delaware, Maryland, Virginia), and Carolinas (North and South Carolina). Birds were adults and sub-adults when banded. 

You may scroll down the data below (**only a subsample**): 

```{r echo = FALSE}
geese <- read_csv(here::here("dat", "geese.csv"))
geese %>%
  kableExtra::kable() %>%
  kableExtra::scroll_box(width = "100%", height = "400px")
y <- geese %>%
  as.matrix()
```

The six columns are years in which the geese were captured, banded and recapture. A 0 stands for a non-detection, and we coded detections in the 3 wintering sites 1, 2 and 3 for mid--Atlantic, Chesapeake and Carolinas respectively. 

### NIMBLE implementation

To write the NIMBLE code corresponding to the AS model, we will make our life easier and start with 2 sites only -- we drop the Carolinas wintering site for now (replace all 3's by 0's in the dataset). Also we consider parameters constant over time.

<!-- Note: You may code non-detections as $y_t = 2$, and the first column in the observation matrix should go last. -->

<!-- Quick answer about the -1 and the important issue of coding states and obs. I did this on purpose, to have folks think about the difference between observations and states (non-detection obs should not be confused with state for dead). This becomes even more crucial when we get to multievent models where several observations may be generated by a single state. I get the intuition argument perfectly, but I’d like them to fight against it at first, then once they’re comfortable with the difference, they may code obs/states as they see fit. Let’s see how it goes. I agree that we should mention that during the multistate lecture, in the spirit of « you’re free to code states and jobs the way you like ». I’ll add something. -->

We start with comments to define the quantities -- parameters, states and observations -- we will use in the NIMBLE code:
```{r eval = FALSE}
multisite <- nimbleCode({
  # -------------------------------------------------
  # Parameters:
  # phiA: survival probability site A
  # phiB: survival probability site B
  # psiAB: movement probability from site A to site B
  # psiBA: movement probability from site B to site A
  # pA: recapture probability site A
  # pB: recapture probability site B
  # -------------------------------------------------
  # States (z):
  # 1 alive at A
  # 2 alive at B
  # 3 dead
  # Observations (y):
  # 1 not seen
  # 2 seen at A
  # 3 seen at B
  # -------------------------------------------------
...
```

The we specify priors for the survival, transition and detection probabilities:
```{r eval = FALSE}
multisite <- nimbleCode({
...
  # Priors
  phiA ~ dunif(0, 1)
  phiB ~ dunif(0, 1)
  psiAB ~ dunif(0, 1)
  psiBA ~ dunif(0, 1)
  pA ~ dunif(0, 1)
  pB ~ dunif(0, 1)
...
```

We now write the vector of initial state probabilities:
```{r eval = FALSE}
multisite <- nimbleCode({
...
  # initial state probabilities
  delta[1] <- piA          # Pr(alive in A at t = first)
  delta[2] <- 1 - piA      # Pr(alive in B at t = first)
  delta[3] <- 0            # Pr(dead at t = first) = 0
...
```

Actually, the initial state is known exactly: It is alive at site of initial capture, and $\pi_A$ is just the proportion of individuals first captured in site A, there is no need to make it explicit in the model and estimate it. Therefore, in the likelihood, instead of `z[i,first[i]] ~ dcat(delta[1:3])`, you can use `z[i,first[i]] <- y[i,first[i]] - 1`. **Remind that y <- y + 1. Maybe start by estimating piA, then illustrating the trick.**. Note that the same trick applies to the CJS model.

We write the transition matrix:
```{r eval = FALSE}
multisite <- nimbleCode({
...
  # probabilities of state z(t+1) given z(t)
  # (read as gamma[z(t),z(t+1)] = gamma[fromState,toState])

  gamma[1,1] <- phiA * (1 - psiAB)
  gamma[1,2] <- phiA * psiAB
  gamma[1,3] <- 1 - phiA
  gamma[2,1] <- phiB * psiBA
  gamma[2,2] <- phiB * (1 - psiBA)
  gamma[2,3] <- 1 - phiB
  gamma[3,1] <- 0
  gamma[3,2] <- 0
  gamma[3,3] <- 1
...
```

**Say something about parameterization in psiAB and psiBA and complementary probabilities that do not need to be estimated. Mutually exclusive event, therefore sum on a row is 1. **

In the same way, the observation matrix is:
```{r eval = FALSE}
multisite <- nimbleCode({
...
  # probabilities of y(t) given z(t)
  # (read as omega[y(t),z(t)] = omega[Observation,State])

  omega[1,1] <- 1 - pA     # Pr(alive A t -> non-detected t)
  omega[1,2] <- pA         # Pr(alive A t -> detected A t)
  omega[1,3] <- 0          # Pr(alive A t -> detected B t)
  omega[2,1] <- 1 - pB     # Pr(alive B t -> non-detected t)
  omega[2,2] <- 0          # Pr(alive B t -> detected A t)
  omega[2,3] <- pB         # Pr(alive B t -> detected B t)
  omega[3,1] <- 1          # Pr(dead t -> non-detected t)
  omega[3,2] <- 0          # Pr(dead t -> detected A t)
  omega[3,3] <- 0          # Pr(dead t -> detected B t)
...
```

At last, we are ready to specify the likelihood which, and this this the magic of HMM, is the same as the likelihood of the CJS model, only the vector of initial states, the transition and observation matrices were changed:
```{r eval = FALSE}
multisite <- nimbleCode({
...
  # likelihood
  for (i in 1:N){
    # latent state at first capture
    z[i,first[i]] <- y[i,first[i]] - 1
    for (t in (first[i]+1):K){
      # z(t) given z(t-1)
      z[i,t] ~ dcat(gamma[z[i,t-1],1:3])
      # y(t) given z(t)
      y[i,t] ~ dcat(omega[z[i,t],1:3])
    }
  }
})
```

Now we may run NIMBLE. **Provide whol code w/ inits, etc.**

We may have a look to the results via a caterpillar plot: 
```{r, echo = FALSE}
load(here::here("dat","geese_2sites.RData"))
```
```{r}
MCMCplot(mcmc.multisite)
```

Remember mid--Atlantic is site A, and Chesapeake site B. Detection in mid--Atlantic (around 0.5) is higher than in Cheasapeake (around 0.4) although it comes with more uncertainty (wider credible interval). Survival in both sites are similar estimated at around 0.6--0.7. Note that by going multisite, we could make these parameters site-specific and differences might reflect habitat quality for example. Now the novelty lies in our capability to estimate movements from site A to site B and from site B to site A from a winter to the next. The annual probability of remaining in the same site for two successive
winters, used as a measure of site fidelity, was lower in the mid--Atlantic (around 0.7) than in the Chesapeake (0.9). The estimated probability of moving to the Chesapeake from the mid--Atlantic was three times as high as the probability of moving in the opposite direction.

We may also have a look to numerical summaries, which confirm our ecological interpretation of the model parameters:
```{r echo = FALSE}
load(here::here("dat","geese_2sites.RData"))
```
```{r}
MCMCsummary(mcmc.multisite, round = 2)
```

**Add time-dependence and comment on the harshness of winters? Also this is only a subsample of the whole dataset, I shall introduce the pooled (marginalized) likelihood, probably at the end of the section/chapter.**

## What if there are more than 2 sites?

So far we have considered two sites only, for the sake of simplicity. Indeed when going for three sites and more, a difficulty arises. While the movement probabilities still need to be between 0 and 1, the sum of all probabilities of moving from a site should also sum to one. This is because an individual alive in site A for example, has to stay in A, move to B or move to C, it has no other choice. **not sure it is clear enough, nor whether i need to mention mutually exclusive events.**

There are basically two methods to fulfill both constraints, either to assign a Dirichlet (it is pronounced deer-eesh-lay) prior to the movement probabilities, or to use a multinomial logit link function. 

### Dirichlet prior

The Dirichlet distribution extends the Beta distribution multivariate we have seen previously (Figure \@ref(fig:betadistribution)) for values between 0 and 1 that add up to 1. Going back to our example with 3 sites, we would like to come up with a prior for parameters of moving from A, which are $\psi^{AA}$, $\psi^{AB}$ and $\psi^{AC}$. The Dirichlet distribution of dimension 3 has a vector of parameters $(\alpha_1, \alpha_2, \alpha_3)$ that controls its shape. The sum of all $\alpha$'s can be interpreted as a measure of precision: The higher the sum, the more peaked is the distribution on the mean value, the mean value along each dimension being the ratio of the corresponding over the sum of all $\alpha$'s. When all $\alpha$'s are equal, the distribution is symmetric (Figure \@ref(fig:dirichletdistribution)). Its mean is $(1/3, 1/3, 1/3)$ in our example with 3 parameters, whatever the value of $\alpha$. When $\alpha_1 = \alpha_2 = \alpha_3 = 1$, we obtain a uniform marginal distribution for the $\psi$'s, while values below 1 ($\alpha_1 = \alpha_2 = \alpha_3 = 0.1$) result in the distribution concentrating in the corners (skewed U-shaped forms) and values above 1 ($\alpha_1 = \alpha_2 = \alpha_3 = 10$) result in unimodal marginal distributions.

<!-- The probability density function for dirichlet is $f(x) = \displaystyle{\frac{1}{\text{B}({\mathbf \alpha})} \prod_{i=1}^K{x_i^{\alpha_i-1}}}$ where $\text{B}({\mathbf \alpha}) = \displaystyle{\frac{\prod_{i=1}^K{\Gamma({\alpha_i})}}{\Gamma(\sum_{i=1}^K{\alpha_i})}}$ and ${\mathbf \alpha} = (\alpha_1, \ldots, \alpha_K)$ the concentration parameters and $K$ the dimension of the space where $x$ takes values (Figure \@ref(fig:dirichlet)). -->
<!-- <https://en.wikipedia.org/wiki/Dirichlet_distribution#Occurrence_and_applications> -->
<!-- <https://stats.stackexchange.com/questions/130248/what-is-a-dirichlet-prior> <https://mc-stan.org/docs/functions-reference/dirichlet-distribution.html> <https://www.cs.helsinki.fi/u/ahonkela/dippa/node95.html> <https://rpubs.com/JanpuHou/295096> <https://www.biorxiv.org/content/10.1101/711317v2.full.pdf> <https://www.statisticshowto.com/dirichlet-distribution/> <https://research.wu.ac.at/ws/portalfiles/portal/17761231/Report125.pdf> -->

```{r dirichletdistribution, echo = TRUE, message=FALSE, warning=FALSE, fig.cap = "Dirichlet prior with parameter alpha"}
library(gtools) # to make the rdirichlet() function available
library(ggtern) # to visually represent multidim prob distribution 
set.seed(123)
n <- 1000
alpha1 <- c(.1, .1, .1)
p1 <- rdirichlet(n, alpha1)
alpha2 <- c(1, 1, 1)
p2 <- rdirichlet(n, alpha2)
alpha3 <- c(10, 10, 10)
p3 <- rdirichlet(n, alpha3)
df <- cbind(rbind(p1, p2, p3), c(rep("alpha = c(0.1, 0.1, 0.1)", n),
                                     rep("alpha = c(1, 1, 1)", n),
                                     rep("alpha = c(10, 10, 10)", n))) %>%
  as_tibble() %>%
  mutate(x = as.numeric(V1),
         y = as.numeric(V2),
         z = as.numeric(V3),
         alpha = V4)

df %>%
  ggtern(aes(x = x, y = y, z = z)) +
  stat_density_tern(aes(fill=..level.., alpha=..level..),
                    geom = 'polygon',
                    bdl = 0.005) + # a 2D kernel density estimation of the distribution
  scale_fill_viridis_b() +
  geom_point(alpha = 0.3, pch = "+") +
  theme_light(base_size = 14) +
  theme_showarrows() +
  scale_T_continuous(breaks = seq(0, 1, by = 0.2),
                     labels = seq(0, 1, by = 0.2)) +
  scale_L_continuous(breaks = seq(0, 1, by = 0.2),
                     labels = seq(0, 1, by = 0.2)) +
  scale_R_continuous(breaks = seq(0, 1, by = 0.2),
                     labels = seq(0, 1, by = 0.2)) +
  labs(x = "",
       y = "",
       z = "",
       Tarrow = "psiAA",
       Larrow = "psiAB",
       Rarrow = "psiAC") +
  guides(color = "none", fill = "none", alpha = "none") +
  facet_wrap(~alpha, ncol = 3)
```

Going back to our example, in NIMBLE, we consider a Dirichlet prior for each triplet of movement parameters, from site A ($\psi^{AA}$, $\psi^{AB}$ and $\psi^{AC}$), from site B ($\psi^{BA}$, $\psi^{BB}$ and $\psi^{BC}$) and from site C ($\psi^{CA}$, $\psi^{CB}$ and $\psi^{CC}$):

```{r eval = FALSE}
multisite <- nimbleCode({
...
  # transitions: Dirichlet priors
  psiA[1:3] ~ ddirch(alpha[1:3]) # psiAA, psiAB, psiAC
  psiB[1:3] ~ ddirch(alpha[1:3]) # psiBA, psiBB, psiCC
  psiC[1:3] ~ ddirch(alpha[1:3]) # psiCA, psiCB, psiCC
...
```

Then we use these parameters (which now respect the constraints) to define the transition matrix:

```{r eval = FALSE}
multisite <- nimbleCode({
...
  # probabilities of state z(t+1) given z(t)
  gamma[1,1] <- phiA * psiA[1]
  gamma[1,2] <- phiA * psiA[2]
  gamma[1,3] <- phiA * psiA[3]
  gamma[1,4] <- 1 - phiA
  gamma[2,1] <- phiB * psiB[1]
  gamma[2,2] <- phiB * psiB[2]
  gamma[2,3] <- phiB * psiB[3]
  gamma[2,4] <- 1 - phiB
  gamma[3,1] <- phiC * psiC[1]
  gamma[3,2] <- phiC * psiC[2]
  gamma[3,3] <- phiC * psiC[3]
  gamma[3,4] <- 1 - phiC
  gamma[4,1] <- 0
  gamma[4,2] <- 0
  gamma[4,3] <- 0
  gamma[4,4] <- 1
...
```

When we fit this model to the geese dataset with the detections in the Carolinas wintering site back in, and with `alpha <- c(1, 1, 1)` passed to the constants, we obtain the following results: 
```{r echo = FALSE}
load(here::here("dat","geese_3sites_dirichlet.RData"))
```
```{r}
MCMCsummary(mcmc.multisite, round = 2)
```

Survival probabilities are similar among sites, but the detection probability in Carolinas seems much lower than in the two other wintering sites. The estimated probability of moving to the Chesapeake from the Carolinas is 2 times as high as the probability of moving in the opposite direction.

In theory, you could include covariates as in \@ref(covariates) through the $\alpha$ parameters and the use a log link function (to ensure $\alpha > 0$), e.g. $\log(\alpha) = \beta_1 + \beta_2 x$. However, NIMBLE does not allow that **Is it certain that we can go hierarchical here?**. Fortunately, there is another way to specify the Dirichlet distribution through a ratio of gamma distributions that allows to incorporate covariates.  

If we have three independent random variables $Y_1, Y_2$ and $Y_3$ distributed as gamma distributions with shape parameters the $\alpha$'s and same scale parameter $\theta$, that is $Y_j \sim \text{Gamma}(\alpha_j, \theta)$, then it can be shown that the vector $(Y_1/V, Y_2/V, Y_3/V)$ is Dirichlet with vector of parameters the $\alpha$'s, where $V$ is the sum of the $Y$'s (which is also gamma distributed). **Do I want to go down that path and define the Gamma distribution.** In NIMBLE, this suggests using $\theta = 1$ to get a uniform prior:

```{r eval = FALSE}
...
# transitions: Dirichlet priors with Gamma formulation
for (s in 1:ns){
  lpsiA[s] ~ dgamma(alpha[s], 1) # Y1, Y2, Y3 for psiAA, psiAB, psiAC
  psiA[s] ~ lpsiA[s]/VA # psiAA, psiAB, psiAC
  lpsiB[s] ~ dgamma(alpha[s], 1) # Y'1, Y'2, Y'3 for psiBA, psiBB, psiBC
  psiB[s] ~ lpsiB[s]/VB # psiBA, psiBB, psiCC
  lpsiC[s] ~ dgamma(alpha[s], 1) # Y''1, Y''2, Y''3 for psiCA, psiCB, psiCC
  psiC[s] ~ lpsiC[s]/VC # psiCA, psiCB, psiCC
}
VA <- sum(lpsiA[1:ns])
VB <- sum(lpsiB[1:ns])
VC <- sum(lpsiC[1:ns])
...
```

From there, we can express the shape parameter of the gamma distribution (precisely the $\alpha$'s here) as a function of covariates as in $\log(\alpha) = \beta_1 + \beta_2 x$ in the spirit of a generalized linear model with a gamma response.

<!-- <https://en.wikipedia.org/wiki/Dirichlet_distribution#Related_distributions>, <https://en.wikipedia.org/wiki/Dirichlet_distribution#Random_variate_generation>, <https://groups.google.com/g/nimble-users/c/4XrJbRLUOyY/m/iDLeAIovAQAJ> -->


### Multinomial logit

<!-- <https://socialwork.wayne.edu/research/pdf/multi-nomial-logistic-regression.pdf>, <https://www3.nd.edu/~rwilliam/stats3/Mlogit1.pdf>, <https://stats.oarc.ucla.edu/stata/dae/multinomiallogistic-regression/> and <https://en.wikipedia.org/wiki/Multinomial_logistic_regression>. -->

Another possibility to build a prior that ensures the movement probabilities are between 0 and 1 and sum up to 1 is to extend the logit link we used for the CJS model in Section \@ref(covariates). Remember we had $\text{logit}(\phi) = \beta$, we specified a prior on $\beta$ say $\beta \sim N(0,1.5)$ then got a prior on $\phi$ by back-transforming $\phi = \text{logit}^{-1}(\beta)$. 

Going back to our example with $3$ sites, and focusing on the movement probabilities say, from site A, we first choose a reference (or pivot) site, say A, then $\log\left(\displaystyle{\frac{\psi^{AB}}{\psi^{AA}}}\right) = \beta_B$ and $\log\left(\displaystyle{\frac{\psi^{AC}}{\psi^{AA}}}\right) = \beta_C$. Interestingly, when exponentiated, the $\beta$'s here can be interpreted as the increase in the odds of moving versus staying on site resulting from a one-unit increase in the covariate. **give an example.** Any of the sites can be chosen to be the reference, this will not change the likelihood and you will get the same results. **It works because the sites are unordered levels. Check out Roger's HDR for other link functions.** Now we specify a normal prior distribution for the $\beta$'s. Eventually, to back-transform, we use $\psi^{AB} = \displaystyle{\frac{\exp(\beta_B)}{1+\displaystyle{\exp(\beta_B)+\displaystyle{\exp(\beta_C)}}}}$ and $\psi^{AC} = \displaystyle{\frac{\exp(\beta_C)}{1+\displaystyle{\exp(\beta_B)+\displaystyle{\exp(\beta_C)}}}}$. The reference parameter, here $\psi^{AA}$, is calculated as $\psi^{AA} = \displaystyle{\frac{1}{1 + \displaystyle{\exp(\beta_B)+\displaystyle{\exp(\beta_C)}}}}$, or simply as the complementary probability $\psi^{AA} = 1 - \psi^{AB} - \psi^{AC}$.

Note that when there are only 2 sites instead of 3 or more, then the multinomial logit reduces to the logit link. 

In NIMBLE, we write:

```{r eval = FALSE}
multisite <- nimbleCode({
...
  # transitions: multinomial logit
  for (i in 1:2){
  # normal priors on logit of all but one movement prob
    betaA[i] ~ dnorm(0, sd = 1.5)
    betaB[i] ~ dnorm(0, sd = 1.5)
    betaC[i] ~ dnorm(0, sd = 1.5)
  # constrain the transitions such that their sum is < 1
    psiA[i] <- exp(betaA[i]) / (1 + exp(betaA[1]) + exp(betaA[2]))
    psiB[i] <- exp(betaB[i]) / (1 + exp(betaB[1]) + exp(betaB[2]))
    psiC[i] <- exp(betaC[i]) / (1 + exp(betaC[1]) + exp(betaC[2]))
  }
  # reference movement probability
  psiA[3] <- 1 - psiA[1] - psiA[2]
  psiB[3] <- 1 - psiB[1] - psiB[2]
  psiC[3] <- 1 - psiC[1] - psiC[2]
...
```

Then we use these parameters (which now respect the constraints) to define the transition matrix:

```{r eval = FALSE}
multisite <- nimbleCode({
...
  # probabilities of state z(t+1) given z(t)
  gamma[1,1] <- phiA * psiA[1]
  gamma[1,2] <- phiA * psiA[2]
  gamma[1,3] <- phiA * psiA[3]
  gamma[1,4] <- 1 - phiA
  gamma[2,1] <- phiB * psiB[1]
  gamma[2,2] <- phiB * psiB[2]
  gamma[2,3] <- phiB * psiB[3]
  gamma[2,4] <- 1 - phiB
  gamma[3,1] <- phiC * psiC[1]
  gamma[3,2] <- phiC * psiC[2]
  gamma[3,3] <- phiC * psiC[3]
  gamma[3,4] <- 1 - phiC
  gamma[4,1] <- 0
  gamma[4,2] <- 0
  gamma[4,3] <- 0
  gamma[4,4] <- 1
...
```

You may check that the results are very similar to those we obtained with the Dirichlet prior:

```{r echo = FALSE}
load(here::here("dat","geese_3sites_logit.RData"))
```
```{r}
MCMCsummary(mcmc.multisite, round = 2)
```

## Sites may be states

So far, we have considered geographical locations (or sites) to refine the alive information when an animal is detected. However, it was quickly realized that sites could actually be states or classes defined by physiology or behavior, hence opening up an avenue for applications of capture-recapture models in many fields of ecology. 

Examples of states include:  

+ Epidemiological or disease states: sick/healthy, uninfected/infected/recovered;  
+ Morphological states: small/medium/big, light/medium/heavy;  
+ Breeding states: e.g. breeder/non-breeder,  failed breeder, first-time breeder;  
+ Developmental or life-history states: e.g. juvenile/subadult/adult;  
+ Social states: e.g. solitary/group-living,  subordinate/dominant;  
+ Death states: e.g. alive, dead from harvest, dead from natural causes;  

In brief, states are individual, time-specific discrete covariates.

### Titis data

To illustrate this section, we will consider data collected between 1940 and 1957 by Lance Richdale on the Sooty shearwaters (aka titis). **More details. Plus a picture of titi.**

```{r echo = FALSE}
titis <- read_csv2(here::here("dat", "titis.csv"), col_names = FALSE)
titis %>%
  rename(year_1942 = X1,
         year_1943 = X2,
         year_1944 = X3,
         year_1949 = X4,
         year_1952 = X5,
         year_1953 = X6,
         year_1956 = X7) %>%
  kableExtra::kable() %>%
  kableExtra::scroll_box(width = "100%", height = "400px")
```


<!-- ```{r echo = FALSE} -->
<!-- knitr::include_graphics("images/sooty.jpg") -->
<!-- ``` -->

These data were analyzed with capture-recapture models by Richard Scofield who kindly provided us with the data. 

Following the way the data were collected, four states were originally considered: Alive breeder; Accompanied by another bird in a burrow; Alone in a burrow; On the surface; Dead. For simplicity, we pooled all alive states (except breeder) together in a non-breeder state (NB) that includes failed breeders (birds that had bred previously – skip reproduction or divorce) and pre-breeders (birds that had yet to breed). Because burrows were not checked before hatching, some birds in the category NB might have already failed. We therefore regard those birds in the B state as successful breeders, and those in the NB state as nonbreeders plus prebreeders and failed breeders.

Observations are non-detections, and detections as breeder and non-breeder

The aim here is to study life-history trade--offs. Specifically, we ask the questions: Does breeding affect survival? Does breeding in current year affect breeding next year?

### The AS model for states

Basically, same model as in the geese example with two sites, see Sections \@ref(ASmodel) and \@ref(ASmodelfitting).

Transition matrix

$$
\begin{matrix}
& \\
\mathbf{\Gamma} =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    z_t=B & z_t=NB & z_t=D \\ \hdashline
\phi_B (1-\psi_{BNB}) & \phi_B \psi_{BNB} & 1 - \phi_B\\
\phi_{NB} \psi_{NBB} & \phi_{NB} (1-\psi_{NBB}) & 1 - \phi_{NB}\\
0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
    \begin{matrix}
    z_{t-1}=B \\ z_{t-1}=NB \\ z_{t-1}=D
    \end{matrix}
\end{matrix}
$$

The costs or reproduction would reflect in future reproduction if breeders have a lower probability of breed next year than non-breeders $\psi_{BB} = 1 - \psi_{BNB} < \psi_{NBB}$ or in survival if the survival of breeders is lower than that of non-breeders $\phi_B < \phi_{NB}$.

Observation matrix

$$
\begin{matrix}
& \\
\mathbf{\Omega} =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    y_t=0 & y_t=1 & y_t=2 \\ \hdashline
1 - p_B & p_B & 0\\
1 - p_{NB} & 0 & p_{NB}\\
1 & 0 & 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
    \begin{matrix}
    z_{t}=B \\ z_{t}=NB \\ z_{t}=D
    \end{matrix}
\end{matrix}
$$

### NIMBLE implementation

We first write the NIMBLE code, which is exactly the same as in the geese example with two sites, see Section \@ref(ASmodelfitting). 

First some definitions which we comment:
```{r eval = FALSE}
multistate <- nimbleCode({
  # -------------------------------------------------
  # Parameters:
  # phiB: survival probability state B
  # phiNB: survival probability state NB
  # psiBNB: transition probability from B to NB
  # psiNBB: transition probability from NB to B
  # pB: recapture probability B
  # pNB: recapture probability NB
  # -------------------------------------------------
  # States (z):
  # 1 alive B
  # 2 alive NB
  # 3 dead
  # Observations (y):
  # 1 not seen
  # 2 seen as B
  # 3 seen as NB
  # -------------------------------------------------
...
```

Then the priors:
```{r eval = FALSE}
multistate <- nimbleCode({
...
  # Priors
  phiB ~ dunif(0, 1)
  phiNB ~ dunif(0, 1)
  psiBNB ~ dunif(0, 1)
  psiNBB ~ dunif(0, 1)
  pB ~ dunif(0, 1)
  pNB ~ dunif(0, 1)
...
```

The transition matrix:
```{r eval = FALSE}
multistate <- nimbleCode({
...
  # probabilities of state z(t+1) given z(t)
  gamma[1,1] <- phiB * (1 - psiBNB)
  gamma[1,2] <- phiB * psiBNB
  gamma[1,3] <- 1 - phiB
  gamma[2,1] <- phiNB * psiNBB
  gamma[2,2] <- phiNB * (1 - psiNBB)
  gamma[2,3] <- 1 - phiNB
  gamma[3,1] <- 0
  gamma[3,2] <- 0
  gamma[3,3] <- 1
...
```

The observation matrix:
```{r eval = FALSE}
multistate <- nimbleCode({
...
  # probabilities of y(t) given z(t)
  omega[1,1] <- 1 - pB    # Pr(alive B t -> non-detected t)
  omega[1,2] <- pB        # Pr(alive B t -> detected B t)
  omega[1,3] <- 0         # Pr(alive B t -> detected NB t)
  omega[2,1] <- 1 - pNB   # Pr(alive NB t -> non-detected t)
  omega[2,2] <- 0         # Pr(alive NB t -> detected B t)
  omega[2,3] <- pNB       # Pr(alive NB t -> detected NB t)
  omega[3,1] <- 1         # Pr(dead t -> non-detected t)
  omega[3,2] <- 0         # Pr(dead t -> detected N t)
  omega[3,3] <- 0         # Pr(dead t -> detected NB t)
...
```

And the likelihood:
```{r eval = FALSE}
multistate <- nimbleCode({
...
  # likelihood
  for (i in 1:N){
    # latent state at first capture
    z[i,first[i]] <- y[i,first[i]] - 1
    for (t in (first[i]+1):K){
      # z(t) given z(t-1)
      z[i,t] ~ dcat(gamma[z[i,t-1],1:3])
      # y(t) given z(t)
      y[i,t] ~ dcat(omega[z[i,t],1:3])
    }
  }
})
```

You may run NIMBLE and get the following results:
```{r echo = FALSE}
load(here::here("dat","titis.RData"))
```
```{r}
MCMCsummary(mcmc.multistate, round = 2)
```

Non-breeder individuals seem to have a survival higher than breeder individuals, suggesting a trade-off between reproduction and survival. Let's compare graphically the survival of breeder and non-breeder individuals. First we gather the values generated for $\phi_B$ and $\phi_{NB}$ for the two chains.

```{r}
phiB <- c(mcmc.multistate$chain1[,"phiB"], mcmc.multistate$chain2[,"phiB"])
phiNB <- c(mcmc.multistate$chain1[,"phiNB"], mcmc.multistate$chain2[,"phiNB"])
df <- data.frame(param = c(rep("phiB", length(phiB)), 
                           rep("phiNB", length(phiB))), 
                 value = c(phiB, phiNB))
head(df)
```

Then, we plot a histogram of the two posterior distributions:

```{r}
df %>%
  ggplot(aes(x = value, fill = param)) +
  geom_density(color = "white", alpha = 0.6, position = 'identity') +
  scale_fill_manual(values = c("#69b3a2", "#404080")) +
  labs(fill = "", x = "survival")
```

A formal test of the trade-off would consist in fitting the model with survival irrespective of the state, and compare its WAIC value to the model we just fitted.

What about a potential trade-off on reproduction?

```{r}
psiBNB <- c(mcmc.multistate$chain1[,"psiBNB"], mcmc.multistate$chain2[,"psiBNB"])
psiBB <- 1 - psiBNB
psiNBB <- c(mcmc.multistate$chain1[,"psiNBB"], mcmc.multistate$chain2[,"psiNBB"])
df <- data.frame(param = c(rep("psiBB", length(phiB)), 
                           rep("psiNBB", length(phiB))), 
                 value = c(psiBB, psiNBB))
df %>%
  ggplot(aes(x = value, fill = param)) +
  geom_density(color = "white", alpha = 0.6, position = 'identity') +
  scale_fill_manual(values = c("#69b3a2", "#404080")) +
  labs(fill = "", x = "breeding probabilities")

```

Interestingly, breeder individuals do much better than non-breeder individuals. This failure at detecting a trade-off is probably due to individual heterogeneity that should be accounted for. **Case study with simulations as in Oikos paper, see Figure 1 and Table 2. Would be a nice example of the use of simulations. Another example could the statistical power analyses.**
  
## Goodness of fit {#gofas}
  
**I'm missing a section on gof w/ R2ucare and posterior predictive checks/Bayesian p-values.**

```{r eval = FALSE}
geese.hist <- geese$encounter_histories
geese.freq <- geese$sample_size
test3Gsr(geese.hist, geese.freq)
test3Gsm(geese.hist, geese.freq)
test3Gwbwa(geese.hist, geese.freq)
testMitec(geese.hist, geese.freq)
testMltec(geese.hist, geese.freq)
```

All at once:
```{r eval = FALSE}
overall_JMV(geese.hist, geese.freq)
```

**Refer to case study for posterior predictive check, and how to account for memory. If trap-dependence or transience is significant, you may account for these lacks of fit as in the Cormack-Jolly-Seber model example. If there are signs of a memory effect, it gets a bit trickier but you may fit a model to account for this issue. Check our Animal Biodiversity paper for more.**

## Issue of local minima

Simulated data: 2 sites or states, and 7 occasions, Survival $\phi = 1$, detection $p = 0.6$, Transition $\psi_{12} = 0.6$, Transition $\psi_{21} = 0.85$.

Courtesy of Jérôme Dupuis, used in @gimenez2005profile.

Data:
```{r echo = FALSE}
dat <- matrix(c(2, 0, 2, 1, 2, 0, 2,
                2, 0, 2, 1, 2, 0, 2,
                2, 0, 2, 1, 2, 0, 2,
                2, 0, 2, 1, 2, 0, 2,
                1, 1, 1, 0, 1, 0, 1,
                1, 1, 1, 0, 1, 0, 1,
                1, 1, 1, 0, 1, 0, 1,
                1, 1, 1, 0, 1, 0, 1,
                2, 0, 2, 0, 2, 0, 1,
                2, 0, 2, 0, 2, 0, 1,
                2, 0, 2, 0, 2, 0, 1,
                2, 0, 2, 0, 2, 0, 1,
                1, 0, 1, 0, 1, 0, 1,
                1, 0, 1, 0, 1, 0, 1,
                1, 0, 1, 0, 1, 0, 1,
                1, 0, 1, 0, 1, 0, 1,
                2, 0, 2, 0, 2, 0, 2,
                2, 0, 2, 0, 2, 0, 2,
                2, 0, 2, 0, 2, 0, 2,
                2, 0, 2, 0, 2, 0, 2,
                1, 0, 1, 0, 1, 0, 2,
                1, 0, 1, 0, 1, 0, 2,
                1, 0, 1, 0, 1, 0, 2,
                1, 0, 1, 0, 1, 0, 2,
                2, 2, 0, 1, 0, 2, 1,
                2, 2, 0, 1, 0, 2, 1,
                2, 2, 0, 1, 0, 2, 1,
                2, 2, 0, 1, 0, 2, 1,
                2, 1, 0, 2, 0, 1, 1,
                2, 1, 0, 2, 0, 1, 1,
                2, 1, 0, 2, 0, 1, 1,
                2, 1, 0, 2, 0, 1, 1),
              byrow = T,
              ncol = 7)
dat %>%
  as_tibble() %>%
  kableExtra::kable() %>%
  kableExtra::scroll_box(width = "100%", height = "400px")
```

Initial values lead to local and global minimum, here rofile deviance of transition from 2 to 1:

```{r inits, fig.ncol = 2, echo = FALSE, fig.cap = "Influence of initial values on convergence in max lik. Left: inits lead to local min; Right: inits lead to global min", fig.show = "hold", fig.subcap = c("left", "right"), out.width="50%"}
knitr::include_graphics(c("images/multistate_local_minimav2_Page_06.png", 
                   "images/multistate_local_minimav2_Page_07.png"))
```

When it comes to MCMC, here are the trace:

```{r, echo = FALSE}
load(here::here("dat","localminima.RData"))
psiBA <- c(mcmc.multistate$chain1[,"psiBA"], mcmc.multistate$chain2[,"psiBA"])
plotpsiBA <- psiBA %>%
  as_tibble() %>%
  ggplot() +
  aes(x = 1:length(value), y = value) +
  geom_line(color = "gray70") +
  labs(y = "psi21", x = "iterations") +
  theme_light(base_size = 14) +
  geom_hline(yintercept = 0.85, lty = 2, color = "blue")

psiAB <- c(mcmc.multistate$chain1[,"psiAB"],mcmc.multistate$chain2[,"psiAB"])
plotpsiAB <- psiAB %>%
  as_tibble() %>%
  ggplot() +
  aes(x = 1:length(value), y = value) +
  geom_line(color = "gray70") +
  labs(y = "psi12", x = "iterations") +
  theme_light(base_size = 14) +
  geom_hline(yintercept = 0.6, lty = 2, color = "blue")

det <- c(mcmc.multistate$chain1[,"p"], mcmc.multistate$chain2[,"p"])
plotdet <- det %>%
  as_tibble() %>%
  ggplot() +
  aes(x = 1:length(value), y = value) +
  geom_line(color = "gray70") +
  labs(y = "detection", x = "iterations") +
  theme_light(base_size = 14) +
  geom_hline(yintercept = 0.6, lty = 2, color = "blue")

plotdet / (plotpsiAB + plotpsiBA)
```

And the posterior distributions:

```{r, echo = FALSE}
load(here::here("dat","localminima.RData"))
psiBA <- c(mcmc.multistate$chain1[,"psiBA"], mcmc.multistate$chain2[,"psiBA"])
plotpsiBA <- psiBA %>%
  as_tibble() %>%
  ggplot() +
  aes(x = value) +
  geom_histogram(color = "white", binwidth = .03, fill = "gray70") +
  geom_density(aes(y = .03 * ..count..)) +
  labs(x = "psi21", y = "") +
  theme_light(base_size = 14) +
  geom_vline(xintercept = 0.85, lty = 2, color = "blue")

psiAB <- c(mcmc.multistate$chain1[,"psiAB"],mcmc.multistate$chain2[,"psiAB"])
plotpsiAB <- psiAB %>%
  as_tibble() %>%
  ggplot() +
  aes(x = value) +
  geom_histogram(color = "white", binwidth = .03, fill = "gray70") +
  geom_density(aes(y = .03 * ..count..)) +
  labs(x = "psi12", y = "") +
  theme_light(base_size = 14) +
  geom_vline(xintercept = 0.6, lty = 2, color = "blue")


det <- c(mcmc.multistate$chain1[,"p"], mcmc.multistate$chain2[,"p"])
plotdet <- det %>%
  as_tibble() %>%
  ggplot() +
  aes(x = value) +
  geom_histogram(color = "white", binwidth = .03, fill = "gray70") +
  geom_density(aes(y = .03 * ..count..)) +
  labs(x = "detection", y = "") +
  theme_light(base_size = 14) +
  geom_vline(xintercept = 0.6, lty = 2, color = "blue")

library(patchwork)

plotdet / (plotpsiAB + plotpsiBA)
```

## Uncertainty

We're going to talk about multievent models. Multievent models extend multistate models with uncertainty in state assignment. Let's see some examples to fix ideas. These examples are from published papers which used multievent models.

### Examples

+ Breeding status in female roe deer is ascertained based on fawn detection

+ Sex status is ascertained based on morphological criteria in Audouin's gulls

+ Disease status in house finches is ascertained based on birds' eyes examination

+ Hybrid status in wolves is ascertained based on genetics

+ Dominance status in wolves is ascertained based on heterogeneity in detection

The common thing to all these examples is that. We need to explicitly consider state assignment in a model. HMMs to the rescue! And to do that, we'll use HMMs again!

Questions:

+ Testing life-history trade-offs while accounting for uncertainty in breeding status

+ Quantifying disease dynamics while accounting for uncertainty in disease status

+ Estimating survival while accounting for individual heterogeneity in detection

+ In this module, I'll go through 3 examples.
+ Testing life-history trade-offs while accounting for uncertainty in breeding status.
+ Quantifying disease dynamics while accounting for uncertainty in disease status.
+ Estimating survival while accounting for individual heterogeneity in detection.

+ Testing life-history trade-offs while accounting for uncertainty in breeding status.

+ Quantifying disease dynamics while accounting for uncertainty in disease status

+ Estimating survival while accounting for individual heterogeneity in detection

### Breeding status

Testing life-history trade-offs while accounting for uncertainty in breeding status.

Ingredients

+ 3 states
    + breeding (B)
    + non-breeding (NB)
    + dead (D)

+ 4 observations
    + not encountered (0)
    + found, ascertained as breeder (1)
    + found, ascertained as non-breeder (2)
    + found, status unknown (3)

We still have 3 states, breeding, non-breeding and dead. With regard to observations, a bird may be not encountered. It may also be encountered, but in contrast with multistate CR data, we don't know its state for sure. It may be found and ascertained or classified as breeder. It may be found and ascertained or classified as non-breeder. It may be found be we are unable to determine whether it's breeding or non-breeding.

Now how do the states generate the observations?

```{r, echo = FALSE}
ggplot() +
  geom_point(aes(1, 1), size = 2.5, alpha = .7) +
  geom_point(aes(1, 1.5), size = 2.5, alpha = .7) +
  geom_point(aes(1, 2), size = 2.5, alpha = .7) +
  geom_text(aes(1.5, 2, label = 'not encountered (0)'), nudge_x = 1, size = 7) +
  geom_text(aes(1.5, 1.5, label = 'found, ascertained as breeder (1)'), nudge_x = 1.5, size = 7) +
  geom_text(aes(1.5, 1, label = 'found, ascertained as non-breeder (2)'), nudge_x = 1.7, size = 7) +
  geom_text(aes(1.5, 0.5, label = 'found, status unknown (3)'), nudge_x = 1.2, size = 7) +
  geom_point(aes(1.5, 0.5), size = 2.5, alpha = .7) +
  geom_point(aes(1.5, 1), size = 2.5, alpha = .7) +
  geom_point(aes(1.5, 1.5), size = 2.5, alpha = .7) +
  geom_point(aes(1.5, 2), size = 2.5, alpha = .7) +
  geom_text(aes(.5, 2, label = 'breeding'), nudge_x = 0, size = 7) +
  geom_text(aes(.5, 1.5, label = 'non-breeding'), nudge_x = -0.2, size = 7) +
  geom_text(aes(.5, 1, label = 'dead'), nudge_x = 0.1, size = 7) +
  xlim(0, 4.5) +
  ylim(0.5, 3) +
  annotate('text', x = .5, y = 2.6, label = 'States', size = 10) +
  annotate('text', x = 2.5, y = 2.6, label = 'Observations', size = 10) +

  geom_segment(aes(x = 1, y = 1, xend = 1.5, yend = 2), alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +

  geom_segment(aes(x = 1, y = 1.5, xend = 1.5, yend = 1), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 1.5, xend = 1.5, yend = 2), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 1.5, xend = 1.5, yend = .5), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +

  geom_segment(aes(x = 1, y = 2, xend = 1.5, yend = .5), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 2, xend = 1.5, yend = 1.5), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +
  geom_segment(aes(x = 1, y = 2, xend = 1.5, yend = 2), lty = 2, alpha = 0.7, arrow = arrow(length = unit(0.02, "npc"))) +

  theme_void()
```

To wrap up each live state can generate 3 observations. The only deterministic link is that between the dead state and the observation non-encountered. Cause if you're dead, you cannot be detected for sure.

### Model

Vector of initial state probabilities

$$
\begin{matrix}
& \\
\mathbf{\delta} =
    \left ( \vphantom{ \begin{matrix} 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    z_t=B & z_t=NB & z_t=D \\ \hdashline
\pi_B & 1 - \pi_{B} & 0\\
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \end{matrix} } \right )
    \begin{matrix}
    \end{matrix}
\end{matrix}
$$

$\pi_B$ is the probability that a newly encountered individual is a breeder. $\pi_{NB} = 1 - \pi_B$ is the probability that a newly encountered individual is a non-breeder

OK now let’s specify the model. First thing we need, and it’s a big difference with multistate models, we need initial state probabilities cause we cannot assign states to individuals w/ certainty. Let's define pi_B the prob that a newly encountered individual is a breeding individual. We write down the prob for each state at first encounter. We have pi_B, then the prob of being a NB is the complementary. And the prob of being dead at first encounter is 0 of course.


Transition matrix

$$
\begin{matrix}
& \\
\mathbf{\Gamma} =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    z_t=B & z_t=NB & z_t=D \\ \hdashline
\phi_B (1-\psi_{BNB}) & \phi_B \psi_{BNB} & 1 - \phi_B\\
\phi_{NB} \psi_{NBB} & \phi_{NB} (1-\psi_{NBB}) & 1 - \phi_{NB}\\
0 & 0 & 1
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12 \end{matrix} } \right )
    \begin{matrix}
    z_{t-1}=B \\ z_{t-1}=NB \\ z_{t-1}=D
    \end{matrix}
\end{matrix}
$$

$\phi_B$ is breeder survival, $\phi_{NB}$ that of non-breeders. $\psi_{BNB}$ is the probability for an individual breeding a year to be a non-breeder the next year. $\psi_{NBB}$ is the probability for an non-breeder individual to breeder the next year. The transition parameters are in a matrix similar to the one we used for multistate models.

Observation matrix

$$
\begin{matrix}
& \\
\mathbf{\Omega} =
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    y_t=0 & y_t=1 & y_t=2 & y_t=3\\ \hdashline
1 - p_B & p_B \beta_B & 0 & p_B (1-\beta_B) \\
1-p_{NB} & 0 & p_{NB} \beta_{NB} & p_{NB} (1-\beta_{NB})\\
1 & 0 & 0 & 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right )
    \begin{matrix}
    z_{t}=B \\ z_{t}=NB \\ z_{t}=D
    \end{matrix}
\end{matrix}
$$

$\beta_B$ is the probability to assign an individual in state B to state B. $\beta_{NB}$ is the probability to assign an individual in state NB to state NB. $p_B$ is the detection probability of breeders, $p_{NB}$ that of non-breeders.

The main difference between multistate and multievent models is here, in the observation parameters. We introduce two new parameters. $\delta_B$: prob. to correctly assign an indiv. that is in state B to state B, $\delta_{NB}$: prob. to correctly assign an indiv. that is in state NB to state NB. We put everything in a matrix, as usual. The observation matrix. In rows we have the states, breeding, non-breeding and dead. In columns, at the same occasion, we have the observation, detected and ascertained B,
detected and ascertained NB, detected and state unknown, and not detected. For example, the prob of being detected and assigned to the state B, given that you’re in state B is the product of the detection prob in B and delta the prob of correctly assigning a B individual to state B.

Because animals are all captured, $p_B = p_{NB} = 1$ at first encounter:

$$
\begin{matrix}
& \\
    \left ( \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right .
\end{matrix}
\hspace{-1.2em}
\begin{matrix}
    y_t=0 & y_t=1 & y_t=2 & y_t=3\\ \hdashline
 0 & \beta_B & 0 & (1-\beta_B)\\
0 & 0 & \beta_{NB} & (1-\beta_{NB})\\
1 & 0 & 0 & 0
\end{matrix}
\hspace{-0.2em}
\begin{matrix}
& \\
\left . \vphantom{ \begin{matrix} 12 \\ 12 \\ 12\end{matrix} } \right )
    \begin{matrix}
    z_{t}=B \\ z_{t}=NB \\ z_{t}=D
    \end{matrix}
\end{matrix}
$$

Note: Breeding assessment is unaffected. Then at first encounter, what happens is that step 1 of encounter is degenerate because individuals are all captured. Just set all the p’s to 1 in the encounter matrix. The breeding assessment matrix remains unchanged.

### NIMBLE implementation

Step 1:
```{r eval = FALSE}
multievent <- nimbleCode({
  # -------------------------------------------------
  # Parameters:
  # phiB: survival probability state B
  # phiNB: survival probability state NB
  # psiBNB: transition probability from B to NB
  # psiNBB: transition probability from NB to B
  # pB: recapture probability B
  # pNB: recapture probability NB
  # piB prob. of being in initial state breeder
  # betaNB prob to ascertain the breeding status of an individual encountered as non-breeder
  # betaB prob to ascertain the breeding status of an individual encountered as breeder
  # -------------------------------------------------
  # States (z):
  # 1 alive B
  # 2 alive NB
  # 3 dead
  # Observations (y):
  # 1 = non-detected
  # 2 = seen and ascertained as breeder
  # 3 = seen and ascertained as non-breeder
  # 4 = not ascertained
  # -------------------------------------------------
...
```

Step 2:
```{r eval = FALSE}
multievent <- nimbleCode({
...
  # Priors
  phiB ~ dunif(0, 1)
  phiNB ~ dunif(0, 1)
  psiBNB ~ dunif(0, 1)
  psiNBB ~ dunif(0, 1)
  pB ~ dunif(0, 1)
  pNB ~ dunif(0, 1)
  piB ~ dunif(0, 1)
  betaNB ~ dunif(0, 1)
  betaB ~ dunif(0, 1)
...
```

Step 3:
```{r eval = FALSE}
multievent <- nimbleCode({
...
  # vector of initial stats probs
  delta[1] <- piB # prob. of being in initial state B
  delta[2] <- 1 - piB # prob. of being in initial state NB
  delta[3] <- 0 # prob. of being in initial state dead
...
```

Step 4:
```{r eval = FALSE}
multievent <- nimbleCode({
...
  # probabilities of state z(t+1) given z(t)
  gamma[1,1] <- phiB * (1 - psiBNB)
  gamma[1,2] <- phiB * psiBNB
  gamma[1,3] <- 1 - phiB
  gamma[2,1] <- phiNB * psiNBB
  gamma[2,2] <- phiNB * (1 - psiNBB)
  gamma[2,3] <- 1 - phiNB
  gamma[3,1] <- 0
  gamma[3,2] <- 0
  gamma[3,3] <- 1
...
```

Step 5:
```{r eval = FALSE}
multievent <- nimbleCode({
...
  # probabilities of y(t) given z(t)
  omega[1,1] <- 1 - pB             # Pr(alive B t -> non-detected t)
  omega[1,2] <- pB * betaB         # Pr(alive B t -> detected B t)
  omega[1,3] <- 0                  # Pr(alive B t -> detected NB t)
  omega[1,4] <- pB * (1 - betaB)   # Pr(alive B t -> detected U t)
  omega[2,1] <- 1 - pNB            # Pr(alive NB t -> non-detected t)
  omega[2,2] <- 0                  # Pr(alive NB t -> detected B t)
  omega[2,3] <- pNB * betaNB       # Pr(alive NB t -> detected NB t)
  omega[2,4] <- pNB * (1 - betaNB) # Pr(alive NB t -> detected U t)
  omega[3,1] <- 1                  # Pr(dead t -> non-detected t)
  omega[3,2] <- 0                  # Pr(dead t -> detected N t)
  omega[3,3] <- 0                  # Pr(dead t -> detected NB t)
  omega[3,4] <- 0                  # Pr(dead t -> detected U t)
...
```

Step 6:
```{r eval = FALSE}
multievent <- nimbleCode({
...
  # probabilities of y(first) given z(first)
  omega.init[1,1] <- 0          # Pr(alive B t = 1 -> non-detected t = 1)
  omega.init[1,2] <- betaB      # Pr(alive B t = 1 -> detected B t = 1)
  omega.init[1,3] <- 0          # Pr(alive B t = 1 -> detected NB t = 1)
  omega.init[1,4] <- 1 - betaB  # Pr(alive B t = 1 -> detected U t = 1)
  omega.init[2,1] <- 0          # Pr(alive NB t = 1 -> non-detected t = 1)
  omega.init[2,2] <- 0          # Pr(alive NB t = 1 -> detected B t = 1)
  omega.init[2,3] <- betaNB     # Pr(alive NB t = 1 -> detected NB t = 1)
  omega.init[2,4] <- 1 - betaNB # Pr(alive NB t = 1 -> detected U t = 1)
  omega.init[3,1] <- 1          # Pr(dead t = 1 -> non-detected t = 1)
  omega.init[3,2] <- 0          # Pr(dead t = 1 -> detected N t = 1)
  omega.init[3,3] <- 0          # Pr(dead t = 1 -> detected NB t = 1)
  omega.init[3,4] <- 0          # Pr(dead t = 1 -> detected U t = 1)
...
```

Step 7:
```{r eval = FALSE}
multievent <- nimbleCode({
...
  # likelihood
  for (i in 1:N){
    # latent state at first capture
    z[i,first[i]] ~ dcat(delta[1:3])
    y[i,first[i]] ~ dcat(omega.init[z[i,first[i]],1:4])
    for (t in (first[i]+1):K){
      # z(t) given z(t-1)
      z[i,t] ~ dcat(gamma[z[i,t-1],1:3])
      # y(t) given z(t)
      y[i,t] ~ dcat(omega[z[i,t],1:4])
    }
  }
})
```

Results:

```{r echo = FALSE}
load(here::here("dat","titisuncertain.RData"))
```
```{r}
MCMCsummary(mcmc.multievent, round = 2)
```

Breeders are difficult to assigned to the correct state. Non-breeders are relatively well classified as non-breeders. No cost of breeding, neither on survival, nor on future reproduction.

**How to give the intuition of how/why it works. Use simulations?**

## Summary

+ Blabla.

+ Blabla.

## Suggested reading

+ Sites: @arnason1972, @arnason1973, @SchwarzEtAl1993. States: @NicholsEtAl1992 (microtus and mass as state); @NicholsEtAl1994 (microtus and reproductive costs). For a review of multistate models, see @LebretonEtAl2009. Titi paper @scofield2001titi. 

+ @evans2017elicit explain and provide Shiny app to elicit prior with Dirichlet. 

+ Uncertainty: Seminal paper by @pradel_multievent_2005. @dupuis_bayesian_1995 had a similar idea for the Arnason-Schwarz model. See also for a review @gimenez_estimating_2012.

